{"ast":null,"code":"/**\r\n * DevExtreme (esm/__internal/scheduler/timezones/m_utils_timezones_data.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { sign } from \"../../../core/utils/math\";\nimport GlobalConfig from \"../../../core/config\";\nconst getConvertedUntils = value => value.split(\"|\").map(until => {\n  if (\"Infinity\" === until) {\n    return null;\n  }\n  return 1e3 * parseInt(until, 36);\n});\nconst parseTimezone = timeZoneConfig => {\n  const {\n    offsets: offsets\n  } = timeZoneConfig;\n  const {\n    offsetIndices: offsetIndices\n  } = timeZoneConfig;\n  const {\n    untils: untils\n  } = timeZoneConfig;\n  const offsetList = offsets.split(\"|\").map(value => parseInt(value));\n  const offsetIndexList = offsetIndices.split(\"\").map(value => parseInt(value));\n  const dateList = getConvertedUntils(untils).map((accumulator = 0, value => accumulator += value));\n  var accumulator;\n  return {\n    offsetList: offsetList,\n    offsetIndexList: offsetIndexList,\n    dateList: dateList\n  };\n};\nclass TimeZoneCache {\n  constructor() {\n    this.map = new Map();\n  }\n  tryGet(id) {\n    if (!this.map.get(id)) {\n      const config = timeZoneDataUtils.getTimezoneById(id);\n      if (!config) {\n        return false;\n      }\n      const timeZoneInfo = parseTimezone(config);\n      this.map.set(id, timeZoneInfo);\n    }\n    return this.map.get(id);\n  }\n}\nconst tzCache = new TimeZoneCache();\nconst timeZoneDataUtils = {\n  _tzCache: tzCache,\n  getTimeZonesOld: () => GlobalConfig().timezones ?? [],\n  formatOffset(offset) {\n    const hours = Math.floor(offset);\n    const minutesInDecimal = offset - hours;\n    const signString = sign(offset) >= 0 ? \"+\" : \"-\";\n    const hoursString = `0${Math.abs(hours)}`.slice(-2);\n    const minutesString = minutesInDecimal > 0 ? \":\" + 60 * minutesInDecimal : \":00\";\n    return signString + hoursString + minutesString;\n  },\n  formatId: id => id.split(\"/\").join(\" - \").split(\"_\").join(\" \"),\n  getTimezoneById(id) {\n    if (!id) {\n      return;\n    }\n    const tzList = this.getTimeZonesOld();\n    for (let i = 0; i < tzList.length; i++) {\n      const currentId = tzList[i].id;\n      if (currentId === id) {\n        return tzList[i];\n      }\n    }\n    return;\n  },\n  getTimeZoneOffsetById(id, timestamp) {\n    const timeZoneInfo = tzCache.tryGet(id);\n    return timeZoneInfo ? this.getUtcOffset(timeZoneInfo, timestamp) : void 0;\n  },\n  getTimeZoneDeclarationTuple(id, year) {\n    const timeZoneInfo = tzCache.tryGet(id);\n    return timeZoneInfo ? this.getTimeZoneDeclarationTupleCore(timeZoneInfo, year) : [];\n  },\n  getTimeZoneDeclarationTupleCore(timeZoneInfo, year) {\n    const {\n      offsetList: offsetList\n    } = timeZoneInfo;\n    const {\n      offsetIndexList: offsetIndexList\n    } = timeZoneInfo;\n    const {\n      dateList: dateList\n    } = timeZoneInfo;\n    const tupleResult = [];\n    for (let i = 0; i < dateList.length; i++) {\n      const currentDate = dateList[i];\n      const currentYear = new Date(currentDate).getFullYear();\n      if (currentYear === year) {\n        const offset = offsetList[offsetIndexList[i + 1]];\n        tupleResult.push({\n          date: currentDate,\n          offset: -offset / 60\n        });\n      }\n      if (currentYear > year) {\n        break;\n      }\n    }\n    return tupleResult;\n  },\n  getUtcOffset(timeZoneInfo, dateTimeStamp) {\n    const {\n      offsetList: offsetList\n    } = timeZoneInfo;\n    const {\n      offsetIndexList: offsetIndexList\n    } = timeZoneInfo;\n    const {\n      dateList: dateList\n    } = timeZoneInfo;\n    const lastIntervalStartIndex = dateList.length - 1 - 1;\n    let index = lastIntervalStartIndex;\n    while (index >= 0 && dateTimeStamp < dateList[index]) {\n      index--;\n    }\n    const offset = offsetList[offsetIndexList[index + 1]];\n    return -offset / 60 || offset;\n  }\n};\nexport default timeZoneDataUtils;","map":{"version":3,"names":["sign","GlobalConfig","getConvertedUntils","value","split","map","until","parseInt","parseTimezone","timeZoneConfig","offsets","offsetIndices","untils","offsetList","offsetIndexList","dateList","accumulator","TimeZoneCache","constructor","Map","tryGet","id","get","config","timeZoneDataUtils","getTimezoneById","timeZoneInfo","set","tzCache","_tzCache","getTimeZonesOld","timezones","formatOffset","offset","hours","Math","floor","minutesInDecimal","signString","hoursString","abs","slice","minutesString","formatId","join","tzList","i","length","currentId","getTimeZoneOffsetById","timestamp","getUtcOffset","getTimeZoneDeclarationTuple","year","getTimeZoneDeclarationTupleCore","tupleResult","currentDate","currentYear","Date","getFullYear","push","date","dateTimeStamp","lastIntervalStartIndex","index"],"sources":["/home/nataf/Cours/world-cities-map/client/node_modules/devextreme/esm/__internal/scheduler/timezones/m_utils_timezones_data.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/__internal/scheduler/timezones/m_utils_timezones_data.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    sign\r\n} from \"../../../core/utils/math\";\r\nimport GlobalConfig from \"../../../core/config\";\r\nconst getConvertedUntils = value => value.split(\"|\").map((until => {\r\n    if (\"Infinity\" === until) {\r\n        return null\r\n    }\r\n    return 1e3 * parseInt(until, 36)\r\n}));\r\nconst parseTimezone = timeZoneConfig => {\r\n    const {\r\n        offsets: offsets\r\n    } = timeZoneConfig;\r\n    const {\r\n        offsetIndices: offsetIndices\r\n    } = timeZoneConfig;\r\n    const {\r\n        untils: untils\r\n    } = timeZoneConfig;\r\n    const offsetList = offsets.split(\"|\").map((value => parseInt(value)));\r\n    const offsetIndexList = offsetIndices.split(\"\").map((value => parseInt(value)));\r\n    const dateList = getConvertedUntils(untils).map((accumulator = 0, value => accumulator += value));\r\n    var accumulator;\r\n    return {\r\n        offsetList: offsetList,\r\n        offsetIndexList: offsetIndexList,\r\n        dateList: dateList\r\n    }\r\n};\r\nclass TimeZoneCache {\r\n    constructor() {\r\n        this.map = new Map\r\n    }\r\n    tryGet(id) {\r\n        if (!this.map.get(id)) {\r\n            const config = timeZoneDataUtils.getTimezoneById(id);\r\n            if (!config) {\r\n                return false\r\n            }\r\n            const timeZoneInfo = parseTimezone(config);\r\n            this.map.set(id, timeZoneInfo)\r\n        }\r\n        return this.map.get(id)\r\n    }\r\n}\r\nconst tzCache = new TimeZoneCache;\r\nconst timeZoneDataUtils = {\r\n    _tzCache: tzCache,\r\n    getTimeZonesOld: () => GlobalConfig().timezones ?? [],\r\n    formatOffset(offset) {\r\n        const hours = Math.floor(offset);\r\n        const minutesInDecimal = offset - hours;\r\n        const signString = sign(offset) >= 0 ? \"+\" : \"-\";\r\n        const hoursString = `0${Math.abs(hours)}`.slice(-2);\r\n        const minutesString = minutesInDecimal > 0 ? \":\" + 60 * minutesInDecimal : \":00\";\r\n        return signString + hoursString + minutesString\r\n    },\r\n    formatId: id => id.split(\"/\").join(\" - \").split(\"_\").join(\" \"),\r\n    getTimezoneById(id) {\r\n        if (!id) {\r\n            return\r\n        }\r\n        const tzList = this.getTimeZonesOld();\r\n        for (let i = 0; i < tzList.length; i++) {\r\n            const currentId = tzList[i].id;\r\n            if (currentId === id) {\r\n                return tzList[i]\r\n            }\r\n        }\r\n        return\r\n    },\r\n    getTimeZoneOffsetById(id, timestamp) {\r\n        const timeZoneInfo = tzCache.tryGet(id);\r\n        return timeZoneInfo ? this.getUtcOffset(timeZoneInfo, timestamp) : void 0\r\n    },\r\n    getTimeZoneDeclarationTuple(id, year) {\r\n        const timeZoneInfo = tzCache.tryGet(id);\r\n        return timeZoneInfo ? this.getTimeZoneDeclarationTupleCore(timeZoneInfo, year) : []\r\n    },\r\n    getTimeZoneDeclarationTupleCore(timeZoneInfo, year) {\r\n        const {\r\n            offsetList: offsetList\r\n        } = timeZoneInfo;\r\n        const {\r\n            offsetIndexList: offsetIndexList\r\n        } = timeZoneInfo;\r\n        const {\r\n            dateList: dateList\r\n        } = timeZoneInfo;\r\n        const tupleResult = [];\r\n        for (let i = 0; i < dateList.length; i++) {\r\n            const currentDate = dateList[i];\r\n            const currentYear = new Date(currentDate).getFullYear();\r\n            if (currentYear === year) {\r\n                const offset = offsetList[offsetIndexList[i + 1]];\r\n                tupleResult.push({\r\n                    date: currentDate,\r\n                    offset: -offset / 60\r\n                })\r\n            }\r\n            if (currentYear > year) {\r\n                break\r\n            }\r\n        }\r\n        return tupleResult\r\n    },\r\n    getUtcOffset(timeZoneInfo, dateTimeStamp) {\r\n        const {\r\n            offsetList: offsetList\r\n        } = timeZoneInfo;\r\n        const {\r\n            offsetIndexList: offsetIndexList\r\n        } = timeZoneInfo;\r\n        const {\r\n            dateList: dateList\r\n        } = timeZoneInfo;\r\n        const lastIntervalStartIndex = dateList.length - 1 - 1;\r\n        let index = lastIntervalStartIndex;\r\n        while (index >= 0 && dateTimeStamp < dateList[index]) {\r\n            index--\r\n        }\r\n        const offset = offsetList[offsetIndexList[index + 1]];\r\n        return -offset / 60 || offset\r\n    }\r\n};\r\nexport default timeZoneDataUtils;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}