{"ast":null,"code":"/**\r\n * DevExtreme (esm/common/core/animation/position.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { getOuterWidth, getOuterHeight, getWidth, getHeight } from \"../../../core/utils/size\";\nimport $ from \"../../../core/renderer\";\nimport { splitPair, pairToObject } from \"../../../core/utils/common\";\nimport { each } from \"../../../core/utils/iterator\";\nimport { getWindow } from \"../../../core/utils/window\";\nconst window = getWindow();\nimport domAdapter from \"../../../core/dom_adapter\";\nimport { isWindow, isDefined } from \"../../../core/utils/type\";\nimport { extend } from \"../../../core/utils/extend\";\nimport { getBoundingRect } from \"../../../core/utils/position\";\nimport browser from \"../../../core/utils/browser\";\nimport { resetPosition, move } from \"./translator\";\nimport { touch } from \"../../../core/utils/support\";\nimport devices from \"../../../core/devices\";\nimport { setStyle } from \"../../../core/utils/style\";\nconst horzRe = /left|right/;\nconst vertRe = /top|bottom/;\nconst collisionRe = /fit|flip|none/;\nconst scaleRe = /scale\\(.+?\\)/;\nconst IS_SAFARI = browser.safari;\nconst normalizeAlign = function (raw) {\n  const result = {\n    h: \"center\",\n    v: \"center\"\n  };\n  const pair = splitPair(raw);\n  if (pair) {\n    each(pair, function () {\n      const w = String(this).toLowerCase();\n      if (horzRe.test(w)) {\n        result.h = w;\n      } else if (vertRe.test(w)) {\n        result.v = w;\n      }\n    });\n  }\n  return result;\n};\nconst normalizeOffset = function (raw, preventRound) {\n  return pairToObject(raw, preventRound);\n};\nconst normalizeCollision = function (raw) {\n  const pair = splitPair(raw);\n  let h = String(pair && pair[0]).toLowerCase();\n  let v = String(pair && pair[1]).toLowerCase();\n  if (!collisionRe.test(h)) {\n    h = \"none\";\n  }\n  if (!collisionRe.test(v)) {\n    v = h;\n  }\n  return {\n    h: h,\n    v: v\n  };\n};\nconst getAlignFactor = function (align) {\n  switch (align) {\n    case \"center\":\n      return .5;\n    case \"right\":\n    case \"bottom\":\n      return 1;\n    default:\n      return 0;\n  }\n};\nconst inverseAlign = function (align) {\n  switch (align) {\n    case \"left\":\n      return \"right\";\n    case \"right\":\n      return \"left\";\n    case \"top\":\n      return \"bottom\";\n    case \"bottom\":\n      return \"top\";\n    default:\n      return align;\n  }\n};\nconst calculateOversize = function (data, bounds) {\n  let oversize = 0;\n  if (data.myLocation < bounds.min) {\n    oversize += bounds.min - data.myLocation;\n  }\n  if (data.myLocation > bounds.max) {\n    oversize += data.myLocation - bounds.max;\n  }\n  return oversize;\n};\nconst collisionSide = function (direction, data, bounds) {\n  if (data.myLocation < bounds.min) {\n    return \"h\" === direction ? \"left\" : \"top\";\n  }\n  if (data.myLocation > bounds.max) {\n    return \"h\" === direction ? \"right\" : \"bottom\";\n  }\n  return \"none\";\n};\nconst initMyLocation = function (data) {\n  data.myLocation = data.atLocation + getAlignFactor(data.atAlign) * data.atSize - getAlignFactor(data.myAlign) * data.mySize + data.offset;\n};\nconst collisionResolvers = {\n  fit: function (data, bounds) {\n    let result = false;\n    if (data.myLocation > bounds.max) {\n      data.myLocation = bounds.max;\n      result = true;\n    }\n    if (data.myLocation < bounds.min) {\n      data.myLocation = bounds.min;\n      result = true;\n    }\n    data.fit = result;\n  },\n  flip: function (data, bounds) {\n    data.flip = false;\n    if (\"center\" === data.myAlign && \"center\" === data.atAlign) {\n      return;\n    }\n    if (data.myLocation < bounds.min || data.myLocation > bounds.max) {\n      const inverseData = extend({}, data, {\n        myAlign: inverseAlign(data.myAlign),\n        atAlign: inverseAlign(data.atAlign),\n        offset: -data.offset\n      });\n      initMyLocation(inverseData);\n      inverseData.oversize = calculateOversize(inverseData, bounds);\n      if (inverseData.myLocation >= bounds.min && inverseData.myLocation <= bounds.max || data.oversize > inverseData.oversize) {\n        data.myLocation = inverseData.myLocation;\n        data.oversize = inverseData.oversize;\n        data.flip = true;\n      }\n    }\n  },\n  flipfit: function (data, bounds) {\n    this.flip(data, bounds);\n    this.fit(data, bounds);\n  },\n  none: function (data) {\n    data.oversize = 0;\n  }\n};\nlet scrollbarWidth;\nconst calculateScrollbarWidth = function () {\n  const $scrollDiv = $(\"<div>\").css({\n    width: 100,\n    height: 100,\n    overflow: \"scroll\",\n    position: \"absolute\",\n    top: -9999\n  }).appendTo($(\"body\"));\n  const result = $scrollDiv.get(0).offsetWidth - $scrollDiv.get(0).clientWidth;\n  $scrollDiv.remove();\n  scrollbarWidth = result;\n};\nconst defaultPositionResult = {\n  h: {\n    location: 0,\n    flip: false,\n    fit: false,\n    oversize: 0\n  },\n  v: {\n    location: 0,\n    flip: false,\n    fit: false,\n    oversize: 0\n  }\n};\nconst calculatePosition = function (what, options) {\n  const $what = $(what);\n  const currentOffset = $what.offset();\n  const result = extend(true, {}, defaultPositionResult, {\n    h: {\n      location: currentOffset.left\n    },\n    v: {\n      location: currentOffset.top\n    }\n  });\n  if (!options) {\n    return result;\n  }\n  const my = normalizeAlign(options.my);\n  const at = normalizeAlign(options.at);\n  let of = $(options.of).length && options.of || window;\n  const offset = normalizeOffset(options.offset, options.precise);\n  const collision = normalizeCollision(options.collision);\n  const boundary = options.boundary;\n  const boundaryOffset = normalizeOffset(options.boundaryOffset, options.precise);\n  const h = {\n    mySize: getOuterWidth($what),\n    myAlign: my.h,\n    atAlign: at.h,\n    offset: offset.h,\n    collision: collision.h,\n    boundaryOffset: boundaryOffset.h\n  };\n  const v = {\n    mySize: getOuterHeight($what),\n    myAlign: my.v,\n    atAlign: at.v,\n    offset: offset.v,\n    collision: collision.v,\n    boundaryOffset: boundaryOffset.v\n  };\n  if (of.preventDefault) {\n    h.atLocation = of.pageX;\n    v.atLocation = of.pageY;\n    h.atSize = 0;\n    v.atSize = 0;\n  } else {\n    of = $(of);\n    if (isWindow(of[0])) {\n      h.atLocation = of.scrollLeft();\n      v.atLocation = of.scrollTop();\n      if (\"phone\" === devices.real().deviceType && of[0].visualViewport) {\n        h.atLocation = Math.max(h.atLocation, of[0].visualViewport.offsetLeft);\n        v.atLocation = Math.max(v.atLocation, of[0].visualViewport.offsetTop);\n        h.atSize = of[0].visualViewport.width;\n        v.atSize = of[0].visualViewport.height;\n      } else {\n        h.atSize = of[0].innerWidth > of[0].outerWidth ? of[0].innerWidth : getWidth(of);\n        v.atSize = of[0].innerHeight > of[0].outerHeight || IS_SAFARI ? of[0].innerHeight : getHeight(of);\n      }\n    } else if (9 === of[0].nodeType) {\n      h.atLocation = 0;\n      v.atLocation = 0;\n      h.atSize = getWidth(of);\n      v.atSize = getHeight(of);\n    } else {\n      const ofRect = getBoundingRect(of.get(0));\n      const o = getOffsetWithoutScale(of);\n      h.atLocation = o.left;\n      v.atLocation = o.top;\n      h.atSize = Math.max(ofRect.width, getOuterWidth(of));\n      v.atSize = Math.max(ofRect.height, getOuterHeight(of));\n    }\n  }\n  initMyLocation(h);\n  initMyLocation(v);\n  const bounds = function () {\n    const win = $(window);\n    const windowWidth = getWidth(win);\n    const windowHeight = getHeight(win);\n    let left = win.scrollLeft();\n    let top = win.scrollTop();\n    const documentElement = domAdapter.getDocumentElement();\n    const hZoomLevel = touch ? documentElement.clientWidth / windowWidth : 1;\n    const vZoomLevel = touch ? documentElement.clientHeight / windowHeight : 1;\n    if (void 0 === scrollbarWidth) {\n      calculateScrollbarWidth();\n    }\n    let boundaryWidth = windowWidth;\n    let boundaryHeight = windowHeight;\n    if (boundary && !isWindow(boundary)) {\n      const $boundary = $(boundary);\n      const boundaryPosition = $boundary.offset();\n      left = boundaryPosition.left;\n      top = boundaryPosition.top;\n      boundaryWidth = getWidth($boundary);\n      boundaryHeight = getHeight($boundary);\n    }\n    return {\n      h: {\n        min: left + h.boundaryOffset,\n        max: left + boundaryWidth / hZoomLevel - h.mySize - h.boundaryOffset\n      },\n      v: {\n        min: top + v.boundaryOffset,\n        max: top + boundaryHeight / vZoomLevel - v.mySize - v.boundaryOffset\n      }\n    };\n  }();\n  h.oversize = calculateOversize(h, bounds.h);\n  v.oversize = calculateOversize(v, bounds.v);\n  h.collisionSide = collisionSide(\"h\", h, bounds.h);\n  v.collisionSide = collisionSide(\"v\", v, bounds.v);\n  if (collisionResolvers[h.collision]) {\n    collisionResolvers[h.collision](h, bounds.h);\n  }\n  if (collisionResolvers[v.collision]) {\n    collisionResolvers[v.collision](v, bounds.v);\n  }\n  const preciser = function (number) {\n    return options.precise ? number : Math.round(number);\n  };\n  extend(true, result, {\n    h: {\n      location: preciser(h.myLocation),\n      oversize: preciser(h.oversize),\n      fit: h.fit,\n      flip: h.flip,\n      collisionSide: h.collisionSide\n    },\n    v: {\n      location: preciser(v.myLocation),\n      oversize: preciser(v.oversize),\n      fit: v.fit,\n      flip: v.flip,\n      collisionSide: v.collisionSide\n    },\n    precise: options.precise\n  });\n  return result;\n};\nconst setScaleProperty = function (element, scale, styleAttr, isEmpty) {\n  const stylePropIsValid = isDefined(element.style) && !domAdapter.isNode(element.style);\n  const newStyleValue = isEmpty ? styleAttr.replace(scale, \"\") : styleAttr;\n  if (stylePropIsValid) {\n    setStyle(element, newStyleValue, false);\n  } else {\n    const styleAttributeNode = domAdapter.createAttribute(\"style\");\n    styleAttributeNode.value = newStyleValue;\n    element.setAttributeNode(styleAttributeNode);\n  }\n};\nconst getOffsetWithoutScale = function ($startElement) {\n  var _currentElement$getAt, _style$match;\n  let $currentElement = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : $startElement;\n  const currentElement = $currentElement.get(0);\n  if (!currentElement) {\n    return $startElement.offset();\n  }\n  const style = (null === (_currentElement$getAt = currentElement.getAttribute) || void 0 === _currentElement$getAt ? void 0 : _currentElement$getAt.call(currentElement, \"style\")) || \"\";\n  const scale = null === (_style$match = style.match(scaleRe)) || void 0 === _style$match ? void 0 : _style$match[0];\n  let offset;\n  if (scale) {\n    setScaleProperty(currentElement, scale, style, true);\n    offset = getOffsetWithoutScale($startElement, $currentElement.parent());\n    setScaleProperty(currentElement, scale, style, false);\n  } else {\n    offset = getOffsetWithoutScale($startElement, $currentElement.parent());\n  }\n  return offset;\n};\nconst position = function (what, options) {\n  const $what = $(what);\n  if (!options) {\n    return $what.offset();\n  }\n  resetPosition($what, true);\n  const offset = getOffsetWithoutScale($what);\n  const targetPosition = options.h && options.v ? options : calculatePosition($what, options);\n  const preciser = function (number) {\n    return options.precise ? number : Math.round(number);\n  };\n  move($what, {\n    left: targetPosition.h.location - preciser(offset.left),\n    top: targetPosition.v.location - preciser(offset.top)\n  });\n  return targetPosition;\n};\nconst offset = function (element) {\n  element = $(element).get(0);\n  if (isWindow(element)) {\n    return null;\n  } else if (element && \"pageY\" in element && \"pageX\" in element) {\n    return {\n      top: element.pageY,\n      left: element.pageX\n    };\n  }\n  return $(element).offset();\n};\nif (!position.inverseAlign) {\n  position.inverseAlign = inverseAlign;\n}\nif (!position.normalizeAlign) {\n  position.normalizeAlign = normalizeAlign;\n}\nexport default {\n  calculateScrollbarWidth: calculateScrollbarWidth,\n  calculate: calculatePosition,\n  setup: position,\n  offset: offset\n};","map":{"version":3,"names":["getOuterWidth","getOuterHeight","getWidth","getHeight","$","splitPair","pairToObject","each","getWindow","window","domAdapter","isWindow","isDefined","extend","getBoundingRect","browser","resetPosition","move","touch","devices","setStyle","horzRe","vertRe","collisionRe","scaleRe","IS_SAFARI","safari","normalizeAlign","raw","result","h","v","pair","w","String","toLowerCase","test","normalizeOffset","preventRound","normalizeCollision","getAlignFactor","align","inverseAlign","calculateOversize","data","bounds","oversize","myLocation","min","max","collisionSide","direction","initMyLocation","atLocation","atAlign","atSize","myAlign","mySize","offset","collisionResolvers","fit","flip","inverseData","flipfit","none","scrollbarWidth","calculateScrollbarWidth","$scrollDiv","css","width","height","overflow","position","top","appendTo","get","offsetWidth","clientWidth","remove","defaultPositionResult","location","calculatePosition","what","options","$what","currentOffset","left","my","at","of","length","precise","collision","boundary","boundaryOffset","preventDefault","pageX","pageY","scrollLeft","scrollTop","real","deviceType","visualViewport","Math","offsetLeft","offsetTop","innerWidth","outerWidth","innerHeight","outerHeight","nodeType","ofRect","o","getOffsetWithoutScale","win","windowWidth","windowHeight","documentElement","getDocumentElement","hZoomLevel","vZoomLevel","clientHeight","boundaryWidth","boundaryHeight","$boundary","boundaryPosition","preciser","number","round","setScaleProperty","element","scale","styleAttr","isEmpty","stylePropIsValid","style","isNode","newStyleValue","replace","styleAttributeNode","createAttribute","value","setAttributeNode","$startElement","_currentElement$getAt","_style$match","$currentElement","arguments","currentElement","getAttribute","call","match","parent","targetPosition","calculate","setup"],"sources":["/home/nataf/Cours/world-cities-map/client/node_modules/devextreme/esm/common/core/animation/position.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/common/core/animation/position.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    getOuterWidth,\r\n    getOuterHeight,\r\n    getWidth,\r\n    getHeight\r\n} from \"../../../core/utils/size\";\r\nimport $ from \"../../../core/renderer\";\r\nimport {\r\n    splitPair,\r\n    pairToObject\r\n} from \"../../../core/utils/common\";\r\nimport {\r\n    each\r\n} from \"../../../core/utils/iterator\";\r\nimport {\r\n    getWindow\r\n} from \"../../../core/utils/window\";\r\nconst window = getWindow();\r\nimport domAdapter from \"../../../core/dom_adapter\";\r\nimport {\r\n    isWindow,\r\n    isDefined\r\n} from \"../../../core/utils/type\";\r\nimport {\r\n    extend\r\n} from \"../../../core/utils/extend\";\r\nimport {\r\n    getBoundingRect\r\n} from \"../../../core/utils/position\";\r\nimport browser from \"../../../core/utils/browser\";\r\nimport {\r\n    resetPosition,\r\n    move\r\n} from \"./translator\";\r\nimport {\r\n    touch\r\n} from \"../../../core/utils/support\";\r\nimport devices from \"../../../core/devices\";\r\nimport {\r\n    setStyle\r\n} from \"../../../core/utils/style\";\r\nconst horzRe = /left|right/;\r\nconst vertRe = /top|bottom/;\r\nconst collisionRe = /fit|flip|none/;\r\nconst scaleRe = /scale\\(.+?\\)/;\r\nconst IS_SAFARI = browser.safari;\r\nconst normalizeAlign = function(raw) {\r\n    const result = {\r\n        h: \"center\",\r\n        v: \"center\"\r\n    };\r\n    const pair = splitPair(raw);\r\n    if (pair) {\r\n        each(pair, (function() {\r\n            const w = String(this).toLowerCase();\r\n            if (horzRe.test(w)) {\r\n                result.h = w\r\n            } else if (vertRe.test(w)) {\r\n                result.v = w\r\n            }\r\n        }))\r\n    }\r\n    return result\r\n};\r\nconst normalizeOffset = function(raw, preventRound) {\r\n    return pairToObject(raw, preventRound)\r\n};\r\nconst normalizeCollision = function(raw) {\r\n    const pair = splitPair(raw);\r\n    let h = String(pair && pair[0]).toLowerCase();\r\n    let v = String(pair && pair[1]).toLowerCase();\r\n    if (!collisionRe.test(h)) {\r\n        h = \"none\"\r\n    }\r\n    if (!collisionRe.test(v)) {\r\n        v = h\r\n    }\r\n    return {\r\n        h: h,\r\n        v: v\r\n    }\r\n};\r\nconst getAlignFactor = function(align) {\r\n    switch (align) {\r\n        case \"center\":\r\n            return .5;\r\n        case \"right\":\r\n        case \"bottom\":\r\n            return 1;\r\n        default:\r\n            return 0\r\n    }\r\n};\r\nconst inverseAlign = function(align) {\r\n    switch (align) {\r\n        case \"left\":\r\n            return \"right\";\r\n        case \"right\":\r\n            return \"left\";\r\n        case \"top\":\r\n            return \"bottom\";\r\n        case \"bottom\":\r\n            return \"top\";\r\n        default:\r\n            return align\r\n    }\r\n};\r\nconst calculateOversize = function(data, bounds) {\r\n    let oversize = 0;\r\n    if (data.myLocation < bounds.min) {\r\n        oversize += bounds.min - data.myLocation\r\n    }\r\n    if (data.myLocation > bounds.max) {\r\n        oversize += data.myLocation - bounds.max\r\n    }\r\n    return oversize\r\n};\r\nconst collisionSide = function(direction, data, bounds) {\r\n    if (data.myLocation < bounds.min) {\r\n        return \"h\" === direction ? \"left\" : \"top\"\r\n    }\r\n    if (data.myLocation > bounds.max) {\r\n        return \"h\" === direction ? \"right\" : \"bottom\"\r\n    }\r\n    return \"none\"\r\n};\r\nconst initMyLocation = function(data) {\r\n    data.myLocation = data.atLocation + getAlignFactor(data.atAlign) * data.atSize - getAlignFactor(data.myAlign) * data.mySize + data.offset\r\n};\r\nconst collisionResolvers = {\r\n    fit: function(data, bounds) {\r\n        let result = false;\r\n        if (data.myLocation > bounds.max) {\r\n            data.myLocation = bounds.max;\r\n            result = true\r\n        }\r\n        if (data.myLocation < bounds.min) {\r\n            data.myLocation = bounds.min;\r\n            result = true\r\n        }\r\n        data.fit = result\r\n    },\r\n    flip: function(data, bounds) {\r\n        data.flip = false;\r\n        if (\"center\" === data.myAlign && \"center\" === data.atAlign) {\r\n            return\r\n        }\r\n        if (data.myLocation < bounds.min || data.myLocation > bounds.max) {\r\n            const inverseData = extend({}, data, {\r\n                myAlign: inverseAlign(data.myAlign),\r\n                atAlign: inverseAlign(data.atAlign),\r\n                offset: -data.offset\r\n            });\r\n            initMyLocation(inverseData);\r\n            inverseData.oversize = calculateOversize(inverseData, bounds);\r\n            if (inverseData.myLocation >= bounds.min && inverseData.myLocation <= bounds.max || data.oversize > inverseData.oversize) {\r\n                data.myLocation = inverseData.myLocation;\r\n                data.oversize = inverseData.oversize;\r\n                data.flip = true\r\n            }\r\n        }\r\n    },\r\n    flipfit: function(data, bounds) {\r\n        this.flip(data, bounds);\r\n        this.fit(data, bounds)\r\n    },\r\n    none: function(data) {\r\n        data.oversize = 0\r\n    }\r\n};\r\nlet scrollbarWidth;\r\nconst calculateScrollbarWidth = function() {\r\n    const $scrollDiv = $(\"<div>\").css({\r\n        width: 100,\r\n        height: 100,\r\n        overflow: \"scroll\",\r\n        position: \"absolute\",\r\n        top: -9999\r\n    }).appendTo($(\"body\"));\r\n    const result = $scrollDiv.get(0).offsetWidth - $scrollDiv.get(0).clientWidth;\r\n    $scrollDiv.remove();\r\n    scrollbarWidth = result\r\n};\r\nconst defaultPositionResult = {\r\n    h: {\r\n        location: 0,\r\n        flip: false,\r\n        fit: false,\r\n        oversize: 0\r\n    },\r\n    v: {\r\n        location: 0,\r\n        flip: false,\r\n        fit: false,\r\n        oversize: 0\r\n    }\r\n};\r\nconst calculatePosition = function(what, options) {\r\n    const $what = $(what);\r\n    const currentOffset = $what.offset();\r\n    const result = extend(true, {}, defaultPositionResult, {\r\n        h: {\r\n            location: currentOffset.left\r\n        },\r\n        v: {\r\n            location: currentOffset.top\r\n        }\r\n    });\r\n    if (!options) {\r\n        return result\r\n    }\r\n    const my = normalizeAlign(options.my);\r\n    const at = normalizeAlign(options.at);\r\n    let of = $(options.of).length && options.of || window;\r\n    const offset = normalizeOffset(options.offset, options.precise);\r\n    const collision = normalizeCollision(options.collision);\r\n    const boundary = options.boundary;\r\n    const boundaryOffset = normalizeOffset(options.boundaryOffset, options.precise);\r\n    const h = {\r\n        mySize: getOuterWidth($what),\r\n        myAlign: my.h,\r\n        atAlign: at.h,\r\n        offset: offset.h,\r\n        collision: collision.h,\r\n        boundaryOffset: boundaryOffset.h\r\n    };\r\n    const v = {\r\n        mySize: getOuterHeight($what),\r\n        myAlign: my.v,\r\n        atAlign: at.v,\r\n        offset: offset.v,\r\n        collision: collision.v,\r\n        boundaryOffset: boundaryOffset.v\r\n    };\r\n    if (of.preventDefault) {\r\n        h.atLocation = of.pageX;\r\n        v.atLocation = of.pageY;\r\n        h.atSize = 0;\r\n        v.atSize = 0\r\n    } else {\r\n        of = $(of);\r\n        if (isWindow(of [0])) {\r\n            h.atLocation = of.scrollLeft();\r\n            v.atLocation = of.scrollTop();\r\n            if (\"phone\" === devices.real().deviceType && of [0].visualViewport) {\r\n                h.atLocation = Math.max(h.atLocation, of [0].visualViewport.offsetLeft);\r\n                v.atLocation = Math.max(v.atLocation, of [0].visualViewport.offsetTop);\r\n                h.atSize = of [0].visualViewport.width;\r\n                v.atSize = of [0].visualViewport.height\r\n            } else {\r\n                h.atSize = of [0].innerWidth > of [0].outerWidth ? of [0].innerWidth : getWidth(of);\r\n                v.atSize = of [0].innerHeight > of [0].outerHeight || IS_SAFARI ? of [0].innerHeight : getHeight(of)\r\n            }\r\n        } else if (9 === of [0].nodeType) {\r\n            h.atLocation = 0;\r\n            v.atLocation = 0;\r\n            h.atSize = getWidth(of);\r\n            v.atSize = getHeight(of)\r\n        } else {\r\n            const ofRect = getBoundingRect(of.get(0));\r\n            const o = getOffsetWithoutScale(of);\r\n            h.atLocation = o.left;\r\n            v.atLocation = o.top;\r\n            h.atSize = Math.max(ofRect.width, getOuterWidth(of));\r\n            v.atSize = Math.max(ofRect.height, getOuterHeight(of))\r\n        }\r\n    }\r\n    initMyLocation(h);\r\n    initMyLocation(v);\r\n    const bounds = function() {\r\n        const win = $(window);\r\n        const windowWidth = getWidth(win);\r\n        const windowHeight = getHeight(win);\r\n        let left = win.scrollLeft();\r\n        let top = win.scrollTop();\r\n        const documentElement = domAdapter.getDocumentElement();\r\n        const hZoomLevel = touch ? documentElement.clientWidth / windowWidth : 1;\r\n        const vZoomLevel = touch ? documentElement.clientHeight / windowHeight : 1;\r\n        if (void 0 === scrollbarWidth) {\r\n            calculateScrollbarWidth()\r\n        }\r\n        let boundaryWidth = windowWidth;\r\n        let boundaryHeight = windowHeight;\r\n        if (boundary && !isWindow(boundary)) {\r\n            const $boundary = $(boundary);\r\n            const boundaryPosition = $boundary.offset();\r\n            left = boundaryPosition.left;\r\n            top = boundaryPosition.top;\r\n            boundaryWidth = getWidth($boundary);\r\n            boundaryHeight = getHeight($boundary)\r\n        }\r\n        return {\r\n            h: {\r\n                min: left + h.boundaryOffset,\r\n                max: left + boundaryWidth / hZoomLevel - h.mySize - h.boundaryOffset\r\n            },\r\n            v: {\r\n                min: top + v.boundaryOffset,\r\n                max: top + boundaryHeight / vZoomLevel - v.mySize - v.boundaryOffset\r\n            }\r\n        }\r\n    }();\r\n    h.oversize = calculateOversize(h, bounds.h);\r\n    v.oversize = calculateOversize(v, bounds.v);\r\n    h.collisionSide = collisionSide(\"h\", h, bounds.h);\r\n    v.collisionSide = collisionSide(\"v\", v, bounds.v);\r\n    if (collisionResolvers[h.collision]) {\r\n        collisionResolvers[h.collision](h, bounds.h)\r\n    }\r\n    if (collisionResolvers[v.collision]) {\r\n        collisionResolvers[v.collision](v, bounds.v)\r\n    }\r\n    const preciser = function(number) {\r\n        return options.precise ? number : Math.round(number)\r\n    };\r\n    extend(true, result, {\r\n        h: {\r\n            location: preciser(h.myLocation),\r\n            oversize: preciser(h.oversize),\r\n            fit: h.fit,\r\n            flip: h.flip,\r\n            collisionSide: h.collisionSide\r\n        },\r\n        v: {\r\n            location: preciser(v.myLocation),\r\n            oversize: preciser(v.oversize),\r\n            fit: v.fit,\r\n            flip: v.flip,\r\n            collisionSide: v.collisionSide\r\n        },\r\n        precise: options.precise\r\n    });\r\n    return result\r\n};\r\nconst setScaleProperty = function(element, scale, styleAttr, isEmpty) {\r\n    const stylePropIsValid = isDefined(element.style) && !domAdapter.isNode(element.style);\r\n    const newStyleValue = isEmpty ? styleAttr.replace(scale, \"\") : styleAttr;\r\n    if (stylePropIsValid) {\r\n        setStyle(element, newStyleValue, false)\r\n    } else {\r\n        const styleAttributeNode = domAdapter.createAttribute(\"style\");\r\n        styleAttributeNode.value = newStyleValue;\r\n        element.setAttributeNode(styleAttributeNode)\r\n    }\r\n};\r\nconst getOffsetWithoutScale = function($startElement) {\r\n    var _currentElement$getAt, _style$match;\r\n    let $currentElement = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : $startElement;\r\n    const currentElement = $currentElement.get(0);\r\n    if (!currentElement) {\r\n        return $startElement.offset()\r\n    }\r\n    const style = (null === (_currentElement$getAt = currentElement.getAttribute) || void 0 === _currentElement$getAt ? void 0 : _currentElement$getAt.call(currentElement, \"style\")) || \"\";\r\n    const scale = null === (_style$match = style.match(scaleRe)) || void 0 === _style$match ? void 0 : _style$match[0];\r\n    let offset;\r\n    if (scale) {\r\n        setScaleProperty(currentElement, scale, style, true);\r\n        offset = getOffsetWithoutScale($startElement, $currentElement.parent());\r\n        setScaleProperty(currentElement, scale, style, false)\r\n    } else {\r\n        offset = getOffsetWithoutScale($startElement, $currentElement.parent())\r\n    }\r\n    return offset\r\n};\r\nconst position = function(what, options) {\r\n    const $what = $(what);\r\n    if (!options) {\r\n        return $what.offset()\r\n    }\r\n    resetPosition($what, true);\r\n    const offset = getOffsetWithoutScale($what);\r\n    const targetPosition = options.h && options.v ? options : calculatePosition($what, options);\r\n    const preciser = function(number) {\r\n        return options.precise ? number : Math.round(number)\r\n    };\r\n    move($what, {\r\n        left: targetPosition.h.location - preciser(offset.left),\r\n        top: targetPosition.v.location - preciser(offset.top)\r\n    });\r\n    return targetPosition\r\n};\r\nconst offset = function(element) {\r\n    element = $(element).get(0);\r\n    if (isWindow(element)) {\r\n        return null\r\n    } else if (element && \"pageY\" in element && \"pageX\" in element) {\r\n        return {\r\n            top: element.pageY,\r\n            left: element.pageX\r\n        }\r\n    }\r\n    return $(element).offset()\r\n};\r\nif (!position.inverseAlign) {\r\n    position.inverseAlign = inverseAlign\r\n}\r\nif (!position.normalizeAlign) {\r\n    position.normalizeAlign = normalizeAlign\r\n}\r\nexport default {\r\n    calculateScrollbarWidth: calculateScrollbarWidth,\r\n    calculate: calculatePosition,\r\n    setup: position,\r\n    offset: offset\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}