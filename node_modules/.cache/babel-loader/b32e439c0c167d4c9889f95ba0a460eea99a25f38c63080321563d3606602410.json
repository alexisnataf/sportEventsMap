{"ast":null,"code":"/**\r\n * DevExtreme (esm/__internal/events/gesture/m_emitter.gesture.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport Emitter from \"../../../common/core/events/core/emitter\";\nimport eventsEngine from \"../../../common/core/events/core/events_engine\";\nimport { createEvent, eventData, eventDelta, isDxMouseWheelEvent, isTouchEvent, needSkipEvent } from \"../../../common/core/events/utils/index\";\nimport $ from \"../../../core/renderer\";\nimport callOnce from \"../../../core/utils/call_once\";\nimport { noop } from \"../../../core/utils/common\";\nimport { sign } from \"../../../core/utils/math\";\nimport readyCallbacks from \"../../../core/utils/ready_callbacks\";\nimport { styleProp } from \"../../../core/utils/style\";\nimport { isDefined } from \"../../../core/utils/type\";\nimport devices from \"../../core/m_devices\";\nimport domUtils from \"../../core/utils/m_dom\";\nconst ready = readyCallbacks.add;\nconst {\n  abs: abs\n} = Math;\nconst SLEEP = 0;\nconst INITED = 1;\nconst STARTED = 2;\nlet TOUCH_BOUNDARY = 10;\nconst IMMEDIATE_TOUCH_BOUNDARY = 0;\nconst IMMEDIATE_TIMEOUT = 180;\nconst supportPointerEvents = function () {\n  return styleProp(\"pointer-events\");\n};\nconst setGestureCover = callOnce(() => {\n  const isDesktop = \"desktop\" === devices.real().deviceType;\n  if (!supportPointerEvents() || !isDesktop) {\n    return noop;\n  }\n  const $cover = $(\"<div>\").addClass(\"dx-gesture-cover\").css(\"pointerEvents\", \"none\");\n  eventsEngine.subscribeGlobal($cover, \"dxmousewheel\", e => {\n    e.preventDefault();\n  });\n  ready(() => {\n    $cover.appendTo(\"body\");\n  });\n  return function (toggle, cursor) {\n    $cover.css(\"pointerEvents\", toggle ? \"all\" : \"none\");\n    toggle && $cover.css(\"cursor\", cursor);\n  };\n});\nconst gestureCover = function (toggle, cursor) {\n  const gestureCoverStrategy = setGestureCover();\n  gestureCoverStrategy(toggle, cursor);\n};\nconst GestureEmitter = Emitter.inherit({\n  gesture: true,\n  configure(data) {\n    this.getElement().css(\"msTouchAction\", data.immediate ? \"pinch-zoom\" : \"\");\n    this.callBase(data);\n  },\n  allowInterruptionByMouseWheel() {\n    return 2 !== this._stage;\n  },\n  getDirection() {\n    return this.direction;\n  },\n  _cancel() {\n    this.callBase.apply(this, arguments);\n    this._toggleGestureCover(false);\n    this._stage = 0;\n  },\n  start(e) {\n    if (e._needSkipEvent || needSkipEvent(e)) {\n      this._cancel(e);\n      return;\n    }\n    this._startEvent = createEvent(e);\n    this._startEventData = eventData(e);\n    this._stage = 1;\n    this._init(e);\n    this._setupImmediateTimer();\n  },\n  _setupImmediateTimer() {\n    clearTimeout(this._immediateTimer);\n    this._immediateAccepted = false;\n    if (!this.immediate) {\n      return;\n    }\n    if (0 === this.immediateTimeout) {\n      this._immediateAccepted = true;\n      return;\n    }\n    this._immediateTimer = setTimeout(() => {\n      this._immediateAccepted = true;\n    }, this.immediateTimeout ?? 180);\n  },\n  move(e) {\n    if (1 === this._stage && this._directionConfirmed(e)) {\n      this._stage = 2;\n      this._resetActiveElement();\n      this._toggleGestureCover(true);\n      this._clearSelection(e);\n      this._adjustStartEvent(e);\n      this._start(this._startEvent);\n      if (0 === this._stage) {\n        return;\n      }\n      this._requestAccept(e);\n      this._move(e);\n      this._forgetAccept();\n    } else if (2 === this._stage) {\n      this._clearSelection(e);\n      this._move(e);\n    }\n  },\n  _directionConfirmed(e) {\n    const touchBoundary = this._getTouchBoundary(e);\n    const delta = eventDelta(this._startEventData, eventData(e));\n    const deltaX = abs(delta.x);\n    const deltaY = abs(delta.y);\n    const horizontalMove = this._validateMove(touchBoundary, deltaX, deltaY);\n    const verticalMove = this._validateMove(touchBoundary, deltaY, deltaX);\n    const direction = this.getDirection(e);\n    const bothAccepted = \"both\" === direction && (horizontalMove || verticalMove);\n    const horizontalAccepted = \"horizontal\" === direction && horizontalMove;\n    const verticalAccepted = \"vertical\" === direction && verticalMove;\n    return bothAccepted || horizontalAccepted || verticalAccepted || this._immediateAccepted;\n  },\n  _validateMove(touchBoundary, mainAxis, crossAxis) {\n    return mainAxis && mainAxis >= touchBoundary && (this.immediate ? mainAxis >= crossAxis : true);\n  },\n  _getTouchBoundary(e) {\n    return this.immediate || isDxMouseWheelEvent(e) ? 0 : TOUCH_BOUNDARY;\n  },\n  _adjustStartEvent(e) {\n    const touchBoundary = this._getTouchBoundary(e);\n    const delta = eventDelta(this._startEventData, eventData(e));\n    this._startEvent.pageX += sign(delta.x) * touchBoundary;\n    this._startEvent.pageY += sign(delta.y) * touchBoundary;\n  },\n  _resetActiveElement() {\n    if (\"ios\" === devices.real().platform && this.getElement().find(\":focus\").length) {\n      domUtils.resetActiveElement();\n    }\n  },\n  _toggleGestureCover(toggle) {\n    this._toggleGestureCoverImpl(toggle);\n  },\n  _toggleGestureCoverImpl(toggle) {\n    const isStarted = 2 === this._stage;\n    if (isStarted) {\n      gestureCover(toggle, this.getElement().css(\"cursor\"));\n    }\n  },\n  _clearSelection(e) {\n    if (isDxMouseWheelEvent(e) || isTouchEvent(e)) {\n      return;\n    }\n    domUtils.clearSelection();\n  },\n  end(e) {\n    this._toggleGestureCover(false);\n    if (2 === this._stage) {\n      this._end(e);\n    } else if (1 === this._stage) {\n      this._stop(e);\n    }\n    this._stage = 0;\n  },\n  dispose() {\n    clearTimeout(this._immediateTimer);\n    this.callBase.apply(this, arguments);\n    this._toggleGestureCover(false);\n  },\n  _init: noop,\n  _start: noop,\n  _move: noop,\n  _stop: noop,\n  _end: noop\n});\nGestureEmitter.initialTouchBoundary = TOUCH_BOUNDARY;\nGestureEmitter.touchBoundary = function (newBoundary) {\n  if (isDefined(newBoundary)) {\n    TOUCH_BOUNDARY = newBoundary;\n    return;\n  }\n  return TOUCH_BOUNDARY;\n};\nexport default GestureEmitter;","map":{"version":3,"names":["Emitter","eventsEngine","createEvent","eventData","eventDelta","isDxMouseWheelEvent","isTouchEvent","needSkipEvent","$","callOnce","noop","sign","readyCallbacks","styleProp","isDefined","devices","domUtils","ready","add","abs","Math","SLEEP","INITED","STARTED","TOUCH_BOUNDARY","IMMEDIATE_TOUCH_BOUNDARY","IMMEDIATE_TIMEOUT","supportPointerEvents","setGestureCover","isDesktop","real","deviceType","$cover","addClass","css","subscribeGlobal","e","preventDefault","appendTo","toggle","cursor","gestureCover","gestureCoverStrategy","GestureEmitter","inherit","gesture","configure","data","getElement","immediate","callBase","allowInterruptionByMouseWheel","_stage","getDirection","direction","_cancel","apply","arguments","_toggleGestureCover","start","_needSkipEvent","_startEvent","_startEventData","_init","_setupImmediateTimer","clearTimeout","_immediateTimer","_immediateAccepted","immediateTimeout","setTimeout","move","_directionConfirmed","_resetActiveElement","_clearSelection","_adjustStartEvent","_start","_requestAccept","_move","_forgetAccept","touchBoundary","_getTouchBoundary","delta","deltaX","x","deltaY","y","horizontalMove","_validateMove","verticalMove","bothAccepted","horizontalAccepted","verticalAccepted","mainAxis","crossAxis","pageX","pageY","platform","find","length","resetActiveElement","_toggleGestureCoverImpl","isStarted","clearSelection","end","_end","_stop","dispose","initialTouchBoundary","newBoundary"],"sources":["/home/nataf/Cours/world-cities-map/client/node_modules/devextreme/esm/__internal/events/gesture/m_emitter.gesture.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/__internal/events/gesture/m_emitter.gesture.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport Emitter from \"../../../common/core/events/core/emitter\";\r\nimport eventsEngine from \"../../../common/core/events/core/events_engine\";\r\nimport {\r\n    createEvent,\r\n    eventData,\r\n    eventDelta,\r\n    isDxMouseWheelEvent,\r\n    isTouchEvent,\r\n    needSkipEvent\r\n} from \"../../../common/core/events/utils/index\";\r\nimport $ from \"../../../core/renderer\";\r\nimport callOnce from \"../../../core/utils/call_once\";\r\nimport {\r\n    noop\r\n} from \"../../../core/utils/common\";\r\nimport {\r\n    sign\r\n} from \"../../../core/utils/math\";\r\nimport readyCallbacks from \"../../../core/utils/ready_callbacks\";\r\nimport {\r\n    styleProp\r\n} from \"../../../core/utils/style\";\r\nimport {\r\n    isDefined\r\n} from \"../../../core/utils/type\";\r\nimport devices from \"../../core/m_devices\";\r\nimport domUtils from \"../../core/utils/m_dom\";\r\nconst ready = readyCallbacks.add;\r\nconst {\r\n    abs: abs\r\n} = Math;\r\nconst SLEEP = 0;\r\nconst INITED = 1;\r\nconst STARTED = 2;\r\nlet TOUCH_BOUNDARY = 10;\r\nconst IMMEDIATE_TOUCH_BOUNDARY = 0;\r\nconst IMMEDIATE_TIMEOUT = 180;\r\nconst supportPointerEvents = function() {\r\n    return styleProp(\"pointer-events\")\r\n};\r\nconst setGestureCover = callOnce((() => {\r\n    const isDesktop = \"desktop\" === devices.real().deviceType;\r\n    if (!supportPointerEvents() || !isDesktop) {\r\n        return noop\r\n    }\r\n    const $cover = $(\"<div>\").addClass(\"dx-gesture-cover\").css(\"pointerEvents\", \"none\");\r\n    eventsEngine.subscribeGlobal($cover, \"dxmousewheel\", (e => {\r\n        e.preventDefault()\r\n    }));\r\n    ready((() => {\r\n        $cover.appendTo(\"body\")\r\n    }));\r\n    return function(toggle, cursor) {\r\n        $cover.css(\"pointerEvents\", toggle ? \"all\" : \"none\");\r\n        toggle && $cover.css(\"cursor\", cursor)\r\n    }\r\n}));\r\nconst gestureCover = function(toggle, cursor) {\r\n    const gestureCoverStrategy = setGestureCover();\r\n    gestureCoverStrategy(toggle, cursor)\r\n};\r\nconst GestureEmitter = Emitter.inherit({\r\n    gesture: true,\r\n    configure(data) {\r\n        this.getElement().css(\"msTouchAction\", data.immediate ? \"pinch-zoom\" : \"\");\r\n        this.callBase(data)\r\n    },\r\n    allowInterruptionByMouseWheel() {\r\n        return 2 !== this._stage\r\n    },\r\n    getDirection() {\r\n        return this.direction\r\n    },\r\n    _cancel() {\r\n        this.callBase.apply(this, arguments);\r\n        this._toggleGestureCover(false);\r\n        this._stage = 0\r\n    },\r\n    start(e) {\r\n        if (e._needSkipEvent || needSkipEvent(e)) {\r\n            this._cancel(e);\r\n            return\r\n        }\r\n        this._startEvent = createEvent(e);\r\n        this._startEventData = eventData(e);\r\n        this._stage = 1;\r\n        this._init(e);\r\n        this._setupImmediateTimer()\r\n    },\r\n    _setupImmediateTimer() {\r\n        clearTimeout(this._immediateTimer);\r\n        this._immediateAccepted = false;\r\n        if (!this.immediate) {\r\n            return\r\n        }\r\n        if (0 === this.immediateTimeout) {\r\n            this._immediateAccepted = true;\r\n            return\r\n        }\r\n        this._immediateTimer = setTimeout((() => {\r\n            this._immediateAccepted = true\r\n        }), this.immediateTimeout ?? 180)\r\n    },\r\n    move(e) {\r\n        if (1 === this._stage && this._directionConfirmed(e)) {\r\n            this._stage = 2;\r\n            this._resetActiveElement();\r\n            this._toggleGestureCover(true);\r\n            this._clearSelection(e);\r\n            this._adjustStartEvent(e);\r\n            this._start(this._startEvent);\r\n            if (0 === this._stage) {\r\n                return\r\n            }\r\n            this._requestAccept(e);\r\n            this._move(e);\r\n            this._forgetAccept()\r\n        } else if (2 === this._stage) {\r\n            this._clearSelection(e);\r\n            this._move(e)\r\n        }\r\n    },\r\n    _directionConfirmed(e) {\r\n        const touchBoundary = this._getTouchBoundary(e);\r\n        const delta = eventDelta(this._startEventData, eventData(e));\r\n        const deltaX = abs(delta.x);\r\n        const deltaY = abs(delta.y);\r\n        const horizontalMove = this._validateMove(touchBoundary, deltaX, deltaY);\r\n        const verticalMove = this._validateMove(touchBoundary, deltaY, deltaX);\r\n        const direction = this.getDirection(e);\r\n        const bothAccepted = \"both\" === direction && (horizontalMove || verticalMove);\r\n        const horizontalAccepted = \"horizontal\" === direction && horizontalMove;\r\n        const verticalAccepted = \"vertical\" === direction && verticalMove;\r\n        return bothAccepted || horizontalAccepted || verticalAccepted || this._immediateAccepted\r\n    },\r\n    _validateMove(touchBoundary, mainAxis, crossAxis) {\r\n        return mainAxis && mainAxis >= touchBoundary && (this.immediate ? mainAxis >= crossAxis : true)\r\n    },\r\n    _getTouchBoundary(e) {\r\n        return this.immediate || isDxMouseWheelEvent(e) ? 0 : TOUCH_BOUNDARY\r\n    },\r\n    _adjustStartEvent(e) {\r\n        const touchBoundary = this._getTouchBoundary(e);\r\n        const delta = eventDelta(this._startEventData, eventData(e));\r\n        this._startEvent.pageX += sign(delta.x) * touchBoundary;\r\n        this._startEvent.pageY += sign(delta.y) * touchBoundary\r\n    },\r\n    _resetActiveElement() {\r\n        if (\"ios\" === devices.real().platform && this.getElement().find(\":focus\").length) {\r\n            domUtils.resetActiveElement()\r\n        }\r\n    },\r\n    _toggleGestureCover(toggle) {\r\n        this._toggleGestureCoverImpl(toggle)\r\n    },\r\n    _toggleGestureCoverImpl(toggle) {\r\n        const isStarted = 2 === this._stage;\r\n        if (isStarted) {\r\n            gestureCover(toggle, this.getElement().css(\"cursor\"))\r\n        }\r\n    },\r\n    _clearSelection(e) {\r\n        if (isDxMouseWheelEvent(e) || isTouchEvent(e)) {\r\n            return\r\n        }\r\n        domUtils.clearSelection()\r\n    },\r\n    end(e) {\r\n        this._toggleGestureCover(false);\r\n        if (2 === this._stage) {\r\n            this._end(e)\r\n        } else if (1 === this._stage) {\r\n            this._stop(e)\r\n        }\r\n        this._stage = 0\r\n    },\r\n    dispose() {\r\n        clearTimeout(this._immediateTimer);\r\n        this.callBase.apply(this, arguments);\r\n        this._toggleGestureCover(false)\r\n    },\r\n    _init: noop,\r\n    _start: noop,\r\n    _move: noop,\r\n    _stop: noop,\r\n    _end: noop\r\n});\r\nGestureEmitter.initialTouchBoundary = TOUCH_BOUNDARY;\r\nGestureEmitter.touchBoundary = function(newBoundary) {\r\n    if (isDefined(newBoundary)) {\r\n        TOUCH_BOUNDARY = newBoundary;\r\n        return\r\n    }\r\n    return TOUCH_BOUNDARY\r\n};\r\nexport default GestureEmitter;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}