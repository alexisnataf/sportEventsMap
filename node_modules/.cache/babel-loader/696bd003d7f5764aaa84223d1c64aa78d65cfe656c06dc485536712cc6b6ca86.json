{"ast":null,"code":"/**\r\n * DevExtreme (esm/__internal/core/utils/m_date_serialization.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport defaultDateNames from \"../../../common/core/localization/default_date_names\";\nimport { getFormatter as getLDMLFormatter } from \"../../../common/core/localization/ldml/date.formatter\";\nimport config from \"../../../core/config\";\nimport { isDate, isNumeric as isNumber, isString } from \"../../../core/utils/type\";\nconst NUMBER_SERIALIZATION_FORMAT = \"number\";\nconst DATE_SERIALIZATION_FORMAT = \"yyyy/MM/dd\";\nconst DATETIME_SERIALIZATION_FORMAT = \"yyyy/MM/dd HH:mm:ss\";\nconst ISO8601_PATTERN = /^(\\d{4,})(-)?(\\d{2})(-)?(\\d{2})(?:T(\\d{2})(:)?(\\d{2})?(:)?(\\d{2}(?:\\.(\\d{1,3})\\d*)?)?)?(Z|([+-])(\\d{2})(:)?(\\d{2})?)?$/;\nconst ISO8601_TIME_PATTERN = /^(\\d{2}):(\\d{2})(:(\\d{2}))?$/;\nconst ISO8601_PATTERN_PARTS = [\"\", \"yyyy\", \"\", \"MM\", \"\", \"dd\", \"THH\", \"\", \"mm\", \"\", \"ss\", \".SSS\"];\nconst DATE_SERIALIZATION_PATTERN = /^(\\d{4})\\/(\\d{2})\\/(\\d{2})$/;\nconst MILLISECOND_LENGHT = 3;\nconst dateParser = function (text, skipISO8601Parsing) {\n  let result;\n  if (isString(text) && !skipISO8601Parsing) {\n    result = parseISO8601String(text);\n  }\n  return result || parseDate(text);\n};\nfunction getTimePart(part) {\n  return +part || 0;\n}\nfunction parseDate(text) {\n  const isDefaultSerializationFormat = \"yyyy/MM/dd\" === getDateSerializationFormat(text);\n  const parsedValue = !isDate(text) && Date.parse(text);\n  if (!parsedValue && isDefaultSerializationFormat) {\n    const parts = text.match(DATE_SERIALIZATION_PATTERN);\n    if (parts) {\n      const newDate = new Date(getTimePart(parts[1]), getTimePart(parts[2]), getTimePart(parts[3]));\n      newDate.setFullYear(getTimePart(parts[1]));\n      newDate.setMonth(getTimePart(parts[2]) - 1);\n      newDate.setDate(getTimePart(parts[3]));\n      return newDate;\n    }\n  }\n  return isNumber(parsedValue) ? new Date(parsedValue) : text;\n}\nfunction parseISO8601String(text) {\n  let parts = text.match(ISO8601_PATTERN);\n  if (!parts) {\n    parts = text.match(ISO8601_TIME_PATTERN);\n    if (parts) {\n      return new Date(0, 0, 0, getTimePart(parts[1]), getTimePart(parts[2]), getTimePart(parts[4]));\n    }\n    return;\n  }\n  const year = getTimePart(parts[1]);\n  const month = --parts[3];\n  const day = parts[5];\n  let timeZoneHour = 0;\n  let timeZoneMinute = 0;\n  const correctYear = d => {\n    year < 100 && d.setFullYear(year);\n    return d;\n  };\n  timeZoneHour = getTimePart(parts[14]);\n  timeZoneMinute = getTimePart(parts[16]);\n  if (\"-\" === parts[13]) {\n    timeZoneHour = -timeZoneHour;\n    timeZoneMinute = -timeZoneMinute;\n  }\n  const hour = getTimePart(parts[6]) - timeZoneHour;\n  const minute = getTimePart(parts[8]) - timeZoneMinute;\n  const second = getTimePart(parts[10]);\n  const millisecond = function (part) {\n    part = part || \"\";\n    return getTimePart(part) * 10 ** (3 - part.length);\n  }(parts[11]);\n  if (parts[12]) {\n    return correctYear(new Date(Date.UTC(year, month, day, hour, minute, second, millisecond)));\n  }\n  return correctYear(new Date(year, month, day, hour, minute, second, millisecond));\n}\nconst getIso8601Format = function (text, useUtc) {\n  let parts = text.match(ISO8601_PATTERN);\n  let result = \"\";\n  if (!parts) {\n    parts = text.match(ISO8601_TIME_PATTERN);\n    if (parts) {\n      return parts[3] ? \"HH:mm:ss\" : \"HH:mm\";\n    }\n    return;\n  }\n  for (let i = 1; i < ISO8601_PATTERN_PARTS.length; i++) {\n    if (parts[i]) {\n      result += ISO8601_PATTERN_PARTS[i] || parts[i];\n    }\n  }\n  if (\"Z\" === parts[12]) {\n    result += \"'Z'\";\n  }\n  if (parts[14]) {\n    if (parts[15]) {\n      result += \"xxx\";\n    } else if (parts[16]) {\n      result += \"xx\";\n    } else {\n      result += \"x\";\n    }\n  }\n  return result;\n};\nconst deserializeDate = function (value) {\n  if (\"number\" === typeof value) {\n    return new Date(value);\n  }\n  return dateParser(value, !config().forceIsoDateParsing);\n};\nconst serializeDate = function (value, serializationFormat) {\n  if (!serializationFormat) {\n    return value;\n  }\n  if (!isDate(value)) {\n    return null;\n  }\n  if (\"number\" === serializationFormat) {\n    return value && value.valueOf ? value.valueOf() : null;\n  }\n  return getLDMLFormatter(serializationFormat, defaultDateNames)(value);\n};\nconst getDateSerializationFormat = function (value) {\n  if (\"number\" === typeof value) {\n    return \"number\";\n  }\n  if (isString(value)) {\n    let format;\n    if (config().forceIsoDateParsing) {\n      format = getIso8601Format(value);\n    }\n    if (format) {\n      return format;\n    }\n    if (value.includes(\":\")) {\n      return \"yyyy/MM/dd HH:mm:ss\";\n    }\n    return \"yyyy/MM/dd\";\n  }\n  if (value) {\n    return null;\n  }\n};\nconst dateSerialization = {\n  dateParser: dateParser,\n  deserializeDate: deserializeDate,\n  serializeDate: serializeDate,\n  getDateSerializationFormat: getDateSerializationFormat\n};\nexport { dateSerialization };","map":{"version":3,"names":["defaultDateNames","getFormatter","getLDMLFormatter","config","isDate","isNumeric","isNumber","isString","NUMBER_SERIALIZATION_FORMAT","DATE_SERIALIZATION_FORMAT","DATETIME_SERIALIZATION_FORMAT","ISO8601_PATTERN","ISO8601_TIME_PATTERN","ISO8601_PATTERN_PARTS","DATE_SERIALIZATION_PATTERN","MILLISECOND_LENGHT","dateParser","text","skipISO8601Parsing","result","parseISO8601String","parseDate","getTimePart","part","isDefaultSerializationFormat","getDateSerializationFormat","parsedValue","Date","parse","parts","match","newDate","setFullYear","setMonth","setDate","year","month","day","timeZoneHour","timeZoneMinute","correctYear","d","hour","minute","second","millisecond","length","UTC","getIso8601Format","useUtc","i","deserializeDate","value","forceIsoDateParsing","serializeDate","serializationFormat","valueOf","format","includes","dateSerialization"],"sources":["/home/nataf/Cours/world-cities-map/client/node_modules/devextreme/esm/__internal/core/utils/m_date_serialization.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/__internal/core/utils/m_date_serialization.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport defaultDateNames from \"../../../common/core/localization/default_date_names\";\r\nimport {\r\n    getFormatter as getLDMLFormatter\r\n} from \"../../../common/core/localization/ldml/date.formatter\";\r\nimport config from \"../../../core/config\";\r\nimport {\r\n    isDate,\r\n    isNumeric as isNumber,\r\n    isString\r\n} from \"../../../core/utils/type\";\r\nconst NUMBER_SERIALIZATION_FORMAT = \"number\";\r\nconst DATE_SERIALIZATION_FORMAT = \"yyyy/MM/dd\";\r\nconst DATETIME_SERIALIZATION_FORMAT = \"yyyy/MM/dd HH:mm:ss\";\r\nconst ISO8601_PATTERN = /^(\\d{4,})(-)?(\\d{2})(-)?(\\d{2})(?:T(\\d{2})(:)?(\\d{2})?(:)?(\\d{2}(?:\\.(\\d{1,3})\\d*)?)?)?(Z|([+-])(\\d{2})(:)?(\\d{2})?)?$/;\r\nconst ISO8601_TIME_PATTERN = /^(\\d{2}):(\\d{2})(:(\\d{2}))?$/;\r\nconst ISO8601_PATTERN_PARTS = [\"\", \"yyyy\", \"\", \"MM\", \"\", \"dd\", \"THH\", \"\", \"mm\", \"\", \"ss\", \".SSS\"];\r\nconst DATE_SERIALIZATION_PATTERN = /^(\\d{4})\\/(\\d{2})\\/(\\d{2})$/;\r\nconst MILLISECOND_LENGHT = 3;\r\nconst dateParser = function(text, skipISO8601Parsing) {\r\n    let result;\r\n    if (isString(text) && !skipISO8601Parsing) {\r\n        result = parseISO8601String(text)\r\n    }\r\n    return result || parseDate(text)\r\n};\r\n\r\nfunction getTimePart(part) {\r\n    return +part || 0\r\n}\r\n\r\nfunction parseDate(text) {\r\n    const isDefaultSerializationFormat = \"yyyy/MM/dd\" === getDateSerializationFormat(text);\r\n    const parsedValue = !isDate(text) && Date.parse(text);\r\n    if (!parsedValue && isDefaultSerializationFormat) {\r\n        const parts = text.match(DATE_SERIALIZATION_PATTERN);\r\n        if (parts) {\r\n            const newDate = new Date(getTimePart(parts[1]), getTimePart(parts[2]), getTimePart(parts[3]));\r\n            newDate.setFullYear(getTimePart(parts[1]));\r\n            newDate.setMonth(getTimePart(parts[2]) - 1);\r\n            newDate.setDate(getTimePart(parts[3]));\r\n            return newDate\r\n        }\r\n    }\r\n    return isNumber(parsedValue) ? new Date(parsedValue) : text\r\n}\r\n\r\nfunction parseISO8601String(text) {\r\n    let parts = text.match(ISO8601_PATTERN);\r\n    if (!parts) {\r\n        parts = text.match(ISO8601_TIME_PATTERN);\r\n        if (parts) {\r\n            return new Date(0, 0, 0, getTimePart(parts[1]), getTimePart(parts[2]), getTimePart(parts[4]))\r\n        }\r\n        return\r\n    }\r\n    const year = getTimePart(parts[1]);\r\n    const month = --parts[3];\r\n    const day = parts[5];\r\n    let timeZoneHour = 0;\r\n    let timeZoneMinute = 0;\r\n    const correctYear = d => {\r\n        year < 100 && d.setFullYear(year);\r\n        return d\r\n    };\r\n    timeZoneHour = getTimePart(parts[14]);\r\n    timeZoneMinute = getTimePart(parts[16]);\r\n    if (\"-\" === parts[13]) {\r\n        timeZoneHour = -timeZoneHour;\r\n        timeZoneMinute = -timeZoneMinute\r\n    }\r\n    const hour = getTimePart(parts[6]) - timeZoneHour;\r\n    const minute = getTimePart(parts[8]) - timeZoneMinute;\r\n    const second = getTimePart(parts[10]);\r\n    const millisecond = function(part) {\r\n        part = part || \"\";\r\n        return getTimePart(part) * 10 ** (3 - part.length)\r\n    }(parts[11]);\r\n    if (parts[12]) {\r\n        return correctYear(new Date(Date.UTC(year, month, day, hour, minute, second, millisecond)))\r\n    }\r\n    return correctYear(new Date(year, month, day, hour, minute, second, millisecond))\r\n}\r\nconst getIso8601Format = function(text, useUtc) {\r\n    let parts = text.match(ISO8601_PATTERN);\r\n    let result = \"\";\r\n    if (!parts) {\r\n        parts = text.match(ISO8601_TIME_PATTERN);\r\n        if (parts) {\r\n            return parts[3] ? \"HH:mm:ss\" : \"HH:mm\"\r\n        }\r\n        return\r\n    }\r\n    for (let i = 1; i < ISO8601_PATTERN_PARTS.length; i++) {\r\n        if (parts[i]) {\r\n            result += ISO8601_PATTERN_PARTS[i] || parts[i]\r\n        }\r\n    }\r\n    if (\"Z\" === parts[12]) {\r\n        result += \"'Z'\"\r\n    }\r\n    if (parts[14]) {\r\n        if (parts[15]) {\r\n            result += \"xxx\"\r\n        } else if (parts[16]) {\r\n            result += \"xx\"\r\n        } else {\r\n            result += \"x\"\r\n        }\r\n    }\r\n    return result\r\n};\r\nconst deserializeDate = function(value) {\r\n    if (\"number\" === typeof value) {\r\n        return new Date(value)\r\n    }\r\n    return dateParser(value, !config().forceIsoDateParsing)\r\n};\r\nconst serializeDate = function(value, serializationFormat) {\r\n    if (!serializationFormat) {\r\n        return value\r\n    }\r\n    if (!isDate(value)) {\r\n        return null\r\n    }\r\n    if (\"number\" === serializationFormat) {\r\n        return value && value.valueOf ? value.valueOf() : null\r\n    }\r\n    return getLDMLFormatter(serializationFormat, defaultDateNames)(value)\r\n};\r\nconst getDateSerializationFormat = function(value) {\r\n    if (\"number\" === typeof value) {\r\n        return \"number\"\r\n    }\r\n    if (isString(value)) {\r\n        let format;\r\n        if (config().forceIsoDateParsing) {\r\n            format = getIso8601Format(value)\r\n        }\r\n        if (format) {\r\n            return format\r\n        }\r\n        if (value.includes(\":\")) {\r\n            return \"yyyy/MM/dd HH:mm:ss\"\r\n        }\r\n        return \"yyyy/MM/dd\"\r\n    }\r\n    if (value) {\r\n        return null\r\n    }\r\n};\r\nconst dateSerialization = {\r\n    dateParser: dateParser,\r\n    deserializeDate: deserializeDate,\r\n    serializeDate: serializeDate,\r\n    getDateSerializationFormat: getDateSerializationFormat\r\n};\r\nexport {\r\n    dateSerialization\r\n};\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,gBAAgB,MAAM,sDAAsD;AACnF,SACIC,YAAY,IAAIC,gBAAgB,QAC7B,uDAAuD;AAC9D,OAAOC,MAAM,MAAM,sBAAsB;AACzC,SACIC,MAAM,EACNC,SAAS,IAAIC,QAAQ,EACrBC,QAAQ,QACL,0BAA0B;AACjC,MAAMC,2BAA2B,GAAG,QAAQ;AAC5C,MAAMC,yBAAyB,GAAG,YAAY;AAC9C,MAAMC,6BAA6B,GAAG,qBAAqB;AAC3D,MAAMC,eAAe,GAAG,wHAAwH;AAChJ,MAAMC,oBAAoB,GAAG,8BAA8B;AAC3D,MAAMC,qBAAqB,GAAG,CAAC,EAAE,EAAE,MAAM,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE,IAAI,EAAE,MAAM,CAAC;AACjG,MAAMC,0BAA0B,GAAG,6BAA6B;AAChE,MAAMC,kBAAkB,GAAG,CAAC;AAC5B,MAAMC,UAAU,GAAG,SAAAA,CAASC,IAAI,EAAEC,kBAAkB,EAAE;EAClD,IAAIC,MAAM;EACV,IAAIZ,QAAQ,CAACU,IAAI,CAAC,IAAI,CAACC,kBAAkB,EAAE;IACvCC,MAAM,GAAGC,kBAAkB,CAACH,IAAI,CAAC;EACrC;EACA,OAAOE,MAAM,IAAIE,SAAS,CAACJ,IAAI,CAAC;AACpC,CAAC;AAED,SAASK,WAAWA,CAACC,IAAI,EAAE;EACvB,OAAO,CAACA,IAAI,IAAI,CAAC;AACrB;AAEA,SAASF,SAASA,CAACJ,IAAI,EAAE;EACrB,MAAMO,4BAA4B,GAAG,YAAY,KAAKC,0BAA0B,CAACR,IAAI,CAAC;EACtF,MAAMS,WAAW,GAAG,CAACtB,MAAM,CAACa,IAAI,CAAC,IAAIU,IAAI,CAACC,KAAK,CAACX,IAAI,CAAC;EACrD,IAAI,CAACS,WAAW,IAAIF,4BAA4B,EAAE;IAC9C,MAAMK,KAAK,GAAGZ,IAAI,CAACa,KAAK,CAAChB,0BAA0B,CAAC;IACpD,IAAIe,KAAK,EAAE;MACP,MAAME,OAAO,GAAG,IAAIJ,IAAI,CAACL,WAAW,CAACO,KAAK,CAAC,CAAC,CAAC,CAAC,EAAEP,WAAW,CAACO,KAAK,CAAC,CAAC,CAAC,CAAC,EAAEP,WAAW,CAACO,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;MAC7FE,OAAO,CAACC,WAAW,CAACV,WAAW,CAACO,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;MAC1CE,OAAO,CAACE,QAAQ,CAACX,WAAW,CAACO,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;MAC3CE,OAAO,CAACG,OAAO,CAACZ,WAAW,CAACO,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;MACtC,OAAOE,OAAO;IAClB;EACJ;EACA,OAAOzB,QAAQ,CAACoB,WAAW,CAAC,GAAG,IAAIC,IAAI,CAACD,WAAW,CAAC,GAAGT,IAAI;AAC/D;AAEA,SAASG,kBAAkBA,CAACH,IAAI,EAAE;EAC9B,IAAIY,KAAK,GAAGZ,IAAI,CAACa,KAAK,CAACnB,eAAe,CAAC;EACvC,IAAI,CAACkB,KAAK,EAAE;IACRA,KAAK,GAAGZ,IAAI,CAACa,KAAK,CAAClB,oBAAoB,CAAC;IACxC,IAAIiB,KAAK,EAAE;MACP,OAAO,IAAIF,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAEL,WAAW,CAACO,KAAK,CAAC,CAAC,CAAC,CAAC,EAAEP,WAAW,CAACO,KAAK,CAAC,CAAC,CAAC,CAAC,EAAEP,WAAW,CAACO,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;IACjG;IACA;EACJ;EACA,MAAMM,IAAI,GAAGb,WAAW,CAACO,KAAK,CAAC,CAAC,CAAC,CAAC;EAClC,MAAMO,KAAK,GAAG,EAAEP,KAAK,CAAC,CAAC,CAAC;EACxB,MAAMQ,GAAG,GAAGR,KAAK,CAAC,CAAC,CAAC;EACpB,IAAIS,YAAY,GAAG,CAAC;EACpB,IAAIC,cAAc,GAAG,CAAC;EACtB,MAAMC,WAAW,GAAGC,CAAC,IAAI;IACrBN,IAAI,GAAG,GAAG,IAAIM,CAAC,CAACT,WAAW,CAACG,IAAI,CAAC;IACjC,OAAOM,CAAC;EACZ,CAAC;EACDH,YAAY,GAAGhB,WAAW,CAACO,KAAK,CAAC,EAAE,CAAC,CAAC;EACrCU,cAAc,GAAGjB,WAAW,CAACO,KAAK,CAAC,EAAE,CAAC,CAAC;EACvC,IAAI,GAAG,KAAKA,KAAK,CAAC,EAAE,CAAC,EAAE;IACnBS,YAAY,GAAG,CAACA,YAAY;IAC5BC,cAAc,GAAG,CAACA,cAAc;EACpC;EACA,MAAMG,IAAI,GAAGpB,WAAW,CAACO,KAAK,CAAC,CAAC,CAAC,CAAC,GAAGS,YAAY;EACjD,MAAMK,MAAM,GAAGrB,WAAW,CAACO,KAAK,CAAC,CAAC,CAAC,CAAC,GAAGU,cAAc;EACrD,MAAMK,MAAM,GAAGtB,WAAW,CAACO,KAAK,CAAC,EAAE,CAAC,CAAC;EACrC,MAAMgB,WAAW,GAAG,UAAStB,IAAI,EAAE;IAC/BA,IAAI,GAAGA,IAAI,IAAI,EAAE;IACjB,OAAOD,WAAW,CAACC,IAAI,CAAC,GAAG,EAAE,KAAK,CAAC,GAAGA,IAAI,CAACuB,MAAM,CAAC;EACtD,CAAC,CAACjB,KAAK,CAAC,EAAE,CAAC,CAAC;EACZ,IAAIA,KAAK,CAAC,EAAE,CAAC,EAAE;IACX,OAAOW,WAAW,CAAC,IAAIb,IAAI,CAACA,IAAI,CAACoB,GAAG,CAACZ,IAAI,EAAEC,KAAK,EAAEC,GAAG,EAAEK,IAAI,EAAEC,MAAM,EAAEC,MAAM,EAAEC,WAAW,CAAC,CAAC,CAAC;EAC/F;EACA,OAAOL,WAAW,CAAC,IAAIb,IAAI,CAACQ,IAAI,EAAEC,KAAK,EAAEC,GAAG,EAAEK,IAAI,EAAEC,MAAM,EAAEC,MAAM,EAAEC,WAAW,CAAC,CAAC;AACrF;AACA,MAAMG,gBAAgB,GAAG,SAAAA,CAAS/B,IAAI,EAAEgC,MAAM,EAAE;EAC5C,IAAIpB,KAAK,GAAGZ,IAAI,CAACa,KAAK,CAACnB,eAAe,CAAC;EACvC,IAAIQ,MAAM,GAAG,EAAE;EACf,IAAI,CAACU,KAAK,EAAE;IACRA,KAAK,GAAGZ,IAAI,CAACa,KAAK,CAAClB,oBAAoB,CAAC;IACxC,IAAIiB,KAAK,EAAE;MACP,OAAOA,KAAK,CAAC,CAAC,CAAC,GAAG,UAAU,GAAG,OAAO;IAC1C;IACA;EACJ;EACA,KAAK,IAAIqB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrC,qBAAqB,CAACiC,MAAM,EAAEI,CAAC,EAAE,EAAE;IACnD,IAAIrB,KAAK,CAACqB,CAAC,CAAC,EAAE;MACV/B,MAAM,IAAIN,qBAAqB,CAACqC,CAAC,CAAC,IAAIrB,KAAK,CAACqB,CAAC,CAAC;IAClD;EACJ;EACA,IAAI,GAAG,KAAKrB,KAAK,CAAC,EAAE,CAAC,EAAE;IACnBV,MAAM,IAAI,KAAK;EACnB;EACA,IAAIU,KAAK,CAAC,EAAE,CAAC,EAAE;IACX,IAAIA,KAAK,CAAC,EAAE,CAAC,EAAE;MACXV,MAAM,IAAI,KAAK;IACnB,CAAC,MAAM,IAAIU,KAAK,CAAC,EAAE,CAAC,EAAE;MAClBV,MAAM,IAAI,IAAI;IAClB,CAAC,MAAM;MACHA,MAAM,IAAI,GAAG;IACjB;EACJ;EACA,OAAOA,MAAM;AACjB,CAAC;AACD,MAAMgC,eAAe,GAAG,SAAAA,CAASC,KAAK,EAAE;EACpC,IAAI,QAAQ,KAAK,OAAOA,KAAK,EAAE;IAC3B,OAAO,IAAIzB,IAAI,CAACyB,KAAK,CAAC;EAC1B;EACA,OAAOpC,UAAU,CAACoC,KAAK,EAAE,CAACjD,MAAM,CAAC,CAAC,CAACkD,mBAAmB,CAAC;AAC3D,CAAC;AACD,MAAMC,aAAa,GAAG,SAAAA,CAASF,KAAK,EAAEG,mBAAmB,EAAE;EACvD,IAAI,CAACA,mBAAmB,EAAE;IACtB,OAAOH,KAAK;EAChB;EACA,IAAI,CAAChD,MAAM,CAACgD,KAAK,CAAC,EAAE;IAChB,OAAO,IAAI;EACf;EACA,IAAI,QAAQ,KAAKG,mBAAmB,EAAE;IAClC,OAAOH,KAAK,IAAIA,KAAK,CAACI,OAAO,GAAGJ,KAAK,CAACI,OAAO,CAAC,CAAC,GAAG,IAAI;EAC1D;EACA,OAAOtD,gBAAgB,CAACqD,mBAAmB,EAAEvD,gBAAgB,CAAC,CAACoD,KAAK,CAAC;AACzE,CAAC;AACD,MAAM3B,0BAA0B,GAAG,SAAAA,CAAS2B,KAAK,EAAE;EAC/C,IAAI,QAAQ,KAAK,OAAOA,KAAK,EAAE;IAC3B,OAAO,QAAQ;EACnB;EACA,IAAI7C,QAAQ,CAAC6C,KAAK,CAAC,EAAE;IACjB,IAAIK,MAAM;IACV,IAAItD,MAAM,CAAC,CAAC,CAACkD,mBAAmB,EAAE;MAC9BI,MAAM,GAAGT,gBAAgB,CAACI,KAAK,CAAC;IACpC;IACA,IAAIK,MAAM,EAAE;MACR,OAAOA,MAAM;IACjB;IACA,IAAIL,KAAK,CAACM,QAAQ,CAAC,GAAG,CAAC,EAAE;MACrB,OAAO,qBAAqB;IAChC;IACA,OAAO,YAAY;EACvB;EACA,IAAIN,KAAK,EAAE;IACP,OAAO,IAAI;EACf;AACJ,CAAC;AACD,MAAMO,iBAAiB,GAAG;EACtB3C,UAAU,EAAEA,UAAU;EACtBmC,eAAe,EAAEA,eAAe;EAChCG,aAAa,EAAEA,aAAa;EAC5B7B,0BAA0B,EAAEA;AAChC,CAAC;AACD,SACIkC,iBAAiB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}