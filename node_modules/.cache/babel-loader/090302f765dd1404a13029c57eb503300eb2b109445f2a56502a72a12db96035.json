{"ast":null,"code":"/**\r\n * DevExtreme (esm/common/core/localization/ldml/number.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { fitIntoRange, multiplyInExponentialForm } from \"../../../../core/utils/math\";\nimport { toFixed } from \"../utils\";\nconst DEFAULT_CONFIG = {\n  thousandsSeparator: \",\",\n  decimalSeparator: \".\"\n};\nconst ESCAPING_CHAR = \"'\";\nconst MAXIMUM_NUMBER_LENGTH = 15;\nconst PERCENT_EXPONENT_SHIFT = 2;\nfunction getGroupSizes(formatString) {\n  return formatString.split(\",\").slice(1).map(function (str) {\n    let singleQuotesLeft = 0;\n    return str.split(\"\").filter(function (char, index) {\n      singleQuotesLeft += \"'\" === char;\n      const isDigit = \"#\" === char || \"0\" === char;\n      const isInStub = singleQuotesLeft % 2;\n      return isDigit && !isInStub;\n    }).length;\n  });\n}\nfunction splitSignParts(format) {\n  let separatorChar = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : \";\";\n  let escapingChar = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : \"'\";\n  const parts = [];\n  let currentPart = \"\";\n  let state = \"searchingSeparator\";\n  for (let i = 0; i < format.length; i++) {\n    const char = format[i];\n    if (\"searchingSeparator\" === state && char === escapingChar) {\n      state = \"skippingSeparationInsideEscaping\";\n    } else if (\"skippingSeparationInsideEscaping\" === state && char === escapingChar) {\n      state = \"searchingSeparator\";\n    } else if (\"searchingSeparator\" === state && char === separatorChar) {\n      state = \"separating\";\n      parts.push(currentPart);\n      currentPart = \"\";\n    }\n    if (\"separating\" !== state) {\n      currentPart += char;\n    } else {\n      state = \"searchingSeparator\";\n    }\n  }\n  parts.push(currentPart);\n  return parts;\n}\nfunction getSignParts(format) {\n  const signParts = splitSignParts(format);\n  if (1 === signParts.length) {\n    signParts.push(\"-\" + signParts[0]);\n  }\n  return signParts;\n}\nfunction reverseString(str) {\n  return str.toString().split(\"\").reverse().join(\"\");\n}\nfunction isPercentFormat(format) {\n  return -1 !== format.indexOf(\"%\") && !format.match(/'[^']*%[^']*'/g);\n}\nfunction removeStubs(str) {\n  return str.replace(/'[^']*'/g, \"\");\n}\nfunction getNonRequiredDigitCount(floatFormat) {\n  if (!floatFormat) {\n    return 0;\n  }\n  const format = removeStubs(floatFormat);\n  return format.length - format.replace(/[#]/g, \"\").length;\n}\nfunction getRequiredDigitCount(floatFormat) {\n  if (!floatFormat) {\n    return 0;\n  }\n  const format = removeStubs(floatFormat);\n  return format.length - format.replace(/[0]/g, \"\").length;\n}\nfunction normalizeValueString(valuePart, minDigitCount, maxDigitCount) {\n  if (!valuePart) {\n    return \"\";\n  }\n  if (valuePart.length > maxDigitCount) {\n    valuePart = valuePart.substr(0, maxDigitCount);\n  }\n  while (valuePart.length > minDigitCount && \"0\" === valuePart.slice(-1)) {\n    valuePart = valuePart.substr(0, valuePart.length - 1);\n  }\n  while (valuePart.length < minDigitCount) {\n    valuePart += \"0\";\n  }\n  return valuePart;\n}\nfunction applyGroups(valueString, groupSizes, thousandsSeparator) {\n  if (!groupSizes.length) {\n    return valueString;\n  }\n  const groups = [];\n  let index = 0;\n  while (valueString) {\n    const groupSize = groupSizes[index];\n    if (!groupSize) {\n      break;\n    }\n    groups.push(valueString.slice(0, groupSize));\n    valueString = valueString.slice(groupSize);\n    if (index < groupSizes.length - 1) {\n      index++;\n    }\n  }\n  return groups.join(thousandsSeparator);\n}\nfunction formatNumberPart(format, valueString) {\n  return format.split(\"'\").map(function (formatPart, escapeIndex) {\n    const isEscape = escapeIndex % 2;\n    if (!formatPart && isEscape) {\n      return \"'\";\n    }\n    return isEscape ? formatPart : formatPart.replace(/[,#0]+/, valueString);\n  }).join(\"\");\n}\nfunction getFloatPointIndex(format) {\n  let isEscape = false;\n  for (let index = 0; index < format.length; index++) {\n    if (\"'\" === format[index]) {\n      isEscape = !isEscape;\n    }\n    if (\".\" === format[index] && !isEscape) {\n      return index;\n    }\n  }\n  return format.length;\n}\nexport function getFormatter(format, config) {\n  config = config || DEFAULT_CONFIG;\n  return function (value) {\n    if (\"number\" !== typeof value || isNaN(value)) {\n      return \"\";\n    }\n    const signFormatParts = getSignParts(format);\n    const isPositiveZero = 1 / value === 1 / 0;\n    const isPositive = value > 0 || isPositiveZero;\n    const numberFormat = signFormatParts[isPositive ? 0 : 1];\n    const floatPointIndex = getFloatPointIndex(numberFormat);\n    const floatFormatParts = [numberFormat.substr(0, floatPointIndex), numberFormat.substr(floatPointIndex + 1)];\n    const minFloatPrecision = getRequiredDigitCount(floatFormatParts[1]);\n    const maxFloatPrecision = minFloatPrecision + getNonRequiredDigitCount(floatFormatParts[1]);\n    if (isPercentFormat(numberFormat)) {\n      value = multiplyInExponentialForm(value, 2);\n    }\n    if (!isPositive) {\n      value = -value;\n    }\n    const minIntegerPrecision = getRequiredDigitCount(floatFormatParts[0]);\n    const maxIntegerPrecision = getNonRequiredDigitCount(floatFormatParts[0]) || config.unlimitedIntegerDigits ? void 0 : minIntegerPrecision;\n    const integerLength = Math.floor(value).toString().length;\n    const floatPrecision = fitIntoRange(maxFloatPrecision, 0, 15 - integerLength);\n    const groupSizes = getGroupSizes(floatFormatParts[0]).reverse();\n    const valueParts = toFixed(value, floatPrecision < 0 ? 0 : floatPrecision).split(\".\");\n    let valueIntegerPart = normalizeValueString(reverseString(valueParts[0]), minIntegerPrecision, maxIntegerPrecision);\n    const valueFloatPart = normalizeValueString(valueParts[1], minFloatPrecision, maxFloatPrecision);\n    valueIntegerPart = applyGroups(valueIntegerPart, groupSizes, config.thousandsSeparator);\n    const integerString = reverseString(formatNumberPart(reverseString(floatFormatParts[0]), valueIntegerPart));\n    const floatString = maxFloatPrecision ? formatNumberPart(floatFormatParts[1], valueFloatPart) : \"\";\n    const result = integerString + (floatString.match(/\\d/) ? config.decimalSeparator : \"\") + floatString;\n    return result;\n  };\n}\nfunction parseValue(text, isPercent, isNegative) {\n  const value = (isPercent ? .01 : 1) * parseFloat(text) || 0;\n  return isNegative ? -value : value;\n}\nfunction prepareValueText(valueText, formatter, isPercent, isIntegerPart) {\n  let nextValueText = valueText;\n  let char;\n  let text;\n  let nextText;\n  do {\n    if (nextText) {\n      char = text.length === nextText.length ? \"0\" : \"1\";\n      valueText = isIntegerPart ? char + valueText : valueText + char;\n    }\n    text = nextText || formatter(parseValue(nextValueText, isPercent));\n    nextValueText = isIntegerPart ? \"1\" + nextValueText : nextValueText + \"1\";\n    nextText = formatter(parseValue(nextValueText, isPercent));\n  } while (text !== nextText && (isIntegerPart ? text.length === nextText.length : text.length <= nextText.length));\n  if (isIntegerPart && nextText.length > text.length) {\n    const hasGroups = -1 === formatter(12345).indexOf(\"12345\");\n    do {\n      valueText = \"1\" + valueText;\n    } while (hasGroups && parseValue(valueText, isPercent) < 1e5);\n  }\n  return valueText;\n}\nfunction getFormatByValueText(valueText, formatter, isPercent, isNegative) {\n  let format = formatter(parseValue(valueText, isPercent, isNegative));\n  const valueTextParts = valueText.split(\".\");\n  const valueTextWithModifiedFloat = valueTextParts[0] + \".3\" + valueTextParts[1].slice(1);\n  const valueWithModifiedFloat = parseValue(valueTextWithModifiedFloat, isPercent, isNegative);\n  const decimalSeparatorIndex = formatter(valueWithModifiedFloat).indexOf(\"3\") - 1;\n  format = format.replace(/(\\d)\\D(\\d)/g, \"$1,$2\");\n  if (decimalSeparatorIndex >= 0) {\n    format = format.slice(0, decimalSeparatorIndex) + \".\" + format.slice(decimalSeparatorIndex + 1);\n  }\n  format = format.replace(/1+/, \"1\").replace(/1/g, \"#\");\n  if (!isPercent) {\n    format = format.replace(/%/g, \"'%'\");\n  }\n  return format;\n}\nexport function getFormat(formatter) {\n  let valueText = \".\";\n  const isPercent = formatter(1).indexOf(\"100\") >= 0;\n  valueText = prepareValueText(valueText, formatter, isPercent, true);\n  valueText = prepareValueText(valueText, formatter, isPercent, false);\n  const positiveFormat = getFormatByValueText(valueText, formatter, isPercent, false);\n  const negativeFormat = getFormatByValueText(valueText, formatter, isPercent, true);\n  return negativeFormat === \"-\" + positiveFormat ? positiveFormat : positiveFormat + \";\" + negativeFormat;\n}","map":{"version":3,"names":["fitIntoRange","multiplyInExponentialForm","toFixed","DEFAULT_CONFIG","thousandsSeparator","decimalSeparator","ESCAPING_CHAR","MAXIMUM_NUMBER_LENGTH","PERCENT_EXPONENT_SHIFT","getGroupSizes","formatString","split","slice","map","str","singleQuotesLeft","filter","char","index","isDigit","isInStub","length","splitSignParts","format","separatorChar","arguments","escapingChar","parts","currentPart","state","i","push","getSignParts","signParts","reverseString","toString","reverse","join","isPercentFormat","indexOf","match","removeStubs","replace","getNonRequiredDigitCount","floatFormat","getRequiredDigitCount","normalizeValueString","valuePart","minDigitCount","maxDigitCount","substr","applyGroups","valueString","groupSizes","groups","groupSize","formatNumberPart","formatPart","escapeIndex","isEscape","getFloatPointIndex","getFormatter","config","value","isNaN","signFormatParts","isPositiveZero","isPositive","numberFormat","floatPointIndex","floatFormatParts","minFloatPrecision","maxFloatPrecision","minIntegerPrecision","maxIntegerPrecision","unlimitedIntegerDigits","integerLength","Math","floor","floatPrecision","valueParts","valueIntegerPart","valueFloatPart","integerString","floatString","result","parseValue","text","isPercent","isNegative","parseFloat","prepareValueText","valueText","formatter","isIntegerPart","nextValueText","nextText","hasGroups","getFormatByValueText","valueTextParts","valueTextWithModifiedFloat","valueWithModifiedFloat","decimalSeparatorIndex","getFormat","positiveFormat","negativeFormat"],"sources":["/home/nataf/Cours/world-cities-map/client/node_modules/devextreme/esm/common/core/localization/ldml/number.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/common/core/localization/ldml/number.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    fitIntoRange,\r\n    multiplyInExponentialForm\r\n} from \"../../../../core/utils/math\";\r\nimport {\r\n    toFixed\r\n} from \"../utils\";\r\nconst DEFAULT_CONFIG = {\r\n    thousandsSeparator: \",\",\r\n    decimalSeparator: \".\"\r\n};\r\nconst ESCAPING_CHAR = \"'\";\r\nconst MAXIMUM_NUMBER_LENGTH = 15;\r\nconst PERCENT_EXPONENT_SHIFT = 2;\r\n\r\nfunction getGroupSizes(formatString) {\r\n    return formatString.split(\",\").slice(1).map((function(str) {\r\n        let singleQuotesLeft = 0;\r\n        return str.split(\"\").filter((function(char, index) {\r\n            singleQuotesLeft += \"'\" === char;\r\n            const isDigit = \"#\" === char || \"0\" === char;\r\n            const isInStub = singleQuotesLeft % 2;\r\n            return isDigit && !isInStub\r\n        })).length\r\n    }))\r\n}\r\n\r\nfunction splitSignParts(format) {\r\n    let separatorChar = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : \";\";\r\n    let escapingChar = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : \"'\";\r\n    const parts = [];\r\n    let currentPart = \"\";\r\n    let state = \"searchingSeparator\";\r\n    for (let i = 0; i < format.length; i++) {\r\n        const char = format[i];\r\n        if (\"searchingSeparator\" === state && char === escapingChar) {\r\n            state = \"skippingSeparationInsideEscaping\"\r\n        } else if (\"skippingSeparationInsideEscaping\" === state && char === escapingChar) {\r\n            state = \"searchingSeparator\"\r\n        } else if (\"searchingSeparator\" === state && char === separatorChar) {\r\n            state = \"separating\";\r\n            parts.push(currentPart);\r\n            currentPart = \"\"\r\n        }\r\n        if (\"separating\" !== state) {\r\n            currentPart += char\r\n        } else {\r\n            state = \"searchingSeparator\"\r\n        }\r\n    }\r\n    parts.push(currentPart);\r\n    return parts\r\n}\r\n\r\nfunction getSignParts(format) {\r\n    const signParts = splitSignParts(format);\r\n    if (1 === signParts.length) {\r\n        signParts.push(\"-\" + signParts[0])\r\n    }\r\n    return signParts\r\n}\r\n\r\nfunction reverseString(str) {\r\n    return str.toString().split(\"\").reverse().join(\"\")\r\n}\r\n\r\nfunction isPercentFormat(format) {\r\n    return -1 !== format.indexOf(\"%\") && !format.match(/'[^']*%[^']*'/g)\r\n}\r\n\r\nfunction removeStubs(str) {\r\n    return str.replace(/'[^']*'/g, \"\")\r\n}\r\n\r\nfunction getNonRequiredDigitCount(floatFormat) {\r\n    if (!floatFormat) {\r\n        return 0\r\n    }\r\n    const format = removeStubs(floatFormat);\r\n    return format.length - format.replace(/[#]/g, \"\").length\r\n}\r\n\r\nfunction getRequiredDigitCount(floatFormat) {\r\n    if (!floatFormat) {\r\n        return 0\r\n    }\r\n    const format = removeStubs(floatFormat);\r\n    return format.length - format.replace(/[0]/g, \"\").length\r\n}\r\n\r\nfunction normalizeValueString(valuePart, minDigitCount, maxDigitCount) {\r\n    if (!valuePart) {\r\n        return \"\"\r\n    }\r\n    if (valuePart.length > maxDigitCount) {\r\n        valuePart = valuePart.substr(0, maxDigitCount)\r\n    }\r\n    while (valuePart.length > minDigitCount && \"0\" === valuePart.slice(-1)) {\r\n        valuePart = valuePart.substr(0, valuePart.length - 1)\r\n    }\r\n    while (valuePart.length < minDigitCount) {\r\n        valuePart += \"0\"\r\n    }\r\n    return valuePart\r\n}\r\n\r\nfunction applyGroups(valueString, groupSizes, thousandsSeparator) {\r\n    if (!groupSizes.length) {\r\n        return valueString\r\n    }\r\n    const groups = [];\r\n    let index = 0;\r\n    while (valueString) {\r\n        const groupSize = groupSizes[index];\r\n        if (!groupSize) {\r\n            break\r\n        }\r\n        groups.push(valueString.slice(0, groupSize));\r\n        valueString = valueString.slice(groupSize);\r\n        if (index < groupSizes.length - 1) {\r\n            index++\r\n        }\r\n    }\r\n    return groups.join(thousandsSeparator)\r\n}\r\n\r\nfunction formatNumberPart(format, valueString) {\r\n    return format.split(\"'\").map((function(formatPart, escapeIndex) {\r\n        const isEscape = escapeIndex % 2;\r\n        if (!formatPart && isEscape) {\r\n            return \"'\"\r\n        }\r\n        return isEscape ? formatPart : formatPart.replace(/[,#0]+/, valueString)\r\n    })).join(\"\")\r\n}\r\n\r\nfunction getFloatPointIndex(format) {\r\n    let isEscape = false;\r\n    for (let index = 0; index < format.length; index++) {\r\n        if (\"'\" === format[index]) {\r\n            isEscape = !isEscape\r\n        }\r\n        if (\".\" === format[index] && !isEscape) {\r\n            return index\r\n        }\r\n    }\r\n    return format.length\r\n}\r\nexport function getFormatter(format, config) {\r\n    config = config || DEFAULT_CONFIG;\r\n    return function(value) {\r\n        if (\"number\" !== typeof value || isNaN(value)) {\r\n            return \"\"\r\n        }\r\n        const signFormatParts = getSignParts(format);\r\n        const isPositiveZero = 1 / value === 1 / 0;\r\n        const isPositive = value > 0 || isPositiveZero;\r\n        const numberFormat = signFormatParts[isPositive ? 0 : 1];\r\n        const floatPointIndex = getFloatPointIndex(numberFormat);\r\n        const floatFormatParts = [numberFormat.substr(0, floatPointIndex), numberFormat.substr(floatPointIndex + 1)];\r\n        const minFloatPrecision = getRequiredDigitCount(floatFormatParts[1]);\r\n        const maxFloatPrecision = minFloatPrecision + getNonRequiredDigitCount(floatFormatParts[1]);\r\n        if (isPercentFormat(numberFormat)) {\r\n            value = multiplyInExponentialForm(value, 2)\r\n        }\r\n        if (!isPositive) {\r\n            value = -value\r\n        }\r\n        const minIntegerPrecision = getRequiredDigitCount(floatFormatParts[0]);\r\n        const maxIntegerPrecision = getNonRequiredDigitCount(floatFormatParts[0]) || config.unlimitedIntegerDigits ? void 0 : minIntegerPrecision;\r\n        const integerLength = Math.floor(value).toString().length;\r\n        const floatPrecision = fitIntoRange(maxFloatPrecision, 0, 15 - integerLength);\r\n        const groupSizes = getGroupSizes(floatFormatParts[0]).reverse();\r\n        const valueParts = toFixed(value, floatPrecision < 0 ? 0 : floatPrecision).split(\".\");\r\n        let valueIntegerPart = normalizeValueString(reverseString(valueParts[0]), minIntegerPrecision, maxIntegerPrecision);\r\n        const valueFloatPart = normalizeValueString(valueParts[1], minFloatPrecision, maxFloatPrecision);\r\n        valueIntegerPart = applyGroups(valueIntegerPart, groupSizes, config.thousandsSeparator);\r\n        const integerString = reverseString(formatNumberPart(reverseString(floatFormatParts[0]), valueIntegerPart));\r\n        const floatString = maxFloatPrecision ? formatNumberPart(floatFormatParts[1], valueFloatPart) : \"\";\r\n        const result = integerString + (floatString.match(/\\d/) ? config.decimalSeparator : \"\") + floatString;\r\n        return result\r\n    }\r\n}\r\n\r\nfunction parseValue(text, isPercent, isNegative) {\r\n    const value = (isPercent ? .01 : 1) * parseFloat(text) || 0;\r\n    return isNegative ? -value : value\r\n}\r\n\r\nfunction prepareValueText(valueText, formatter, isPercent, isIntegerPart) {\r\n    let nextValueText = valueText;\r\n    let char;\r\n    let text;\r\n    let nextText;\r\n    do {\r\n        if (nextText) {\r\n            char = text.length === nextText.length ? \"0\" : \"1\";\r\n            valueText = isIntegerPart ? char + valueText : valueText + char\r\n        }\r\n        text = nextText || formatter(parseValue(nextValueText, isPercent));\r\n        nextValueText = isIntegerPart ? \"1\" + nextValueText : nextValueText + \"1\";\r\n        nextText = formatter(parseValue(nextValueText, isPercent))\r\n    } while (text !== nextText && (isIntegerPart ? text.length === nextText.length : text.length <= nextText.length));\r\n    if (isIntegerPart && nextText.length > text.length) {\r\n        const hasGroups = -1 === formatter(12345).indexOf(\"12345\");\r\n        do {\r\n            valueText = \"1\" + valueText\r\n        } while (hasGroups && parseValue(valueText, isPercent) < 1e5)\r\n    }\r\n    return valueText\r\n}\r\n\r\nfunction getFormatByValueText(valueText, formatter, isPercent, isNegative) {\r\n    let format = formatter(parseValue(valueText, isPercent, isNegative));\r\n    const valueTextParts = valueText.split(\".\");\r\n    const valueTextWithModifiedFloat = valueTextParts[0] + \".3\" + valueTextParts[1].slice(1);\r\n    const valueWithModifiedFloat = parseValue(valueTextWithModifiedFloat, isPercent, isNegative);\r\n    const decimalSeparatorIndex = formatter(valueWithModifiedFloat).indexOf(\"3\") - 1;\r\n    format = format.replace(/(\\d)\\D(\\d)/g, \"$1,$2\");\r\n    if (decimalSeparatorIndex >= 0) {\r\n        format = format.slice(0, decimalSeparatorIndex) + \".\" + format.slice(decimalSeparatorIndex + 1)\r\n    }\r\n    format = format.replace(/1+/, \"1\").replace(/1/g, \"#\");\r\n    if (!isPercent) {\r\n        format = format.replace(/%/g, \"'%'\")\r\n    }\r\n    return format\r\n}\r\nexport function getFormat(formatter) {\r\n    let valueText = \".\";\r\n    const isPercent = formatter(1).indexOf(\"100\") >= 0;\r\n    valueText = prepareValueText(valueText, formatter, isPercent, true);\r\n    valueText = prepareValueText(valueText, formatter, isPercent, false);\r\n    const positiveFormat = getFormatByValueText(valueText, formatter, isPercent, false);\r\n    const negativeFormat = getFormatByValueText(valueText, formatter, isPercent, true);\r\n    return negativeFormat === \"-\" + positiveFormat ? positiveFormat : positiveFormat + \";\" + negativeFormat\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}