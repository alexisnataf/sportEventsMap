{"ast":null,"code":"/**\r\n * DevExtreme (esm/__internal/events/m_drag.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport registerEmitter from \"../../common/core/events/core/emitter_registrator\";\nimport registerEvent from \"../../common/core/events/core/event_registrator\";\nimport GestureEmitter from \"../../common/core/events/gesture/emitter.gesture\";\nimport { eventData as eData, fireEvent } from \"../../common/core/events/utils/index\";\nimport { data as elementData, removeData } from \"../../core/element_data\";\nimport $ from \"../../core/renderer\";\nimport { wrapToArray } from \"../../core/utils/array\";\nimport { contains } from \"../../core/utils/dom\";\nimport * as iteratorUtils from \"../../core/utils/iterator\";\nconst DRAG_START_EVENT = \"dxdragstart\";\nconst DRAG_EVENT = \"dxdrag\";\nconst DRAG_END_EVENT = \"dxdragend\";\nconst DRAG_ENTER_EVENT = \"dxdragenter\";\nconst DRAG_LEAVE_EVENT = \"dxdragleave\";\nconst DROP_EVENT = \"dxdrop\";\nconst DX_DRAG_EVENTS_COUNT_KEY = \"dxDragEventsCount\";\nconst knownDropTargets = [];\nconst knownDropTargetSelectors = [];\nconst knownDropTargetConfigs = [];\nconst dropTargetRegistration = {\n  setup(element, data) {\n    const knownDropTarget = knownDropTargets.includes(element);\n    if (!knownDropTarget) {\n      knownDropTargets.push(element);\n      knownDropTargetSelectors.push([]);\n      knownDropTargetConfigs.push(data || {});\n    }\n  },\n  add(element, handleObj) {\n    const index = knownDropTargets.indexOf(element);\n    this.updateEventsCounter(element, handleObj.type, 1);\n    const {\n      selector: selector\n    } = handleObj;\n    if (!knownDropTargetSelectors[index].includes(selector)) {\n      knownDropTargetSelectors[index].push(selector);\n    }\n  },\n  updateEventsCounter(element, event, value) {\n    if ([DRAG_ENTER_EVENT, DRAG_LEAVE_EVENT, DROP_EVENT].includes(event)) {\n      const eventsCount = elementData(element, \"dxDragEventsCount\") || 0;\n      elementData(element, \"dxDragEventsCount\", Math.max(0, eventsCount + value));\n    }\n  },\n  remove(element, handleObj) {\n    this.updateEventsCounter(element, handleObj.type, -1);\n  },\n  teardown(element) {\n    const handlersCount = elementData(element, \"dxDragEventsCount\");\n    if (!handlersCount) {\n      const index = knownDropTargets.indexOf(element);\n      knownDropTargets.splice(index, 1);\n      knownDropTargetSelectors.splice(index, 1);\n      knownDropTargetConfigs.splice(index, 1);\n      removeData(element, \"dxDragEventsCount\");\n    }\n  }\n};\nregisterEvent(DRAG_ENTER_EVENT, dropTargetRegistration);\nregisterEvent(DRAG_LEAVE_EVENT, dropTargetRegistration);\nregisterEvent(DROP_EVENT, dropTargetRegistration);\nconst getItemDelegatedTargets = function ($element) {\n  const dropTargetIndex = knownDropTargets.indexOf($element.get(0));\n  const dropTargetSelectors = knownDropTargetSelectors[dropTargetIndex].filter(selector => selector);\n  let $delegatedTargets = $element.find(dropTargetSelectors.join(\", \"));\n  if (knownDropTargetSelectors[dropTargetIndex].includes(void 0)) {\n    $delegatedTargets = $delegatedTargets.add($element);\n  }\n  return $delegatedTargets;\n};\nconst getItemConfig = function ($element) {\n  const dropTargetIndex = knownDropTargets.indexOf($element.get(0));\n  return knownDropTargetConfigs[dropTargetIndex];\n};\nconst getItemPosition = function (dropTargetConfig, $element) {\n  if (dropTargetConfig.itemPositionFunc) {\n    return dropTargetConfig.itemPositionFunc($element);\n  }\n  return $element.offset();\n};\nconst getItemSize = function (dropTargetConfig, $element) {\n  if (dropTargetConfig.itemSizeFunc) {\n    return dropTargetConfig.itemSizeFunc($element);\n  }\n  return {\n    width: $element.get(0).getBoundingClientRect().width,\n    height: $element.get(0).getBoundingClientRect().height\n  };\n};\nconst DragEmitter = GestureEmitter.inherit({\n  ctor(element) {\n    this.callBase(element);\n    this.direction = \"both\";\n  },\n  _init(e) {\n    this._initEvent = e;\n  },\n  _start(e) {\n    e = this._fireEvent(\"dxdragstart\", this._initEvent);\n    this._maxLeftOffset = e.maxLeftOffset;\n    this._maxRightOffset = e.maxRightOffset;\n    this._maxTopOffset = e.maxTopOffset;\n    this._maxBottomOffset = e.maxBottomOffset;\n    if (e.targetElements || null === e.targetElements) {\n      const dropTargets = wrapToArray(e.targetElements || []);\n      this._dropTargets = iteratorUtils.map(dropTargets, element => $(element).get(0));\n    } else {\n      this._dropTargets = knownDropTargets;\n    }\n  },\n  _move(e) {\n    const eventData = eData(e);\n    const dragOffset = this._calculateOffset(eventData);\n    e = this._fireEvent(\"dxdrag\", e, {\n      offset: dragOffset\n    });\n    this._processDropTargets(e);\n    if (!e._cancelPreventDefault) {\n      e.preventDefault();\n    }\n  },\n  _calculateOffset(eventData) {\n    return {\n      x: this._calculateXOffset(eventData),\n      y: this._calculateYOffset(eventData)\n    };\n  },\n  _calculateXOffset(eventData) {\n    if (\"vertical\" !== this.direction) {\n      const offset = eventData.x - this._startEventData.x;\n      return this._fitOffset(offset, this._maxLeftOffset, this._maxRightOffset);\n    }\n    return 0;\n  },\n  _calculateYOffset(eventData) {\n    if (\"horizontal\" !== this.direction) {\n      const offset = eventData.y - this._startEventData.y;\n      return this._fitOffset(offset, this._maxTopOffset, this._maxBottomOffset);\n    }\n    return 0;\n  },\n  _fitOffset(offset, minOffset, maxOffset) {\n    if (null != minOffset) {\n      offset = Math.max(offset, -minOffset);\n    }\n    if (null != maxOffset) {\n      offset = Math.min(offset, maxOffset);\n    }\n    return offset;\n  },\n  _processDropTargets(e) {\n    const target = this._findDropTarget(e);\n    const sameTarget = target === this._currentDropTarget;\n    if (!sameTarget) {\n      this._fireDropTargetEvent(e, DRAG_LEAVE_EVENT);\n      this._currentDropTarget = target;\n      this._fireDropTargetEvent(e, DRAG_ENTER_EVENT);\n    }\n  },\n  _fireDropTargetEvent(event, eventName) {\n    if (!this._currentDropTarget) {\n      return;\n    }\n    const eventData = {\n      type: eventName,\n      originalEvent: event,\n      draggingElement: this._$element.get(0),\n      target: this._currentDropTarget\n    };\n    fireEvent(eventData);\n  },\n  _findDropTarget(e) {\n    const that = this;\n    let result;\n    iteratorUtils.each(knownDropTargets, (_, target) => {\n      if (!that._checkDropTargetActive(target)) {\n        return;\n      }\n      const $target = $(target);\n      iteratorUtils.each(getItemDelegatedTargets($target), (_, delegatedTarget) => {\n        const $delegatedTarget = $(delegatedTarget);\n        if (that._checkDropTarget(getItemConfig($target), $delegatedTarget, $(result), e)) {\n          result = delegatedTarget;\n        }\n      });\n    });\n    return result;\n  },\n  _checkDropTargetActive(target) {\n    let active = false;\n    iteratorUtils.each(this._dropTargets, (_, activeTarget) => {\n      active = active || activeTarget === target || contains(activeTarget, target);\n      return !active;\n    });\n    return active;\n  },\n  _checkDropTarget(config, $target, $prevTarget, e) {\n    const isDraggingElement = $target.get(0) === $(e.target).get(0);\n    if (isDraggingElement) {\n      return false;\n    }\n    const targetPosition = getItemPosition(config, $target);\n    if (e.pageX < targetPosition.left) {\n      return false;\n    }\n    if (e.pageY < targetPosition.top) {\n      return false;\n    }\n    const targetSize = getItemSize(config, $target);\n    if (e.pageX > targetPosition.left + targetSize.width) {\n      return false;\n    }\n    if (e.pageY > targetPosition.top + targetSize.height) {\n      return false;\n    }\n    if ($prevTarget.length && $prevTarget.closest($target).length) {\n      return false;\n    }\n    if (config.checkDropTarget && !config.checkDropTarget($target, e)) {\n      return false;\n    }\n    return $target;\n  },\n  _end(e) {\n    const eventData = eData(e);\n    this._fireEvent(\"dxdragend\", e, {\n      offset: this._calculateOffset(eventData)\n    });\n    this._fireDropTargetEvent(e, DROP_EVENT);\n    delete this._currentDropTarget;\n  }\n});\nregisterEmitter({\n  emitter: DragEmitter,\n  events: [\"dxdragstart\", \"dxdrag\", \"dxdragend\"]\n});\nexport { DROP_EVENT as drop, DRAG_END_EVENT as end, DRAG_ENTER_EVENT as enter, DRAG_LEAVE_EVENT as leave, DRAG_EVENT as move, DRAG_START_EVENT as start };","map":{"version":3,"names":["registerEmitter","registerEvent","GestureEmitter","eventData","eData","fireEvent","data","elementData","removeData","$","wrapToArray","contains","iteratorUtils","DRAG_START_EVENT","DRAG_EVENT","DRAG_END_EVENT","DRAG_ENTER_EVENT","DRAG_LEAVE_EVENT","DROP_EVENT","DX_DRAG_EVENTS_COUNT_KEY","knownDropTargets","knownDropTargetSelectors","knownDropTargetConfigs","dropTargetRegistration","setup","element","knownDropTarget","includes","push","add","handleObj","index","indexOf","updateEventsCounter","type","selector","event","value","eventsCount","Math","max","remove","teardown","handlersCount","splice","getItemDelegatedTargets","$element","dropTargetIndex","get","dropTargetSelectors","filter","$delegatedTargets","find","join","getItemConfig","getItemPosition","dropTargetConfig","itemPositionFunc","offset","getItemSize","itemSizeFunc","width","getBoundingClientRect","height","DragEmitter","inherit","ctor","callBase","direction","_init","e","_initEvent","_start","_fireEvent","_maxLeftOffset","maxLeftOffset","_maxRightOffset","maxRightOffset","_maxTopOffset","maxTopOffset","_maxBottomOffset","maxBottomOffset","targetElements","dropTargets","_dropTargets","map","_move","dragOffset","_calculateOffset","_processDropTargets","_cancelPreventDefault","preventDefault","x","_calculateXOffset","y","_calculateYOffset","_startEventData","_fitOffset","minOffset","maxOffset","min","target","_findDropTarget","sameTarget","_currentDropTarget","_fireDropTargetEvent","eventName","originalEvent","draggingElement","_$element","that","result","each","_","_checkDropTargetActive","$target","delegatedTarget","$delegatedTarget","_checkDropTarget","active","activeTarget","config","$prevTarget","isDraggingElement","targetPosition","pageX","left","pageY","top","targetSize","length","closest","checkDropTarget","_end","emitter","events","drop","end","enter","leave","move","start"],"sources":["/home/nataf/Cours/world-cities-map/client/node_modules/devextreme/esm/__internal/events/m_drag.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/__internal/events/m_drag.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport registerEmitter from \"../../common/core/events/core/emitter_registrator\";\r\nimport registerEvent from \"../../common/core/events/core/event_registrator\";\r\nimport GestureEmitter from \"../../common/core/events/gesture/emitter.gesture\";\r\nimport {\r\n    eventData as eData,\r\n    fireEvent\r\n} from \"../../common/core/events/utils/index\";\r\nimport {\r\n    data as elementData,\r\n    removeData\r\n} from \"../../core/element_data\";\r\nimport $ from \"../../core/renderer\";\r\nimport {\r\n    wrapToArray\r\n} from \"../../core/utils/array\";\r\nimport {\r\n    contains\r\n} from \"../../core/utils/dom\";\r\nimport * as iteratorUtils from \"../../core/utils/iterator\";\r\nconst DRAG_START_EVENT = \"dxdragstart\";\r\nconst DRAG_EVENT = \"dxdrag\";\r\nconst DRAG_END_EVENT = \"dxdragend\";\r\nconst DRAG_ENTER_EVENT = \"dxdragenter\";\r\nconst DRAG_LEAVE_EVENT = \"dxdragleave\";\r\nconst DROP_EVENT = \"dxdrop\";\r\nconst DX_DRAG_EVENTS_COUNT_KEY = \"dxDragEventsCount\";\r\nconst knownDropTargets = [];\r\nconst knownDropTargetSelectors = [];\r\nconst knownDropTargetConfigs = [];\r\nconst dropTargetRegistration = {\r\n    setup(element, data) {\r\n        const knownDropTarget = knownDropTargets.includes(element);\r\n        if (!knownDropTarget) {\r\n            knownDropTargets.push(element);\r\n            knownDropTargetSelectors.push([]);\r\n            knownDropTargetConfigs.push(data || {})\r\n        }\r\n    },\r\n    add(element, handleObj) {\r\n        const index = knownDropTargets.indexOf(element);\r\n        this.updateEventsCounter(element, handleObj.type, 1);\r\n        const {\r\n            selector: selector\r\n        } = handleObj;\r\n        if (!knownDropTargetSelectors[index].includes(selector)) {\r\n            knownDropTargetSelectors[index].push(selector)\r\n        }\r\n    },\r\n    updateEventsCounter(element, event, value) {\r\n        if ([DRAG_ENTER_EVENT, DRAG_LEAVE_EVENT, DROP_EVENT].includes(event)) {\r\n            const eventsCount = elementData(element, \"dxDragEventsCount\") || 0;\r\n            elementData(element, \"dxDragEventsCount\", Math.max(0, eventsCount + value))\r\n        }\r\n    },\r\n    remove(element, handleObj) {\r\n        this.updateEventsCounter(element, handleObj.type, -1)\r\n    },\r\n    teardown(element) {\r\n        const handlersCount = elementData(element, \"dxDragEventsCount\");\r\n        if (!handlersCount) {\r\n            const index = knownDropTargets.indexOf(element);\r\n            knownDropTargets.splice(index, 1);\r\n            knownDropTargetSelectors.splice(index, 1);\r\n            knownDropTargetConfigs.splice(index, 1);\r\n            removeData(element, \"dxDragEventsCount\")\r\n        }\r\n    }\r\n};\r\nregisterEvent(DRAG_ENTER_EVENT, dropTargetRegistration);\r\nregisterEvent(DRAG_LEAVE_EVENT, dropTargetRegistration);\r\nregisterEvent(DROP_EVENT, dropTargetRegistration);\r\nconst getItemDelegatedTargets = function($element) {\r\n    const dropTargetIndex = knownDropTargets.indexOf($element.get(0));\r\n    const dropTargetSelectors = knownDropTargetSelectors[dropTargetIndex].filter((selector => selector));\r\n    let $delegatedTargets = $element.find(dropTargetSelectors.join(\", \"));\r\n    if (knownDropTargetSelectors[dropTargetIndex].includes(void 0)) {\r\n        $delegatedTargets = $delegatedTargets.add($element)\r\n    }\r\n    return $delegatedTargets\r\n};\r\nconst getItemConfig = function($element) {\r\n    const dropTargetIndex = knownDropTargets.indexOf($element.get(0));\r\n    return knownDropTargetConfigs[dropTargetIndex]\r\n};\r\nconst getItemPosition = function(dropTargetConfig, $element) {\r\n    if (dropTargetConfig.itemPositionFunc) {\r\n        return dropTargetConfig.itemPositionFunc($element)\r\n    }\r\n    return $element.offset()\r\n};\r\nconst getItemSize = function(dropTargetConfig, $element) {\r\n    if (dropTargetConfig.itemSizeFunc) {\r\n        return dropTargetConfig.itemSizeFunc($element)\r\n    }\r\n    return {\r\n        width: $element.get(0).getBoundingClientRect().width,\r\n        height: $element.get(0).getBoundingClientRect().height\r\n    }\r\n};\r\nconst DragEmitter = GestureEmitter.inherit({\r\n    ctor(element) {\r\n        this.callBase(element);\r\n        this.direction = \"both\"\r\n    },\r\n    _init(e) {\r\n        this._initEvent = e\r\n    },\r\n    _start(e) {\r\n        e = this._fireEvent(\"dxdragstart\", this._initEvent);\r\n        this._maxLeftOffset = e.maxLeftOffset;\r\n        this._maxRightOffset = e.maxRightOffset;\r\n        this._maxTopOffset = e.maxTopOffset;\r\n        this._maxBottomOffset = e.maxBottomOffset;\r\n        if (e.targetElements || null === e.targetElements) {\r\n            const dropTargets = wrapToArray(e.targetElements || []);\r\n            this._dropTargets = iteratorUtils.map(dropTargets, (element => $(element).get(0)))\r\n        } else {\r\n            this._dropTargets = knownDropTargets\r\n        }\r\n    },\r\n    _move(e) {\r\n        const eventData = eData(e);\r\n        const dragOffset = this._calculateOffset(eventData);\r\n        e = this._fireEvent(\"dxdrag\", e, {\r\n            offset: dragOffset\r\n        });\r\n        this._processDropTargets(e);\r\n        if (!e._cancelPreventDefault) {\r\n            e.preventDefault()\r\n        }\r\n    },\r\n    _calculateOffset(eventData) {\r\n        return {\r\n            x: this._calculateXOffset(eventData),\r\n            y: this._calculateYOffset(eventData)\r\n        }\r\n    },\r\n    _calculateXOffset(eventData) {\r\n        if (\"vertical\" !== this.direction) {\r\n            const offset = eventData.x - this._startEventData.x;\r\n            return this._fitOffset(offset, this._maxLeftOffset, this._maxRightOffset)\r\n        }\r\n        return 0\r\n    },\r\n    _calculateYOffset(eventData) {\r\n        if (\"horizontal\" !== this.direction) {\r\n            const offset = eventData.y - this._startEventData.y;\r\n            return this._fitOffset(offset, this._maxTopOffset, this._maxBottomOffset)\r\n        }\r\n        return 0\r\n    },\r\n    _fitOffset(offset, minOffset, maxOffset) {\r\n        if (null != minOffset) {\r\n            offset = Math.max(offset, -minOffset)\r\n        }\r\n        if (null != maxOffset) {\r\n            offset = Math.min(offset, maxOffset)\r\n        }\r\n        return offset\r\n    },\r\n    _processDropTargets(e) {\r\n        const target = this._findDropTarget(e);\r\n        const sameTarget = target === this._currentDropTarget;\r\n        if (!sameTarget) {\r\n            this._fireDropTargetEvent(e, DRAG_LEAVE_EVENT);\r\n            this._currentDropTarget = target;\r\n            this._fireDropTargetEvent(e, DRAG_ENTER_EVENT)\r\n        }\r\n    },\r\n    _fireDropTargetEvent(event, eventName) {\r\n        if (!this._currentDropTarget) {\r\n            return\r\n        }\r\n        const eventData = {\r\n            type: eventName,\r\n            originalEvent: event,\r\n            draggingElement: this._$element.get(0),\r\n            target: this._currentDropTarget\r\n        };\r\n        fireEvent(eventData)\r\n    },\r\n    _findDropTarget(e) {\r\n        const that = this;\r\n        let result;\r\n        iteratorUtils.each(knownDropTargets, ((_, target) => {\r\n            if (!that._checkDropTargetActive(target)) {\r\n                return\r\n            }\r\n            const $target = $(target);\r\n            iteratorUtils.each(getItemDelegatedTargets($target), ((_, delegatedTarget) => {\r\n                const $delegatedTarget = $(delegatedTarget);\r\n                if (that._checkDropTarget(getItemConfig($target), $delegatedTarget, $(result), e)) {\r\n                    result = delegatedTarget\r\n                }\r\n            }))\r\n        }));\r\n        return result\r\n    },\r\n    _checkDropTargetActive(target) {\r\n        let active = false;\r\n        iteratorUtils.each(this._dropTargets, ((_, activeTarget) => {\r\n            active = active || activeTarget === target || contains(activeTarget, target);\r\n            return !active\r\n        }));\r\n        return active\r\n    },\r\n    _checkDropTarget(config, $target, $prevTarget, e) {\r\n        const isDraggingElement = $target.get(0) === $(e.target).get(0);\r\n        if (isDraggingElement) {\r\n            return false\r\n        }\r\n        const targetPosition = getItemPosition(config, $target);\r\n        if (e.pageX < targetPosition.left) {\r\n            return false\r\n        }\r\n        if (e.pageY < targetPosition.top) {\r\n            return false\r\n        }\r\n        const targetSize = getItemSize(config, $target);\r\n        if (e.pageX > targetPosition.left + targetSize.width) {\r\n            return false\r\n        }\r\n        if (e.pageY > targetPosition.top + targetSize.height) {\r\n            return false\r\n        }\r\n        if ($prevTarget.length && $prevTarget.closest($target).length) {\r\n            return false\r\n        }\r\n        if (config.checkDropTarget && !config.checkDropTarget($target, e)) {\r\n            return false\r\n        }\r\n        return $target\r\n    },\r\n    _end(e) {\r\n        const eventData = eData(e);\r\n        this._fireEvent(\"dxdragend\", e, {\r\n            offset: this._calculateOffset(eventData)\r\n        });\r\n        this._fireDropTargetEvent(e, DROP_EVENT);\r\n        delete this._currentDropTarget\r\n    }\r\n});\r\nregisterEmitter({\r\n    emitter: DragEmitter,\r\n    events: [\"dxdragstart\", \"dxdrag\", \"dxdragend\"]\r\n});\r\nexport {\r\n    DROP_EVENT as drop, DRAG_END_EVENT as end, DRAG_ENTER_EVENT as enter, DRAG_LEAVE_EVENT as leave, DRAG_EVENT as move, DRAG_START_EVENT as start\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}