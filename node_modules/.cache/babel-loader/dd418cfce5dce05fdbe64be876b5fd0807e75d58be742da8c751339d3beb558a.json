{"ast":null,"code":"/**\r\n * DevExtreme (esm/__internal/ui/m_validation_engine.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport messageLocalization from \"../../common/core/localization/message\";\nimport numberLocalization from \"../../common/core/localization/number\";\nimport Class from \"../../core/class\";\nimport errors from \"../../core/errors\";\nimport { EventsStrategy } from \"../../core/events_strategy\";\nimport { grep } from \"../../core/utils/common\";\nimport { Deferred, fromPromise } from \"../../core/utils/deferred\";\nimport { extend } from \"../../core/utils/extend\";\nimport { each } from \"../../core/utils/iterator\";\nimport { isBoolean, isDate, isDefined, isFunction, isNumeric, isObject, isPromise, isString } from \"../../core/utils/type\";\nconst EMAIL_VALIDATION_REGEX = /^[\\d\\w.+_-]+@[\\d\\w._-]+\\.[\\w]+$/i;\nconst STATUS = {\n  valid: \"valid\",\n  invalid: \"invalid\",\n  pending: \"pending\"\n};\nclass BaseRuleValidator {\n  constructor() {\n    this.NAME = \"base\";\n  }\n  defaultMessage(value) {\n    return messageLocalization.getFormatter(`validation-${this.NAME}`)(value);\n  }\n  defaultFormattedMessage(value) {\n    return messageLocalization.getFormatter(`validation-${this.NAME}-formatted`)(value);\n  }\n  _isValueEmpty(value) {\n    return !rulesValidators.required.validate(value, {});\n  }\n  validate(value, rule) {\n    const valueArray = Array.isArray(value) ? value : [value];\n    let result = true;\n    if (valueArray.length) {\n      valueArray.every(itemValue => {\n        result = this._validate(itemValue, rule);\n        return result;\n      });\n    } else {\n      result = this._validate(null, rule);\n    }\n    return result;\n  }\n}\nclass RequiredRuleValidator extends BaseRuleValidator {\n  constructor() {\n    super();\n    this.NAME = \"required\";\n  }\n  _validate(value, rule) {\n    if (!isDefined(value)) {\n      return false;\n    }\n    if (false === value) {\n      return false;\n    }\n    value = String(value);\n    if (rule.trim || !isDefined(rule.trim)) {\n      value = value.trim();\n    }\n    return \"\" !== value;\n  }\n}\nclass NumericRuleValidator extends BaseRuleValidator {\n  constructor() {\n    super();\n    this.NAME = \"numeric\";\n  }\n  _validate(value, rule) {\n    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value)) {\n      return true;\n    }\n    if (rule.useCultureSettings && isString(value)) {\n      return !isNaN(numberLocalization.parse(value));\n    }\n    return isNumeric(value);\n  }\n}\nclass RangeRuleValidator extends BaseRuleValidator {\n  constructor() {\n    super();\n    this.NAME = \"range\";\n  }\n  _validate(value, rule) {\n    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value)) {\n      return true;\n    }\n    const validNumber = rulesValidators.numeric.validate(value, rule);\n    const validValue = isDefined(value) && \"\" !== value;\n    const number = validNumber ? parseFloat(value) : validValue && value.valueOf();\n    const {\n      min: min\n    } = rule;\n    const {\n      max: max\n    } = rule;\n    if (!(validNumber || isDate(value)) && !validValue) {\n      return false;\n    }\n    if (isDefined(min)) {\n      if (isDefined(max)) {\n        return number >= min && number <= max;\n      }\n      return number >= min;\n    }\n    if (isDefined(max)) {\n      return number <= max;\n    }\n    throw errors.Error(\"E0101\");\n  }\n}\nclass StringLengthRuleValidator extends BaseRuleValidator {\n  constructor() {\n    super();\n    this.NAME = \"stringLength\";\n  }\n  _validate(value, rule) {\n    value = String(value ?? \"\");\n    if (rule.trim || !isDefined(rule.trim)) {\n      value = value.trim();\n    }\n    if (rule.ignoreEmptyValue && this._isValueEmpty(value)) {\n      return true;\n    }\n    return rulesValidators.range.validate(value.length, extend({}, rule));\n  }\n}\nclass CustomRuleValidator extends BaseRuleValidator {\n  constructor() {\n    super();\n    this.NAME = \"custom\";\n  }\n  validate(value, rule) {\n    if (rule.ignoreEmptyValue && this._isValueEmpty(value)) {\n      return true;\n    }\n    const {\n      validator: validator\n    } = rule;\n    const dataGetter = validator && isFunction(validator.option) && validator.option(\"dataGetter\");\n    const extraParams = isFunction(dataGetter) && dataGetter();\n    const params = {\n      value: value,\n      validator: validator,\n      rule: rule\n    };\n    if (extraParams) {\n      extend(params, extraParams);\n    }\n    return rule.validationCallback(params);\n  }\n}\nclass AsyncRuleValidator extends CustomRuleValidator {\n  constructor() {\n    super();\n    this.NAME = \"async\";\n  }\n  validate(value, rule) {\n    if (!isDefined(rule.reevaluate)) {\n      extend(rule, {\n        reevaluate: true\n      });\n    }\n    if (rule.ignoreEmptyValue && this._isValueEmpty(value)) {\n      return true;\n    }\n    const {\n      validator: validator\n    } = rule;\n    const dataGetter = validator && isFunction(validator.option) && validator.option(\"dataGetter\");\n    const extraParams = isFunction(dataGetter) && dataGetter();\n    const params = {\n      value: value,\n      validator: validator,\n      rule: rule\n    };\n    if (extraParams) {\n      extend(params, extraParams);\n    }\n    const callbackResult = rule.validationCallback(params);\n    if (!isPromise(callbackResult)) {\n      throw errors.Error(\"E0103\");\n    }\n    return this._getWrappedPromise(fromPromise(callbackResult).promise());\n  }\n  _getWrappedPromise(promise) {\n    const deferred = Deferred();\n    promise.then(res => {\n      deferred.resolve(res);\n    }, err => {\n      const res = {\n        isValid: false\n      };\n      if (isDefined(err)) {\n        if (isString(err)) {\n          res.message = err;\n        } else if (isObject(err) && isDefined(err.message) && isString(err.message)) {\n          res.message = err.message;\n        }\n      }\n      deferred.resolve(res);\n    });\n    return deferred.promise();\n  }\n}\nclass CompareRuleValidator extends BaseRuleValidator {\n  constructor() {\n    super();\n    this.NAME = \"compare\";\n  }\n  _validate(value, rule) {\n    if (!rule.comparisonTarget) {\n      throw errors.Error(\"E0102\");\n    }\n    if (rule.ignoreEmptyValue && this._isValueEmpty(value)) {\n      return true;\n    }\n    extend(rule, {\n      reevaluate: true\n    });\n    const otherValue = rule.comparisonTarget();\n    const type = rule.comparisonType || \"==\";\n    switch (type) {\n      case \"==\":\n        return value == otherValue;\n      case \"!=\":\n        return value != otherValue;\n      case \"===\":\n        return value === otherValue;\n      case \"!==\":\n        return value !== otherValue;\n      case \">\":\n        return value > otherValue;\n      case \">=\":\n        return value >= otherValue;\n      case \"<\":\n        return value < otherValue;\n      case \"<=\":\n        return value <= otherValue;\n    }\n  }\n}\nclass PatternRuleValidator extends BaseRuleValidator {\n  constructor() {\n    super();\n    this.NAME = \"pattern\";\n  }\n  _validate(value, rule) {\n    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value)) {\n      return true;\n    }\n    let {\n      pattern: pattern\n    } = rule;\n    if (isString(pattern)) {\n      pattern = new RegExp(pattern);\n    }\n    return pattern.test(value);\n  }\n}\nclass EmailRuleValidator extends BaseRuleValidator {\n  constructor() {\n    super();\n    this.NAME = \"email\";\n  }\n  _validate(value, rule) {\n    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value)) {\n      return true;\n    }\n    return rulesValidators.pattern.validate(value, extend({}, rule, {\n      pattern: EMAIL_VALIDATION_REGEX\n    }));\n  }\n}\nconst rulesValidators = {\n  required: new RequiredRuleValidator(),\n  numeric: new NumericRuleValidator(),\n  range: new RangeRuleValidator(),\n  stringLength: new StringLengthRuleValidator(),\n  custom: new CustomRuleValidator(),\n  async: new AsyncRuleValidator(),\n  compare: new CompareRuleValidator(),\n  pattern: new PatternRuleValidator(),\n  email: new EmailRuleValidator()\n};\nclass GroupConfig extends Class.inherit({}) {\n  ctor(group, isRemovable) {\n    this.group = group;\n    this.validators = [];\n    this._isRemovable = isRemovable;\n    this._pendingValidators = [];\n    this._onValidatorStatusChanged = this._onValidatorStatusChanged.bind(this);\n    this._resetValidationInfo();\n    this._eventsStrategy = new EventsStrategy(this);\n  }\n  validate() {\n    const result = {\n      isValid: true,\n      brokenRules: [],\n      validators: [],\n      status: STATUS.valid,\n      complete: null\n    };\n    this._unsubscribeFromAllChangeEvents();\n    this._pendingValidators = [];\n    this._resetValidationInfo();\n    each(this.validators, (_, validator) => {\n      const validatorResult = validator.validate();\n      result.isValid = result.isValid && validatorResult.isValid;\n      if (validatorResult.brokenRules) {\n        result.brokenRules = result.brokenRules.concat(validatorResult.brokenRules);\n      }\n      result.validators.push(validator);\n      if (validatorResult.status === STATUS.pending) {\n        this._addPendingValidator(validator);\n      }\n      this._subscribeToChangeEvents(validator);\n    });\n    if (this._pendingValidators.length) {\n      result.status = STATUS.pending;\n    } else {\n      result.status = result.isValid ? STATUS.valid : STATUS.invalid;\n      this._unsubscribeFromAllChangeEvents();\n      this._raiseValidatedEvent(result);\n    }\n    this._updateValidationInfo(result);\n    return extend({}, this._validationInfo.result);\n  }\n  _subscribeToChangeEvents(validator) {\n    validator.on(\"validating\", this._onValidatorStatusChanged);\n    validator.on(\"validated\", this._onValidatorStatusChanged);\n  }\n  _unsubscribeFromChangeEvents(validator) {\n    validator.off(\"validating\", this._onValidatorStatusChanged);\n    validator.off(\"validated\", this._onValidatorStatusChanged);\n  }\n  _unsubscribeFromAllChangeEvents() {\n    each(this.validators, (_, validator) => {\n      this._unsubscribeFromChangeEvents(validator);\n    });\n  }\n  _updateValidationInfo(result) {\n    this._validationInfo.result = result;\n    if (result.status !== STATUS.pending) {\n      return;\n    }\n    if (!this._validationInfo.deferred) {\n      this._validationInfo.deferred = Deferred();\n      this._validationInfo.result.complete = this._validationInfo.deferred.promise();\n    }\n  }\n  _addPendingValidator(validator) {\n    const foundValidator = grep(this._pendingValidators, val => val === validator)[0];\n    if (!foundValidator) {\n      this._pendingValidators.push(validator);\n    }\n  }\n  _removePendingValidator(validator) {\n    const index = this._pendingValidators.indexOf(validator);\n    if (index >= 0) {\n      this._pendingValidators.splice(index, 1);\n    }\n  }\n  _orderBrokenRules(brokenRules) {\n    let orderedRules = [];\n    each(this.validators, (_, validator) => {\n      const foundRules = grep(brokenRules, rule => rule.validator === validator);\n      if (foundRules.length) {\n        orderedRules = orderedRules.concat(foundRules);\n      }\n    });\n    return orderedRules;\n  }\n  _updateBrokenRules(result) {\n    if (!this._validationInfo.result) {\n      return;\n    }\n    let {\n      brokenRules: brokenRules\n    } = this._validationInfo.result;\n    const rules = grep(brokenRules, rule => rule.validator !== result.validator);\n    if (result.brokenRules) {\n      brokenRules = rules.concat(result.brokenRules);\n    }\n    this._validationInfo.result.brokenRules = this._orderBrokenRules(brokenRules);\n  }\n  _onValidatorStatusChanged(result) {\n    if (result.status === STATUS.pending) {\n      this._addPendingValidator(result.validator);\n      return;\n    }\n    this._resolveIfComplete(result);\n  }\n  _resolveIfComplete(result) {\n    this._removePendingValidator(result.validator);\n    this._updateBrokenRules(result);\n    if (!this._pendingValidators.length) {\n      this._unsubscribeFromAllChangeEvents();\n      if (!this._validationInfo.result) {\n        return;\n      }\n      this._validationInfo.result.status = 0 === this._validationInfo.result.brokenRules.length ? STATUS.valid : STATUS.invalid;\n      this._validationInfo.result.isValid = this._validationInfo.result.status === STATUS.valid;\n      const res = extend({}, this._validationInfo.result, {\n        complete: null\n      });\n      const {\n        deferred: deferred\n      } = this._validationInfo;\n      this._validationInfo.deferred = null;\n      this._raiseValidatedEvent(res);\n      deferred && setTimeout(() => {\n        deferred.resolve(res);\n      });\n    }\n  }\n  _raiseValidatedEvent(result) {\n    this._eventsStrategy.fireEvent(\"validated\", [result]);\n  }\n  _resetValidationInfo() {\n    this._validationInfo = {\n      result: null,\n      deferred: null\n    };\n  }\n  _synchronizeValidationInfo() {\n    if (this._validationInfo.result) {\n      this._validationInfo.result.validators = this.validators;\n    }\n  }\n  removeRegisteredValidator(validator) {\n    const index = this.validators.indexOf(validator);\n    if (index > -1) {\n      this.validators.splice(index, 1);\n      this._synchronizeValidationInfo();\n      this._resolveIfComplete({\n        validator: validator\n      });\n    }\n  }\n  registerValidator(validator) {\n    if (!this.validators.includes(validator)) {\n      this.validators.push(validator);\n      this._synchronizeValidationInfo();\n    }\n  }\n  reset() {\n    each(this.validators, (_, validator) => {\n      validator.reset();\n    });\n    this._pendingValidators = [];\n    this._resetValidationInfo();\n  }\n  on(eventName, eventHandler) {\n    this._eventsStrategy.on(eventName, eventHandler);\n    return this;\n  }\n  off(eventName, eventHandler) {\n    this._eventsStrategy.off(eventName, eventHandler);\n    return this;\n  }\n}\nconst ValidationEngine = {\n  groups: [],\n  getGroupConfig(group) {\n    const result = grep(this.groups, config => config.group === group);\n    if (result.length) {\n      return result[0];\n    }\n  },\n  findGroup($element, model) {\n    var _$element$data;\n    const hasValidationGroup = null === (_$element$data = $element.data()) || void 0 === _$element$data || null === (_$element$data = _$element$data.dxComponents) || void 0 === _$element$data ? void 0 : _$element$data.includes(\"dxValidationGroup\");\n    const validationGroup = hasValidationGroup && $element.dxValidationGroup(\"instance\");\n    if (validationGroup) {\n      return validationGroup;\n    }\n    const $dxGroup = $element.parents(\".dx-validationgroup\").first();\n    if ($dxGroup.length) {\n      return $dxGroup.dxValidationGroup(\"instance\");\n    }\n    return model;\n  },\n  initGroups() {\n    this.groups = [];\n    this.addGroup(void 0, false);\n  },\n  addGroup(group) {\n    let isRemovable = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : true;\n    let config = this.getGroupConfig(group);\n    if (!config) {\n      config = new GroupConfig(group, isRemovable);\n      this.groups.push(config);\n    }\n    return config;\n  },\n  removeGroup(group) {\n    const config = this.getGroupConfig(group);\n    const index = this.groups.indexOf(config);\n    if (index > -1) {\n      this.groups.splice(index, 1);\n    }\n    return config;\n  },\n  _setDefaultMessage(info) {\n    const {\n      rule: rule,\n      validator: validator,\n      name: name\n    } = info;\n    if (!isDefined(rule.message)) {\n      if (validator.defaultFormattedMessage && isDefined(name)) {\n        rule.message = validator.defaultFormattedMessage(name);\n      } else {\n        rule.message = validator.defaultMessage();\n      }\n    }\n  },\n  _addBrokenRule(info) {\n    const {\n      result: result,\n      rule: rule\n    } = info;\n    if (!result.brokenRule) {\n      result.brokenRule = rule;\n    }\n    if (!result.brokenRules) {\n      result.brokenRules = [];\n    }\n    result.brokenRules.push(rule);\n  },\n  validate(value, rules, name) {\n    var _rules$;\n    let result = {\n      name: name,\n      value: value,\n      brokenRule: null,\n      brokenRules: null,\n      isValid: true,\n      validationRules: rules,\n      pendingRules: null,\n      status: STATUS.valid,\n      complete: null\n    };\n    const validator = null === rules || void 0 === rules || null === (_rules$ = rules[0]) || void 0 === _rules$ ? void 0 : _rules$.validator;\n    const asyncRuleItems = [];\n    each(rules || [], (_, rule) => {\n      const ruleValidator = rulesValidators[rule.type];\n      let ruleValidationResult;\n      if (ruleValidator) {\n        if (isDefined(rule.isValid) && rule.value === value && !rule.reevaluate) {\n          if (!rule.isValid) {\n            result.isValid = false;\n            this._addBrokenRule({\n              result: result,\n              rule: rule\n            });\n            return false;\n          }\n          return true;\n        }\n        rule.value = value;\n        if (\"async\" === rule.type) {\n          asyncRuleItems.push({\n            rule: rule,\n            ruleValidator: ruleValidator\n          });\n          return true;\n        }\n        ruleValidationResult = ruleValidator.validate(value, rule);\n        rule.isValid = ruleValidationResult;\n        if (!ruleValidationResult) {\n          result.isValid = false;\n          this._setDefaultMessage({\n            rule: rule,\n            validator: ruleValidator,\n            name: name\n          });\n          this._addBrokenRule({\n            result: result,\n            rule: rule\n          });\n        }\n        if (!rule.isValid) {\n          return false;\n        }\n      } else {\n        throw errors.Error(\"E0100\");\n      }\n    });\n    if (result.isValid && !result.brokenRules && asyncRuleItems.length) {\n      result = this._validateAsyncRules({\n        value: value,\n        items: asyncRuleItems,\n        result: result,\n        name: name\n      });\n    }\n    this._synchronizeGroupValidationInfo(validator, result);\n    result.status = result.pendingRules ? STATUS.pending : result.isValid ? STATUS.valid : STATUS.invalid;\n    return result;\n  },\n  _synchronizeGroupValidationInfo(validator, result) {\n    if (!validator) {\n      return;\n    }\n    const groupConfig = ValidationEngine.getGroupConfig(validator._validationGroup);\n    groupConfig._updateBrokenRules.call(groupConfig, {\n      validator: validator,\n      brokenRules: result.brokenRules ?? []\n    });\n  },\n  _validateAsyncRules(_ref) {\n    let {\n      result: result,\n      value: value,\n      items: items,\n      name: name\n    } = _ref;\n    const asyncResults = [];\n    each(items, (_, item) => {\n      const validateResult = item.ruleValidator.validate(value, item.rule);\n      if (!isPromise(validateResult)) {\n        this._updateRuleConfig({\n          rule: item.rule,\n          ruleResult: this._getPatchedRuleResult(validateResult),\n          validator: item.ruleValidator,\n          name: name\n        });\n      } else {\n        if (!result.pendingRules) {\n          result.pendingRules = [];\n        }\n        result.pendingRules.push(item.rule);\n        const asyncResult = validateResult.then(res => {\n          const ruleResult = this._getPatchedRuleResult(res);\n          this._updateRuleConfig({\n            rule: item.rule,\n            ruleResult: ruleResult,\n            validator: item.ruleValidator,\n            name: name\n          });\n          return ruleResult;\n        });\n        asyncResults.push(asyncResult);\n      }\n    });\n    if (asyncResults.length) {\n      result.complete = Promise.all(asyncResults).then(values => this._getAsyncRulesResult({\n        result: result,\n        values: values\n      }));\n    }\n    return result;\n  },\n  _updateRuleConfig(_ref2) {\n    let {\n      rule: rule,\n      ruleResult: ruleResult,\n      validator: validator,\n      name: name\n    } = _ref2;\n    rule.isValid = ruleResult.isValid;\n    if (!ruleResult.isValid) {\n      if (isDefined(ruleResult.message) && isString(ruleResult.message) && ruleResult.message.length) {\n        rule.message = ruleResult.message;\n      } else {\n        this._setDefaultMessage({\n          rule: rule,\n          validator: validator,\n          name: name\n        });\n      }\n    }\n  },\n  _getPatchedRuleResult(ruleResult) {\n    let result;\n    if (isObject(ruleResult)) {\n      result = extend({}, ruleResult);\n      if (!isDefined(result.isValid)) {\n        result.isValid = true;\n      }\n    } else {\n      result = {\n        isValid: isBoolean(ruleResult) ? ruleResult : true\n      };\n    }\n    return result;\n  },\n  _getAsyncRulesResult(_ref3) {\n    let {\n      values: values,\n      result: result\n    } = _ref3;\n    each(values, (index, val) => {\n      if (false === val.isValid) {\n        result.isValid = val.isValid;\n        const rule = result.pendingRules[index];\n        this._addBrokenRule({\n          result: result,\n          rule: rule\n        });\n      }\n    });\n    result.pendingRules = null;\n    result.complete = null;\n    result.status = result.isValid ? STATUS.valid : STATUS.invalid;\n    return result;\n  },\n  registerValidatorInGroup(group, validator) {\n    const groupConfig = ValidationEngine.addGroup(group);\n    groupConfig.registerValidator.call(groupConfig, validator);\n  },\n  removeRegisteredValidator(group, validator) {\n    const config = ValidationEngine.getGroupConfig(group);\n    if (config) {\n      config.removeRegisteredValidator.call(config, validator);\n      const validatorsInGroup = config.validators;\n      const isRemovable = config._isRemovable;\n      const shouldRemoveGroup = 0 === validatorsInGroup.length && isRemovable;\n      if (shouldRemoveGroup) {\n        this.removeGroup(group);\n      }\n    }\n  },\n  initValidationOptions(options) {\n    const initedOptions = {};\n    if (options) {\n      const syncOptions = [\"isValid\", \"validationStatus\", \"validationError\", \"validationErrors\"];\n      syncOptions.forEach(prop => {\n        if (prop in options) {\n          extend(initedOptions, this.synchronizeValidationOptions({\n            name: prop,\n            value: options[prop]\n          }, options));\n        }\n      });\n    }\n    return initedOptions;\n  },\n  synchronizeValidationOptions(_ref4, options) {\n    let {\n      name: name,\n      value: value\n    } = _ref4;\n    switch (name) {\n      case \"validationStatus\":\n        {\n          const isValid = value === STATUS.valid || value === STATUS.pending;\n          return options.isValid !== isValid ? {\n            isValid: isValid\n          } : {};\n        }\n      case \"isValid\":\n        {\n          const {\n            validationStatus: validationStatus\n          } = options;\n          let newStatus = validationStatus;\n          if (value && validationStatus === STATUS.invalid) {\n            newStatus = STATUS.valid;\n          } else if (!value && validationStatus !== STATUS.invalid) {\n            newStatus = STATUS.invalid;\n          }\n          return newStatus !== validationStatus ? {\n            validationStatus: newStatus\n          } : {};\n        }\n      case \"validationErrors\":\n        {\n          const validationError = !(null !== value && void 0 !== value && value.length) ? null : value[0];\n          return options.validationError !== validationError ? {\n            validationError: validationError\n          } : {};\n        }\n      case \"validationError\":\n        {\n          const {\n            validationErrors: validationErrors\n          } = options;\n          if (!value && validationErrors) {\n            return {\n              validationErrors: null\n            };\n          }\n          if (value && !validationErrors) {\n            return {\n              validationErrors: [value]\n            };\n          }\n          if (value && validationErrors && value !== validationErrors[0]) {\n            validationErrors[0] = value;\n            return {\n              validationErrors: validationErrors.slice()\n            };\n          }\n        }\n    }\n    return {};\n  },\n  validateGroup(group) {\n    const groupConfig = ValidationEngine.getGroupConfig(group);\n    if (!groupConfig) {\n      throw errors.Error(\"E0110\");\n    }\n    return groupConfig.validate();\n  },\n  resetGroup(group) {\n    const groupConfig = ValidationEngine.getGroupConfig(group);\n    if (!groupConfig) {\n      throw errors.Error(\"E0110\");\n    }\n    return groupConfig.reset();\n  }\n};\nValidationEngine.initGroups();\nexport default ValidationEngine;","map":{"version":3,"names":["messageLocalization","numberLocalization","Class","errors","EventsStrategy","grep","Deferred","fromPromise","extend","each","isBoolean","isDate","isDefined","isFunction","isNumeric","isObject","isPromise","isString","EMAIL_VALIDATION_REGEX","STATUS","valid","invalid","pending","BaseRuleValidator","constructor","NAME","defaultMessage","value","getFormatter","defaultFormattedMessage","_isValueEmpty","rulesValidators","required","validate","rule","valueArray","Array","isArray","result","length","every","itemValue","_validate","RequiredRuleValidator","String","trim","NumericRuleValidator","ignoreEmptyValue","useCultureSettings","isNaN","parse","RangeRuleValidator","validNumber","numeric","validValue","number","parseFloat","valueOf","min","max","Error","StringLengthRuleValidator","range","CustomRuleValidator","validator","dataGetter","option","extraParams","params","validationCallback","AsyncRuleValidator","reevaluate","callbackResult","_getWrappedPromise","promise","deferred","then","res","resolve","err","isValid","message","CompareRuleValidator","comparisonTarget","otherValue","type","comparisonType","PatternRuleValidator","pattern","RegExp","test","EmailRuleValidator","stringLength","custom","async","compare","email","GroupConfig","inherit","ctor","group","isRemovable","validators","_isRemovable","_pendingValidators","_onValidatorStatusChanged","bind","_resetValidationInfo","_eventsStrategy","brokenRules","status","complete","_unsubscribeFromAllChangeEvents","_","validatorResult","concat","push","_addPendingValidator","_subscribeToChangeEvents","_raiseValidatedEvent","_updateValidationInfo","_validationInfo","on","_unsubscribeFromChangeEvents","off","foundValidator","val","_removePendingValidator","index","indexOf","splice","_orderBrokenRules","orderedRules","foundRules","_updateBrokenRules","rules","_resolveIfComplete","setTimeout","fireEvent","_synchronizeValidationInfo","removeRegisteredValidator","registerValidator","includes","reset","eventName","eventHandler","ValidationEngine","groups","getGroupConfig","config","findGroup","$element","model","_$element$data","hasValidationGroup","data","dxComponents","validationGroup","dxValidationGroup","$dxGroup","parents","first","initGroups","addGroup","arguments","removeGroup","_setDefaultMessage","info","name","_addBrokenRule","brokenRule","_rules$","validationRules","pendingRules","asyncRuleItems","ruleValidator","ruleValidationResult","_validateAsyncRules","items","_synchronizeGroupValidationInfo","groupConfig","_validationGroup","call","_ref","asyncResults","item","validateResult","_updateRuleConfig","ruleResult","_getPatchedRuleResult","asyncResult","Promise","all","values","_getAsyncRulesResult","_ref2","_ref3","registerValidatorInGroup","validatorsInGroup","shouldRemoveGroup","initValidationOptions","options","initedOptions","syncOptions","forEach","prop","synchronizeValidationOptions","_ref4","validationStatus","newStatus","validationError","validationErrors","slice","validateGroup","resetGroup"],"sources":["/home/nataf/Cours/world-cities-map/client/node_modules/devextreme/esm/__internal/ui/m_validation_engine.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/__internal/ui/m_validation_engine.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport messageLocalization from \"../../common/core/localization/message\";\r\nimport numberLocalization from \"../../common/core/localization/number\";\r\nimport Class from \"../../core/class\";\r\nimport errors from \"../../core/errors\";\r\nimport {\r\n    EventsStrategy\r\n} from \"../../core/events_strategy\";\r\nimport {\r\n    grep\r\n} from \"../../core/utils/common\";\r\nimport {\r\n    Deferred,\r\n    fromPromise\r\n} from \"../../core/utils/deferred\";\r\nimport {\r\n    extend\r\n} from \"../../core/utils/extend\";\r\nimport {\r\n    each\r\n} from \"../../core/utils/iterator\";\r\nimport {\r\n    isBoolean,\r\n    isDate,\r\n    isDefined,\r\n    isFunction,\r\n    isNumeric,\r\n    isObject,\r\n    isPromise,\r\n    isString\r\n} from \"../../core/utils/type\";\r\nconst EMAIL_VALIDATION_REGEX = /^[\\d\\w.+_-]+@[\\d\\w._-]+\\.[\\w]+$/i;\r\nconst STATUS = {\r\n    valid: \"valid\",\r\n    invalid: \"invalid\",\r\n    pending: \"pending\"\r\n};\r\nclass BaseRuleValidator {\r\n    constructor() {\r\n        this.NAME = \"base\"\r\n    }\r\n    defaultMessage(value) {\r\n        return messageLocalization.getFormatter(`validation-${this.NAME}`)(value)\r\n    }\r\n    defaultFormattedMessage(value) {\r\n        return messageLocalization.getFormatter(`validation-${this.NAME}-formatted`)(value)\r\n    }\r\n    _isValueEmpty(value) {\r\n        return !rulesValidators.required.validate(value, {})\r\n    }\r\n    validate(value, rule) {\r\n        const valueArray = Array.isArray(value) ? value : [value];\r\n        let result = true;\r\n        if (valueArray.length) {\r\n            valueArray.every((itemValue => {\r\n                result = this._validate(itemValue, rule);\r\n                return result\r\n            }))\r\n        } else {\r\n            result = this._validate(null, rule)\r\n        }\r\n        return result\r\n    }\r\n}\r\nclass RequiredRuleValidator extends BaseRuleValidator {\r\n    constructor() {\r\n        super();\r\n        this.NAME = \"required\"\r\n    }\r\n    _validate(value, rule) {\r\n        if (!isDefined(value)) {\r\n            return false\r\n        }\r\n        if (false === value) {\r\n            return false\r\n        }\r\n        value = String(value);\r\n        if (rule.trim || !isDefined(rule.trim)) {\r\n            value = value.trim()\r\n        }\r\n        return \"\" !== value\r\n    }\r\n}\r\nclass NumericRuleValidator extends BaseRuleValidator {\r\n    constructor() {\r\n        super();\r\n        this.NAME = \"numeric\"\r\n    }\r\n    _validate(value, rule) {\r\n        if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value)) {\r\n            return true\r\n        }\r\n        if (rule.useCultureSettings && isString(value)) {\r\n            return !isNaN(numberLocalization.parse(value))\r\n        }\r\n        return isNumeric(value)\r\n    }\r\n}\r\nclass RangeRuleValidator extends BaseRuleValidator {\r\n    constructor() {\r\n        super();\r\n        this.NAME = \"range\"\r\n    }\r\n    _validate(value, rule) {\r\n        if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value)) {\r\n            return true\r\n        }\r\n        const validNumber = rulesValidators.numeric.validate(value, rule);\r\n        const validValue = isDefined(value) && \"\" !== value;\r\n        const number = validNumber ? parseFloat(value) : validValue && value.valueOf();\r\n        const {\r\n            min: min\r\n        } = rule;\r\n        const {\r\n            max: max\r\n        } = rule;\r\n        if (!(validNumber || isDate(value)) && !validValue) {\r\n            return false\r\n        }\r\n        if (isDefined(min)) {\r\n            if (isDefined(max)) {\r\n                return number >= min && number <= max\r\n            }\r\n            return number >= min\r\n        }\r\n        if (isDefined(max)) {\r\n            return number <= max\r\n        }\r\n        throw errors.Error(\"E0101\")\r\n    }\r\n}\r\nclass StringLengthRuleValidator extends BaseRuleValidator {\r\n    constructor() {\r\n        super();\r\n        this.NAME = \"stringLength\"\r\n    }\r\n    _validate(value, rule) {\r\n        value = String(value ?? \"\");\r\n        if (rule.trim || !isDefined(rule.trim)) {\r\n            value = value.trim()\r\n        }\r\n        if (rule.ignoreEmptyValue && this._isValueEmpty(value)) {\r\n            return true\r\n        }\r\n        return rulesValidators.range.validate(value.length, extend({}, rule))\r\n    }\r\n}\r\nclass CustomRuleValidator extends BaseRuleValidator {\r\n    constructor() {\r\n        super();\r\n        this.NAME = \"custom\"\r\n    }\r\n    validate(value, rule) {\r\n        if (rule.ignoreEmptyValue && this._isValueEmpty(value)) {\r\n            return true\r\n        }\r\n        const {\r\n            validator: validator\r\n        } = rule;\r\n        const dataGetter = validator && isFunction(validator.option) && validator.option(\"dataGetter\");\r\n        const extraParams = isFunction(dataGetter) && dataGetter();\r\n        const params = {\r\n            value: value,\r\n            validator: validator,\r\n            rule: rule\r\n        };\r\n        if (extraParams) {\r\n            extend(params, extraParams)\r\n        }\r\n        return rule.validationCallback(params)\r\n    }\r\n}\r\nclass AsyncRuleValidator extends CustomRuleValidator {\r\n    constructor() {\r\n        super();\r\n        this.NAME = \"async\"\r\n    }\r\n    validate(value, rule) {\r\n        if (!isDefined(rule.reevaluate)) {\r\n            extend(rule, {\r\n                reevaluate: true\r\n            })\r\n        }\r\n        if (rule.ignoreEmptyValue && this._isValueEmpty(value)) {\r\n            return true\r\n        }\r\n        const {\r\n            validator: validator\r\n        } = rule;\r\n        const dataGetter = validator && isFunction(validator.option) && validator.option(\"dataGetter\");\r\n        const extraParams = isFunction(dataGetter) && dataGetter();\r\n        const params = {\r\n            value: value,\r\n            validator: validator,\r\n            rule: rule\r\n        };\r\n        if (extraParams) {\r\n            extend(params, extraParams)\r\n        }\r\n        const callbackResult = rule.validationCallback(params);\r\n        if (!isPromise(callbackResult)) {\r\n            throw errors.Error(\"E0103\")\r\n        }\r\n        return this._getWrappedPromise(fromPromise(callbackResult).promise())\r\n    }\r\n    _getWrappedPromise(promise) {\r\n        const deferred = Deferred();\r\n        promise.then((res => {\r\n            deferred.resolve(res)\r\n        }), (err => {\r\n            const res = {\r\n                isValid: false\r\n            };\r\n            if (isDefined(err)) {\r\n                if (isString(err)) {\r\n                    res.message = err\r\n                } else if (isObject(err) && isDefined(err.message) && isString(err.message)) {\r\n                    res.message = err.message\r\n                }\r\n            }\r\n            deferred.resolve(res)\r\n        }));\r\n        return deferred.promise()\r\n    }\r\n}\r\nclass CompareRuleValidator extends BaseRuleValidator {\r\n    constructor() {\r\n        super();\r\n        this.NAME = \"compare\"\r\n    }\r\n    _validate(value, rule) {\r\n        if (!rule.comparisonTarget) {\r\n            throw errors.Error(\"E0102\")\r\n        }\r\n        if (rule.ignoreEmptyValue && this._isValueEmpty(value)) {\r\n            return true\r\n        }\r\n        extend(rule, {\r\n            reevaluate: true\r\n        });\r\n        const otherValue = rule.comparisonTarget();\r\n        const type = rule.comparisonType || \"==\";\r\n        switch (type) {\r\n            case \"==\":\r\n                return value == otherValue;\r\n            case \"!=\":\r\n                return value != otherValue;\r\n            case \"===\":\r\n                return value === otherValue;\r\n            case \"!==\":\r\n                return value !== otherValue;\r\n            case \">\":\r\n                return value > otherValue;\r\n            case \">=\":\r\n                return value >= otherValue;\r\n            case \"<\":\r\n                return value < otherValue;\r\n            case \"<=\":\r\n                return value <= otherValue\r\n        }\r\n    }\r\n}\r\nclass PatternRuleValidator extends BaseRuleValidator {\r\n    constructor() {\r\n        super();\r\n        this.NAME = \"pattern\"\r\n    }\r\n    _validate(value, rule) {\r\n        if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value)) {\r\n            return true\r\n        }\r\n        let {\r\n            pattern: pattern\r\n        } = rule;\r\n        if (isString(pattern)) {\r\n            pattern = new RegExp(pattern)\r\n        }\r\n        return pattern.test(value)\r\n    }\r\n}\r\nclass EmailRuleValidator extends BaseRuleValidator {\r\n    constructor() {\r\n        super();\r\n        this.NAME = \"email\"\r\n    }\r\n    _validate(value, rule) {\r\n        if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value)) {\r\n            return true\r\n        }\r\n        return rulesValidators.pattern.validate(value, extend({}, rule, {\r\n            pattern: EMAIL_VALIDATION_REGEX\r\n        }))\r\n    }\r\n}\r\nconst rulesValidators = {\r\n    required: new RequiredRuleValidator,\r\n    numeric: new NumericRuleValidator,\r\n    range: new RangeRuleValidator,\r\n    stringLength: new StringLengthRuleValidator,\r\n    custom: new CustomRuleValidator,\r\n    async: new AsyncRuleValidator,\r\n    compare: new CompareRuleValidator,\r\n    pattern: new PatternRuleValidator,\r\n    email: new EmailRuleValidator\r\n};\r\nclass GroupConfig extends(Class.inherit({})) {\r\n    ctor(group, isRemovable) {\r\n        this.group = group;\r\n        this.validators = [];\r\n        this._isRemovable = isRemovable;\r\n        this._pendingValidators = [];\r\n        this._onValidatorStatusChanged = this._onValidatorStatusChanged.bind(this);\r\n        this._resetValidationInfo();\r\n        this._eventsStrategy = new EventsStrategy(this)\r\n    }\r\n    validate() {\r\n        const result = {\r\n            isValid: true,\r\n            brokenRules: [],\r\n            validators: [],\r\n            status: STATUS.valid,\r\n            complete: null\r\n        };\r\n        this._unsubscribeFromAllChangeEvents();\r\n        this._pendingValidators = [];\r\n        this._resetValidationInfo();\r\n        each(this.validators, ((_, validator) => {\r\n            const validatorResult = validator.validate();\r\n            result.isValid = result.isValid && validatorResult.isValid;\r\n            if (validatorResult.brokenRules) {\r\n                result.brokenRules = result.brokenRules.concat(validatorResult.brokenRules)\r\n            }\r\n            result.validators.push(validator);\r\n            if (validatorResult.status === STATUS.pending) {\r\n                this._addPendingValidator(validator)\r\n            }\r\n            this._subscribeToChangeEvents(validator)\r\n        }));\r\n        if (this._pendingValidators.length) {\r\n            result.status = STATUS.pending\r\n        } else {\r\n            result.status = result.isValid ? STATUS.valid : STATUS.invalid;\r\n            this._unsubscribeFromAllChangeEvents();\r\n            this._raiseValidatedEvent(result)\r\n        }\r\n        this._updateValidationInfo(result);\r\n        return extend({}, this._validationInfo.result)\r\n    }\r\n    _subscribeToChangeEvents(validator) {\r\n        validator.on(\"validating\", this._onValidatorStatusChanged);\r\n        validator.on(\"validated\", this._onValidatorStatusChanged)\r\n    }\r\n    _unsubscribeFromChangeEvents(validator) {\r\n        validator.off(\"validating\", this._onValidatorStatusChanged);\r\n        validator.off(\"validated\", this._onValidatorStatusChanged)\r\n    }\r\n    _unsubscribeFromAllChangeEvents() {\r\n        each(this.validators, ((_, validator) => {\r\n            this._unsubscribeFromChangeEvents(validator)\r\n        }))\r\n    }\r\n    _updateValidationInfo(result) {\r\n        this._validationInfo.result = result;\r\n        if (result.status !== STATUS.pending) {\r\n            return\r\n        }\r\n        if (!this._validationInfo.deferred) {\r\n            this._validationInfo.deferred = Deferred();\r\n            this._validationInfo.result.complete = this._validationInfo.deferred.promise()\r\n        }\r\n    }\r\n    _addPendingValidator(validator) {\r\n        const foundValidator = grep(this._pendingValidators, (val => val === validator))[0];\r\n        if (!foundValidator) {\r\n            this._pendingValidators.push(validator)\r\n        }\r\n    }\r\n    _removePendingValidator(validator) {\r\n        const index = this._pendingValidators.indexOf(validator);\r\n        if (index >= 0) {\r\n            this._pendingValidators.splice(index, 1)\r\n        }\r\n    }\r\n    _orderBrokenRules(brokenRules) {\r\n        let orderedRules = [];\r\n        each(this.validators, ((_, validator) => {\r\n            const foundRules = grep(brokenRules, (rule => rule.validator === validator));\r\n            if (foundRules.length) {\r\n                orderedRules = orderedRules.concat(foundRules)\r\n            }\r\n        }));\r\n        return orderedRules\r\n    }\r\n    _updateBrokenRules(result) {\r\n        if (!this._validationInfo.result) {\r\n            return\r\n        }\r\n        let {\r\n            brokenRules: brokenRules\r\n        } = this._validationInfo.result;\r\n        const rules = grep(brokenRules, (rule => rule.validator !== result.validator));\r\n        if (result.brokenRules) {\r\n            brokenRules = rules.concat(result.brokenRules)\r\n        }\r\n        this._validationInfo.result.brokenRules = this._orderBrokenRules(brokenRules)\r\n    }\r\n    _onValidatorStatusChanged(result) {\r\n        if (result.status === STATUS.pending) {\r\n            this._addPendingValidator(result.validator);\r\n            return\r\n        }\r\n        this._resolveIfComplete(result)\r\n    }\r\n    _resolveIfComplete(result) {\r\n        this._removePendingValidator(result.validator);\r\n        this._updateBrokenRules(result);\r\n        if (!this._pendingValidators.length) {\r\n            this._unsubscribeFromAllChangeEvents();\r\n            if (!this._validationInfo.result) {\r\n                return\r\n            }\r\n            this._validationInfo.result.status = 0 === this._validationInfo.result.brokenRules.length ? STATUS.valid : STATUS.invalid;\r\n            this._validationInfo.result.isValid = this._validationInfo.result.status === STATUS.valid;\r\n            const res = extend({}, this._validationInfo.result, {\r\n                complete: null\r\n            });\r\n            const {\r\n                deferred: deferred\r\n            } = this._validationInfo;\r\n            this._validationInfo.deferred = null;\r\n            this._raiseValidatedEvent(res);\r\n            deferred && setTimeout((() => {\r\n                deferred.resolve(res)\r\n            }))\r\n        }\r\n    }\r\n    _raiseValidatedEvent(result) {\r\n        this._eventsStrategy.fireEvent(\"validated\", [result])\r\n    }\r\n    _resetValidationInfo() {\r\n        this._validationInfo = {\r\n            result: null,\r\n            deferred: null\r\n        }\r\n    }\r\n    _synchronizeValidationInfo() {\r\n        if (this._validationInfo.result) {\r\n            this._validationInfo.result.validators = this.validators\r\n        }\r\n    }\r\n    removeRegisteredValidator(validator) {\r\n        const index = this.validators.indexOf(validator);\r\n        if (index > -1) {\r\n            this.validators.splice(index, 1);\r\n            this._synchronizeValidationInfo();\r\n            this._resolveIfComplete({\r\n                validator: validator\r\n            })\r\n        }\r\n    }\r\n    registerValidator(validator) {\r\n        if (!this.validators.includes(validator)) {\r\n            this.validators.push(validator);\r\n            this._synchronizeValidationInfo()\r\n        }\r\n    }\r\n    reset() {\r\n        each(this.validators, ((_, validator) => {\r\n            validator.reset()\r\n        }));\r\n        this._pendingValidators = [];\r\n        this._resetValidationInfo()\r\n    }\r\n    on(eventName, eventHandler) {\r\n        this._eventsStrategy.on(eventName, eventHandler);\r\n        return this\r\n    }\r\n    off(eventName, eventHandler) {\r\n        this._eventsStrategy.off(eventName, eventHandler);\r\n        return this\r\n    }\r\n}\r\nconst ValidationEngine = {\r\n    groups: [],\r\n    getGroupConfig(group) {\r\n        const result = grep(this.groups, (config => config.group === group));\r\n        if (result.length) {\r\n            return result[0]\r\n        }\r\n    },\r\n    findGroup($element, model) {\r\n        var _$element$data;\r\n        const hasValidationGroup = null === (_$element$data = $element.data()) || void 0 === _$element$data || null === (_$element$data = _$element$data.dxComponents) || void 0 === _$element$data ? void 0 : _$element$data.includes(\"dxValidationGroup\");\r\n        const validationGroup = hasValidationGroup && $element.dxValidationGroup(\"instance\");\r\n        if (validationGroup) {\r\n            return validationGroup\r\n        }\r\n        const $dxGroup = $element.parents(\".dx-validationgroup\").first();\r\n        if ($dxGroup.length) {\r\n            return $dxGroup.dxValidationGroup(\"instance\")\r\n        }\r\n        return model\r\n    },\r\n    initGroups() {\r\n        this.groups = [];\r\n        this.addGroup(void 0, false)\r\n    },\r\n    addGroup(group) {\r\n        let isRemovable = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : true;\r\n        let config = this.getGroupConfig(group);\r\n        if (!config) {\r\n            config = new GroupConfig(group, isRemovable);\r\n            this.groups.push(config)\r\n        }\r\n        return config\r\n    },\r\n    removeGroup(group) {\r\n        const config = this.getGroupConfig(group);\r\n        const index = this.groups.indexOf(config);\r\n        if (index > -1) {\r\n            this.groups.splice(index, 1)\r\n        }\r\n        return config\r\n    },\r\n    _setDefaultMessage(info) {\r\n        const {\r\n            rule: rule,\r\n            validator: validator,\r\n            name: name\r\n        } = info;\r\n        if (!isDefined(rule.message)) {\r\n            if (validator.defaultFormattedMessage && isDefined(name)) {\r\n                rule.message = validator.defaultFormattedMessage(name)\r\n            } else {\r\n                rule.message = validator.defaultMessage()\r\n            }\r\n        }\r\n    },\r\n    _addBrokenRule(info) {\r\n        const {\r\n            result: result,\r\n            rule: rule\r\n        } = info;\r\n        if (!result.brokenRule) {\r\n            result.brokenRule = rule\r\n        }\r\n        if (!result.brokenRules) {\r\n            result.brokenRules = []\r\n        }\r\n        result.brokenRules.push(rule)\r\n    },\r\n    validate(value, rules, name) {\r\n        var _rules$;\r\n        let result = {\r\n            name: name,\r\n            value: value,\r\n            brokenRule: null,\r\n            brokenRules: null,\r\n            isValid: true,\r\n            validationRules: rules,\r\n            pendingRules: null,\r\n            status: STATUS.valid,\r\n            complete: null\r\n        };\r\n        const validator = null === rules || void 0 === rules || null === (_rules$ = rules[0]) || void 0 === _rules$ ? void 0 : _rules$.validator;\r\n        const asyncRuleItems = [];\r\n        each(rules || [], ((_, rule) => {\r\n            const ruleValidator = rulesValidators[rule.type];\r\n            let ruleValidationResult;\r\n            if (ruleValidator) {\r\n                if (isDefined(rule.isValid) && rule.value === value && !rule.reevaluate) {\r\n                    if (!rule.isValid) {\r\n                        result.isValid = false;\r\n                        this._addBrokenRule({\r\n                            result: result,\r\n                            rule: rule\r\n                        });\r\n                        return false\r\n                    }\r\n                    return true\r\n                }\r\n                rule.value = value;\r\n                if (\"async\" === rule.type) {\r\n                    asyncRuleItems.push({\r\n                        rule: rule,\r\n                        ruleValidator: ruleValidator\r\n                    });\r\n                    return true\r\n                }\r\n                ruleValidationResult = ruleValidator.validate(value, rule);\r\n                rule.isValid = ruleValidationResult;\r\n                if (!ruleValidationResult) {\r\n                    result.isValid = false;\r\n                    this._setDefaultMessage({\r\n                        rule: rule,\r\n                        validator: ruleValidator,\r\n                        name: name\r\n                    });\r\n                    this._addBrokenRule({\r\n                        result: result,\r\n                        rule: rule\r\n                    })\r\n                }\r\n                if (!rule.isValid) {\r\n                    return false\r\n                }\r\n            } else {\r\n                throw errors.Error(\"E0100\")\r\n            }\r\n        }));\r\n        if (result.isValid && !result.brokenRules && asyncRuleItems.length) {\r\n            result = this._validateAsyncRules({\r\n                value: value,\r\n                items: asyncRuleItems,\r\n                result: result,\r\n                name: name\r\n            })\r\n        }\r\n        this._synchronizeGroupValidationInfo(validator, result);\r\n        result.status = result.pendingRules ? STATUS.pending : result.isValid ? STATUS.valid : STATUS.invalid;\r\n        return result\r\n    },\r\n    _synchronizeGroupValidationInfo(validator, result) {\r\n        if (!validator) {\r\n            return\r\n        }\r\n        const groupConfig = ValidationEngine.getGroupConfig(validator._validationGroup);\r\n        groupConfig._updateBrokenRules.call(groupConfig, {\r\n            validator: validator,\r\n            brokenRules: result.brokenRules ?? []\r\n        })\r\n    },\r\n    _validateAsyncRules(_ref) {\r\n        let {\r\n            result: result,\r\n            value: value,\r\n            items: items,\r\n            name: name\r\n        } = _ref;\r\n        const asyncResults = [];\r\n        each(items, ((_, item) => {\r\n            const validateResult = item.ruleValidator.validate(value, item.rule);\r\n            if (!isPromise(validateResult)) {\r\n                this._updateRuleConfig({\r\n                    rule: item.rule,\r\n                    ruleResult: this._getPatchedRuleResult(validateResult),\r\n                    validator: item.ruleValidator,\r\n                    name: name\r\n                })\r\n            } else {\r\n                if (!result.pendingRules) {\r\n                    result.pendingRules = []\r\n                }\r\n                result.pendingRules.push(item.rule);\r\n                const asyncResult = validateResult.then((res => {\r\n                    const ruleResult = this._getPatchedRuleResult(res);\r\n                    this._updateRuleConfig({\r\n                        rule: item.rule,\r\n                        ruleResult: ruleResult,\r\n                        validator: item.ruleValidator,\r\n                        name: name\r\n                    });\r\n                    return ruleResult\r\n                }));\r\n                asyncResults.push(asyncResult)\r\n            }\r\n        }));\r\n        if (asyncResults.length) {\r\n            result.complete = Promise.all(asyncResults).then((values => this._getAsyncRulesResult({\r\n                result: result,\r\n                values: values\r\n            })))\r\n        }\r\n        return result\r\n    },\r\n    _updateRuleConfig(_ref2) {\r\n        let {\r\n            rule: rule,\r\n            ruleResult: ruleResult,\r\n            validator: validator,\r\n            name: name\r\n        } = _ref2;\r\n        rule.isValid = ruleResult.isValid;\r\n        if (!ruleResult.isValid) {\r\n            if (isDefined(ruleResult.message) && isString(ruleResult.message) && ruleResult.message.length) {\r\n                rule.message = ruleResult.message\r\n            } else {\r\n                this._setDefaultMessage({\r\n                    rule: rule,\r\n                    validator: validator,\r\n                    name: name\r\n                })\r\n            }\r\n        }\r\n    },\r\n    _getPatchedRuleResult(ruleResult) {\r\n        let result;\r\n        if (isObject(ruleResult)) {\r\n            result = extend({}, ruleResult);\r\n            if (!isDefined(result.isValid)) {\r\n                result.isValid = true\r\n            }\r\n        } else {\r\n            result = {\r\n                isValid: isBoolean(ruleResult) ? ruleResult : true\r\n            }\r\n        }\r\n        return result\r\n    },\r\n    _getAsyncRulesResult(_ref3) {\r\n        let {\r\n            values: values,\r\n            result: result\r\n        } = _ref3;\r\n        each(values, ((index, val) => {\r\n            if (false === val.isValid) {\r\n                result.isValid = val.isValid;\r\n                const rule = result.pendingRules[index];\r\n                this._addBrokenRule({\r\n                    result: result,\r\n                    rule: rule\r\n                })\r\n            }\r\n        }));\r\n        result.pendingRules = null;\r\n        result.complete = null;\r\n        result.status = result.isValid ? STATUS.valid : STATUS.invalid;\r\n        return result\r\n    },\r\n    registerValidatorInGroup(group, validator) {\r\n        const groupConfig = ValidationEngine.addGroup(group);\r\n        groupConfig.registerValidator.call(groupConfig, validator)\r\n    },\r\n    removeRegisteredValidator(group, validator) {\r\n        const config = ValidationEngine.getGroupConfig(group);\r\n        if (config) {\r\n            config.removeRegisteredValidator.call(config, validator);\r\n            const validatorsInGroup = config.validators;\r\n            const isRemovable = config._isRemovable;\r\n            const shouldRemoveGroup = 0 === validatorsInGroup.length && isRemovable;\r\n            if (shouldRemoveGroup) {\r\n                this.removeGroup(group)\r\n            }\r\n        }\r\n    },\r\n    initValidationOptions(options) {\r\n        const initedOptions = {};\r\n        if (options) {\r\n            const syncOptions = [\"isValid\", \"validationStatus\", \"validationError\", \"validationErrors\"];\r\n            syncOptions.forEach((prop => {\r\n                if (prop in options) {\r\n                    extend(initedOptions, this.synchronizeValidationOptions({\r\n                        name: prop,\r\n                        value: options[prop]\r\n                    }, options))\r\n                }\r\n            }))\r\n        }\r\n        return initedOptions\r\n    },\r\n    synchronizeValidationOptions(_ref4, options) {\r\n        let {\r\n            name: name,\r\n            value: value\r\n        } = _ref4;\r\n        switch (name) {\r\n            case \"validationStatus\": {\r\n                const isValid = value === STATUS.valid || value === STATUS.pending;\r\n                return options.isValid !== isValid ? {\r\n                    isValid: isValid\r\n                } : {}\r\n            }\r\n            case \"isValid\": {\r\n                const {\r\n                    validationStatus: validationStatus\r\n                } = options;\r\n                let newStatus = validationStatus;\r\n                if (value && validationStatus === STATUS.invalid) {\r\n                    newStatus = STATUS.valid\r\n                } else if (!value && validationStatus !== STATUS.invalid) {\r\n                    newStatus = STATUS.invalid\r\n                }\r\n                return newStatus !== validationStatus ? {\r\n                    validationStatus: newStatus\r\n                } : {}\r\n            }\r\n            case \"validationErrors\": {\r\n                const validationError = !(null !== value && void 0 !== value && value.length) ? null : value[0];\r\n                return options.validationError !== validationError ? {\r\n                    validationError: validationError\r\n                } : {}\r\n            }\r\n            case \"validationError\": {\r\n                const {\r\n                    validationErrors: validationErrors\r\n                } = options;\r\n                if (!value && validationErrors) {\r\n                    return {\r\n                        validationErrors: null\r\n                    }\r\n                }\r\n                if (value && !validationErrors) {\r\n                    return {\r\n                        validationErrors: [value]\r\n                    }\r\n                }\r\n                if (value && validationErrors && value !== validationErrors[0]) {\r\n                    validationErrors[0] = value;\r\n                    return {\r\n                        validationErrors: validationErrors.slice()\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return {}\r\n    },\r\n    validateGroup(group) {\r\n        const groupConfig = ValidationEngine.getGroupConfig(group);\r\n        if (!groupConfig) {\r\n            throw errors.Error(\"E0110\")\r\n        }\r\n        return groupConfig.validate()\r\n    },\r\n    resetGroup(group) {\r\n        const groupConfig = ValidationEngine.getGroupConfig(group);\r\n        if (!groupConfig) {\r\n            throw errors.Error(\"E0110\")\r\n        }\r\n        return groupConfig.reset()\r\n    }\r\n};\r\nValidationEngine.initGroups();\r\nexport default ValidationEngine;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}