{"ast":null,"code":"/**\r\n * DevExtreme (esm/__internal/data/m_array_query.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { errors, handleError as handleDataError } from \"../../common/data/errors\";\nimport { aggregators, isConjunctiveOperator as isConjunctiveOperatorChecker, isGroupCriterion, isUnaryOperation, isUniformEqualsByOr, normalizeBinaryCriterion } from \"../../common/data/utils\";\nimport Class from \"../../core/class\";\nimport { compileGetter, toComparable } from \"../../core/utils/data\";\nimport { Deferred } from \"../../core/utils/deferred\";\nimport { each, map } from \"../../core/utils/iterator\";\nimport { isDefined, isFunction, isString } from \"../../core/utils/type\";\nconst Iterator = Class.inherit({\n  toArray() {\n    const result = [];\n    this.reset();\n    while (this.next()) {\n      result.push(this.current());\n    }\n    return result;\n  },\n  countable: () => false\n});\nconst ArrayIterator = Iterator.inherit({\n  ctor(array) {\n    this.array = array;\n    this.index = -1;\n  },\n  next() {\n    if (this.index + 1 < this.array.length) {\n      this.index++;\n      return true;\n    }\n    return false;\n  },\n  current() {\n    return this.array[this.index];\n  },\n  reset() {\n    this.index = -1;\n  },\n  toArray() {\n    return this.array.slice(0);\n  },\n  countable: () => true,\n  count() {\n    return this.array.length;\n  }\n});\nconst WrappedIterator = Iterator.inherit({\n  ctor(iter) {\n    this.iter = iter;\n  },\n  next() {\n    return this.iter.next();\n  },\n  current() {\n    return this.iter.current();\n  },\n  reset() {\n    return this.iter.reset();\n  }\n});\nconst MapIterator = WrappedIterator.inherit({\n  ctor(iter, mapper) {\n    this.callBase(iter);\n    this.index = -1;\n    this.mapper = mapper;\n  },\n  current() {\n    return this.mapper(this.callBase(), this.index);\n  },\n  next() {\n    const hasNext = this.callBase();\n    if (hasNext) {\n      this.index++;\n    }\n    return hasNext;\n  }\n});\nconst defaultCompare = function (xValue, yValue, options) {\n  if (isString(xValue) && isString(yValue) && (null !== options && void 0 !== options && options.locale || null !== options && void 0 !== options && options.collatorOptions)) {\n    return new Intl.Collator((null === options || void 0 === options ? void 0 : options.locale) || void 0, (null === options || void 0 === options ? void 0 : options.collatorOptions) || void 0).compare(xValue, yValue);\n  }\n  xValue = toComparable(xValue, false, options);\n  yValue = toComparable(yValue, false, options);\n  if (null === xValue && null !== yValue) {\n    return -1;\n  }\n  if (null !== xValue && null === yValue) {\n    return 1;\n  }\n  if (void 0 === xValue && void 0 !== yValue) {\n    return 1;\n  }\n  if (void 0 !== xValue && void 0 === yValue) {\n    return -1;\n  }\n  if (xValue < yValue) {\n    return -1;\n  }\n  if (xValue > yValue) {\n    return 1;\n  }\n  return 0;\n};\nconst SortIterator = Iterator.inherit({\n  ctor(iter, getter, desc, compare) {\n    this.langParams = iter.langParams;\n    if (!(iter instanceof MapIterator)) {\n      iter = new MapIterator(iter, this._wrap);\n      iter.langParams = this.langParams;\n    }\n    this.iter = iter;\n    this.rules = [{\n      getter: getter,\n      desc: desc,\n      compare: compare,\n      langParams: this.langParams\n    }];\n  },\n  thenBy(getter, desc, compare) {\n    const result = new SortIterator(this.sortedIter || this.iter, getter, desc, compare);\n    if (!this.sortedIter) {\n      result.rules = this.rules.concat(result.rules);\n    }\n    return result;\n  },\n  next() {\n    this._ensureSorted();\n    return this.sortedIter.next();\n  },\n  current() {\n    this._ensureSorted();\n    return this.sortedIter.current();\n  },\n  reset() {\n    delete this.sortedIter;\n  },\n  countable() {\n    return this.sortedIter || this.iter.countable();\n  },\n  count() {\n    if (this.sortedIter) {\n      return this.sortedIter.count();\n    }\n    return this.iter.count();\n  },\n  _ensureSorted() {\n    const that = this;\n    if (that.sortedIter) {\n      return;\n    }\n    each(that.rules, function () {\n      this.getter = compileGetter(this.getter);\n    });\n    that.sortedIter = new MapIterator(new ArrayIterator(this.iter.toArray().sort((x, y) => that._compare(x, y))), that._unwrap);\n  },\n  _wrap: (record, index) => ({\n    index: index,\n    value: record\n  }),\n  _unwrap: wrappedItem => wrappedItem.value,\n  _getDefaultCompare: langParams => (xValue, yValue) => defaultCompare(xValue, yValue, langParams),\n  _compare(x, y) {\n    const xIndex = x.index;\n    const yIndex = y.index;\n    x = x.value;\n    y = y.value;\n    if (x === y) {\n      return xIndex - yIndex;\n    }\n    for (let i = 0, rulesCount = this.rules.length; i < rulesCount; i++) {\n      const rule = this.rules[i];\n      const xValue = rule.getter(x);\n      const yValue = rule.getter(y);\n      const compare = rule.compare || this._getDefaultCompare(rule.langParams);\n      const compareResult = compare(xValue, yValue);\n      if (compareResult) {\n        return rule.desc ? -compareResult : compareResult;\n      }\n    }\n    return xIndex - yIndex;\n  }\n});\nconst compileCriteria = function () {\n  let langParams = {};\n  const _toComparable = value => toComparable(value, false, langParams);\n  const compileGroup = function (crit) {\n    if (isUniformEqualsByOr(crit)) {\n      return (crit => {\n        const getter = compileGetter(crit[0][0]);\n        const filterValues = crit.reduce((acc, item, i) => {\n          if (i % 2 === 0) {\n            acc.push(_toComparable(item[2]));\n          }\n          return acc;\n        }, []);\n        return obj => {\n          const value = _toComparable(getter(obj));\n          return filterValues.some(filterValue => useStrictComparison(filterValue) ? value === filterValue : value == filterValue);\n        };\n      })(crit);\n    }\n    const ops = [];\n    let isConjunctiveOperator = false;\n    let isConjunctiveNextOperator = false;\n    each(crit, function () {\n      if (Array.isArray(this) || isFunction(this)) {\n        if (ops.length > 1 && isConjunctiveOperator !== isConjunctiveNextOperator) {\n          throw errors.Error(\"E4019\");\n        }\n        ops.push(compileCriteria(this, langParams));\n        isConjunctiveOperator = isConjunctiveNextOperator;\n        isConjunctiveNextOperator = true;\n      } else {\n        isConjunctiveNextOperator = isConjunctiveOperatorChecker(this);\n      }\n    });\n    return function (d) {\n      let result = isConjunctiveOperator;\n      for (let i = 0; i < ops.length; i++) {\n        if (ops[i](d) !== isConjunctiveOperator) {\n          result = !isConjunctiveOperator;\n          break;\n        }\n      }\n      return result;\n    };\n  };\n  const toString = function (value) {\n    var _langParams;\n    return isDefined(value) ? null !== (_langParams = langParams) && void 0 !== _langParams && _langParams.locale ? value.toLocaleString(langParams.locale) : value.toString() : \"\";\n  };\n  function compileEquals(getter, value, negate) {\n    return function (obj) {\n      obj = _toComparable(getter(obj));\n      let result = useStrictComparison(value) ? obj === value : obj == value;\n      if (negate) {\n        result = !result;\n      }\n      return result;\n    };\n  }\n  function useStrictComparison(value) {\n    return \"\" === value || 0 === value || false === value;\n  }\n  return function (crit, options) {\n    langParams = options || {};\n    if (isFunction(crit)) {\n      return crit;\n    }\n    if (isGroupCriterion(crit)) {\n      return compileGroup(crit);\n    }\n    if (isUnaryOperation(crit)) {\n      return function (crit) {\n        const op = crit[0];\n        const criteria = compileCriteria(crit[1], langParams);\n        if (\"!\" === op) {\n          return function (obj) {\n            return !criteria(obj);\n          };\n        }\n        throw errors.Error(\"E4003\", op);\n      }(crit);\n    }\n    return function (crit) {\n      crit = normalizeBinaryCriterion(crit);\n      const getter = compileGetter(crit[0]);\n      const op = crit[1];\n      let value = crit[2];\n      value = _toComparable(value);\n      const compare = (obj, operatorFn) => {\n        obj = _toComparable(getter(obj));\n        return (null == value || null == obj) && value !== obj ? false : operatorFn(obj, value);\n      };\n      switch (op.toLowerCase()) {\n        case \"=\":\n          return compileEquals(getter, value);\n        case \"<>\":\n          return compileEquals(getter, value, true);\n        case \">\":\n          return obj => compare(obj, (a, b) => a > b);\n        case \"<\":\n          return obj => compare(obj, (a, b) => a < b);\n        case \">=\":\n          return obj => compare(obj, (a, b) => a >= b);\n        case \"<=\":\n          return obj => compare(obj, (a, b) => a <= b);\n        case \"startswith\":\n          return obj => _toComparable(toString(getter(obj))).startsWith(value);\n        case \"endswith\":\n          return obj => _toComparable(toString(getter(obj))).endsWith(value);\n        case \"contains\":\n          return obj => _toComparable(toString(getter(obj))).includes(value);\n        case \"notcontains\":\n          return obj => !_toComparable(toString(getter(obj))).includes(value);\n      }\n      throw errors.Error(\"E4003\", op);\n    }(crit);\n  };\n}();\nconst FilterIterator = WrappedIterator.inherit({\n  ctor(iter, criteria) {\n    this.callBase(iter);\n    this.langParams = iter.langParams;\n    this.criteria = compileCriteria(criteria, this.langParams);\n  },\n  next() {\n    while (this.iter.next()) {\n      if (this.criteria(this.current())) {\n        return true;\n      }\n    }\n    return false;\n  }\n});\nconst GroupIterator = Iterator.inherit({\n  ctor(iter, getter) {\n    this.iter = iter;\n    this.getter = getter;\n  },\n  next() {\n    this._ensureGrouped();\n    return this.groupedIter.next();\n  },\n  current() {\n    this._ensureGrouped();\n    return this.groupedIter.current();\n  },\n  reset() {\n    delete this.groupedIter;\n  },\n  countable() {\n    return !!this.groupedIter;\n  },\n  count() {\n    return this.groupedIter.count();\n  },\n  _ensureGrouped() {\n    if (this.groupedIter) {\n      return;\n    }\n    const hash = {};\n    const keys = [];\n    const {\n      iter: iter\n    } = this;\n    const getter = compileGetter(this.getter);\n    iter.reset();\n    while (iter.next()) {\n      const current = iter.current();\n      const key = getter(current);\n      if (key in hash) {\n        hash[key].push(current);\n      } else {\n        hash[key] = [current];\n        keys.push(key);\n      }\n    }\n    this.groupedIter = new ArrayIterator(map(keys, key => ({\n      key: key,\n      items: hash[key]\n    })));\n  }\n});\nconst SelectIterator = WrappedIterator.inherit({\n  ctor(iter, getter) {\n    this.callBase(iter);\n    this.getter = compileGetter(getter);\n  },\n  current() {\n    return this.getter(this.callBase());\n  },\n  countable() {\n    return this.iter.countable();\n  },\n  count() {\n    return this.iter.count();\n  }\n});\nconst SliceIterator = WrappedIterator.inherit({\n  ctor(iter, skip, take) {\n    this.callBase(iter);\n    this.skip = Math.max(0, skip);\n    this.take = Math.max(0, take);\n    this.pos = 0;\n  },\n  next() {\n    if (this.pos >= this.skip + this.take) {\n      return false;\n    }\n    while (this.pos < this.skip && this.iter.next()) {\n      this.pos++;\n    }\n    this.pos++;\n    return this.iter.next();\n  },\n  reset() {\n    this.callBase();\n    this.pos = 0;\n  },\n  countable() {\n    return this.iter.countable();\n  },\n  count() {\n    return Math.min(this.iter.count() - this.skip, this.take);\n  }\n});\nconst arrayQueryImpl = function (iter, queryOptions) {\n  queryOptions = queryOptions || {};\n  if (!(iter instanceof Iterator)) {\n    iter = new ArrayIterator(iter);\n  }\n  if (queryOptions.langParams) {\n    iter.langParams = queryOptions.langParams;\n  }\n  const handleError = function (error) {\n    const handler = queryOptions.errorHandler;\n    if (handler) {\n      handler(error);\n    }\n    handleDataError(error);\n  };\n  const aggregateCore = function (aggregator) {\n    const d = new Deferred().fail(handleError);\n    let seed;\n    const {\n      step: step\n    } = aggregator;\n    const {\n      finalize: finalize\n    } = aggregator;\n    try {\n      iter.reset();\n      if (\"seed\" in aggregator) {\n        seed = aggregator.seed;\n      } else {\n        seed = iter.next() ? iter.current() : NaN;\n      }\n      let accumulator = seed;\n      while (iter.next()) {\n        accumulator = step(accumulator, iter.current());\n      }\n      d.resolve(finalize ? finalize(accumulator) : accumulator);\n    } catch (x) {\n      d.reject(x);\n    }\n    return d.promise();\n  };\n  const standardAggregate = function (name) {\n    return aggregateCore(aggregators[name]);\n  };\n  const select = function (getter) {\n    if (!isFunction(getter) && !Array.isArray(getter)) {\n      getter = [].slice.call(arguments);\n    }\n    return chainQuery(new SelectIterator(iter, getter));\n  };\n  const selectProp = function (name) {\n    return select(compileGetter(name));\n  };\n  function chainQuery(iter) {\n    return arrayQueryImpl(iter, queryOptions);\n  }\n  return {\n    toArray: () => iter.toArray(),\n    enumerate() {\n      const d = new Deferred().fail(handleError);\n      try {\n        d.resolve(iter.toArray());\n      } catch (x) {\n        d.reject(x);\n      }\n      return d.promise();\n    },\n    setLangParams(options) {\n      iter.langParams = options;\n    },\n    sortBy: (getter, desc, compare) => chainQuery(new SortIterator(iter, getter, desc, compare)),\n    thenBy(getter, desc, compare) {\n      if (iter instanceof SortIterator) {\n        return chainQuery(iter.thenBy(getter, desc, compare));\n      }\n      throw errors.Error(\"E4004\");\n    },\n    filter(criteria) {\n      if (!Array.isArray(criteria)) {\n        criteria = [].slice.call(arguments);\n      }\n      return chainQuery(new FilterIterator(iter, criteria));\n    },\n    slice(skip, take) {\n      if (void 0 === take) {\n        take = Number.MAX_VALUE;\n      }\n      return chainQuery(new SliceIterator(iter, skip, take));\n    },\n    select: select,\n    groupBy: getter => chainQuery(new GroupIterator(iter, getter)),\n    aggregate: function (seed, step, finalize) {\n      if (arguments.length < 2) {\n        return aggregateCore({\n          step: arguments[0]\n        });\n      }\n      return aggregateCore({\n        seed: seed,\n        step: step,\n        finalize: finalize\n      });\n    },\n    count() {\n      if (iter.countable()) {\n        const d = new Deferred().fail(handleError);\n        try {\n          d.resolve(iter.count());\n        } catch (x) {\n          d.reject(x);\n        }\n        return d.promise();\n      }\n      return standardAggregate(\"count\");\n    },\n    sum(getter) {\n      if (getter) {\n        return selectProp(getter).sum();\n      }\n      return standardAggregate(\"sum\");\n    },\n    min(getter) {\n      if (getter) {\n        return selectProp(getter).min();\n      }\n      return standardAggregate(\"min\");\n    },\n    max(getter) {\n      if (getter) {\n        return selectProp(getter).max();\n      }\n      return standardAggregate(\"max\");\n    },\n    avg(getter) {\n      if (getter) {\n        return selectProp(getter).avg();\n      }\n      return standardAggregate(\"avg\");\n    }\n  };\n};\nexport default arrayQueryImpl;","map":{"version":3,"names":["errors","handleError","handleDataError","aggregators","isConjunctiveOperator","isConjunctiveOperatorChecker","isGroupCriterion","isUnaryOperation","isUniformEqualsByOr","normalizeBinaryCriterion","Class","compileGetter","toComparable","Deferred","each","map","isDefined","isFunction","isString","Iterator","inherit","toArray","result","reset","next","push","current","countable","ArrayIterator","ctor","array","index","length","slice","count","WrappedIterator","iter","MapIterator","mapper","callBase","hasNext","defaultCompare","xValue","yValue","options","locale","collatorOptions","Intl","Collator","compare","SortIterator","getter","desc","langParams","_wrap","rules","thenBy","sortedIter","concat","_ensureSorted","that","sort","x","y","_compare","_unwrap","record","value","wrappedItem","_getDefaultCompare","xIndex","yIndex","i","rulesCount","rule","compareResult","compileCriteria","_toComparable","compileGroup","crit","filterValues","reduce","acc","item","obj","some","filterValue","useStrictComparison","ops","isConjunctiveNextOperator","Array","isArray","Error","d","toString","_langParams","toLocaleString","compileEquals","negate","op","criteria","operatorFn","toLowerCase","a","b","startsWith","endsWith","includes","FilterIterator","GroupIterator","_ensureGrouped","groupedIter","hash","keys","key","items","SelectIterator","SliceIterator","skip","take","Math","max","pos","min","arrayQueryImpl","queryOptions","error","handler","errorHandler","aggregateCore","aggregator","fail","seed","step","finalize","NaN","accumulator","resolve","reject","promise","standardAggregate","name","select","call","arguments","chainQuery","selectProp","enumerate","setLangParams","sortBy","filter","Number","MAX_VALUE","groupBy","aggregate","sum","avg"],"sources":["/home/nataf/Cours/world-cities-map/client/node_modules/devextreme/esm/__internal/data/m_array_query.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/__internal/data/m_array_query.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    errors,\r\n    handleError as handleDataError\r\n} from \"../../common/data/errors\";\r\nimport {\r\n    aggregators,\r\n    isConjunctiveOperator as isConjunctiveOperatorChecker,\r\n    isGroupCriterion,\r\n    isUnaryOperation,\r\n    isUniformEqualsByOr,\r\n    normalizeBinaryCriterion\r\n} from \"../../common/data/utils\";\r\nimport Class from \"../../core/class\";\r\nimport {\r\n    compileGetter,\r\n    toComparable\r\n} from \"../../core/utils/data\";\r\nimport {\r\n    Deferred\r\n} from \"../../core/utils/deferred\";\r\nimport {\r\n    each,\r\n    map\r\n} from \"../../core/utils/iterator\";\r\nimport {\r\n    isDefined,\r\n    isFunction,\r\n    isString\r\n} from \"../../core/utils/type\";\r\nconst Iterator = Class.inherit({\r\n    toArray() {\r\n        const result = [];\r\n        this.reset();\r\n        while (this.next()) {\r\n            result.push(this.current())\r\n        }\r\n        return result\r\n    },\r\n    countable: () => false\r\n});\r\nconst ArrayIterator = Iterator.inherit({\r\n    ctor(array) {\r\n        this.array = array;\r\n        this.index = -1\r\n    },\r\n    next() {\r\n        if (this.index + 1 < this.array.length) {\r\n            this.index++;\r\n            return true\r\n        }\r\n        return false\r\n    },\r\n    current() {\r\n        return this.array[this.index]\r\n    },\r\n    reset() {\r\n        this.index = -1\r\n    },\r\n    toArray() {\r\n        return this.array.slice(0)\r\n    },\r\n    countable: () => true,\r\n    count() {\r\n        return this.array.length\r\n    }\r\n});\r\nconst WrappedIterator = Iterator.inherit({\r\n    ctor(iter) {\r\n        this.iter = iter\r\n    },\r\n    next() {\r\n        return this.iter.next()\r\n    },\r\n    current() {\r\n        return this.iter.current()\r\n    },\r\n    reset() {\r\n        return this.iter.reset()\r\n    }\r\n});\r\nconst MapIterator = WrappedIterator.inherit({\r\n    ctor(iter, mapper) {\r\n        this.callBase(iter);\r\n        this.index = -1;\r\n        this.mapper = mapper\r\n    },\r\n    current() {\r\n        return this.mapper(this.callBase(), this.index)\r\n    },\r\n    next() {\r\n        const hasNext = this.callBase();\r\n        if (hasNext) {\r\n            this.index++\r\n        }\r\n        return hasNext\r\n    }\r\n});\r\nconst defaultCompare = function(xValue, yValue, options) {\r\n    if (isString(xValue) && isString(yValue) && (null !== options && void 0 !== options && options.locale || null !== options && void 0 !== options && options.collatorOptions)) {\r\n        return new Intl.Collator((null === options || void 0 === options ? void 0 : options.locale) || void 0, (null === options || void 0 === options ? void 0 : options.collatorOptions) || void 0).compare(xValue, yValue)\r\n    }\r\n    xValue = toComparable(xValue, false, options);\r\n    yValue = toComparable(yValue, false, options);\r\n    if (null === xValue && null !== yValue) {\r\n        return -1\r\n    }\r\n    if (null !== xValue && null === yValue) {\r\n        return 1\r\n    }\r\n    if (void 0 === xValue && void 0 !== yValue) {\r\n        return 1\r\n    }\r\n    if (void 0 !== xValue && void 0 === yValue) {\r\n        return -1\r\n    }\r\n    if (xValue < yValue) {\r\n        return -1\r\n    }\r\n    if (xValue > yValue) {\r\n        return 1\r\n    }\r\n    return 0\r\n};\r\nconst SortIterator = Iterator.inherit({\r\n    ctor(iter, getter, desc, compare) {\r\n        this.langParams = iter.langParams;\r\n        if (!(iter instanceof MapIterator)) {\r\n            iter = new MapIterator(iter, this._wrap);\r\n            iter.langParams = this.langParams\r\n        }\r\n        this.iter = iter;\r\n        this.rules = [{\r\n            getter: getter,\r\n            desc: desc,\r\n            compare: compare,\r\n            langParams: this.langParams\r\n        }]\r\n    },\r\n    thenBy(getter, desc, compare) {\r\n        const result = new SortIterator(this.sortedIter || this.iter, getter, desc, compare);\r\n        if (!this.sortedIter) {\r\n            result.rules = this.rules.concat(result.rules)\r\n        }\r\n        return result\r\n    },\r\n    next() {\r\n        this._ensureSorted();\r\n        return this.sortedIter.next()\r\n    },\r\n    current() {\r\n        this._ensureSorted();\r\n        return this.sortedIter.current()\r\n    },\r\n    reset() {\r\n        delete this.sortedIter\r\n    },\r\n    countable() {\r\n        return this.sortedIter || this.iter.countable()\r\n    },\r\n    count() {\r\n        if (this.sortedIter) {\r\n            return this.sortedIter.count()\r\n        }\r\n        return this.iter.count()\r\n    },\r\n    _ensureSorted() {\r\n        const that = this;\r\n        if (that.sortedIter) {\r\n            return\r\n        }\r\n        each(that.rules, (function() {\r\n            this.getter = compileGetter(this.getter)\r\n        }));\r\n        that.sortedIter = new MapIterator(new ArrayIterator(this.iter.toArray().sort(((x, y) => that._compare(x, y)))), that._unwrap)\r\n    },\r\n    _wrap: (record, index) => ({\r\n        index: index,\r\n        value: record\r\n    }),\r\n    _unwrap: wrappedItem => wrappedItem.value,\r\n    _getDefaultCompare: langParams => (xValue, yValue) => defaultCompare(xValue, yValue, langParams),\r\n    _compare(x, y) {\r\n        const xIndex = x.index;\r\n        const yIndex = y.index;\r\n        x = x.value;\r\n        y = y.value;\r\n        if (x === y) {\r\n            return xIndex - yIndex\r\n        }\r\n        for (let i = 0, rulesCount = this.rules.length; i < rulesCount; i++) {\r\n            const rule = this.rules[i];\r\n            const xValue = rule.getter(x);\r\n            const yValue = rule.getter(y);\r\n            const compare = rule.compare || this._getDefaultCompare(rule.langParams);\r\n            const compareResult = compare(xValue, yValue);\r\n            if (compareResult) {\r\n                return rule.desc ? -compareResult : compareResult\r\n            }\r\n        }\r\n        return xIndex - yIndex\r\n    }\r\n});\r\nconst compileCriteria = function() {\r\n    let langParams = {};\r\n    const _toComparable = value => toComparable(value, false, langParams);\r\n    const compileGroup = function(crit) {\r\n        if (isUniformEqualsByOr(crit)) {\r\n            return (crit => {\r\n                const getter = compileGetter(crit[0][0]);\r\n                const filterValues = crit.reduce(((acc, item, i) => {\r\n                    if (i % 2 === 0) {\r\n                        acc.push(_toComparable(item[2]))\r\n                    }\r\n                    return acc\r\n                }), []);\r\n                return obj => {\r\n                    const value = _toComparable(getter(obj));\r\n                    return filterValues.some((filterValue => useStrictComparison(filterValue) ? value === filterValue : value == filterValue))\r\n                }\r\n            })(crit)\r\n        }\r\n        const ops = [];\r\n        let isConjunctiveOperator = false;\r\n        let isConjunctiveNextOperator = false;\r\n        each(crit, (function() {\r\n            if (Array.isArray(this) || isFunction(this)) {\r\n                if (ops.length > 1 && isConjunctiveOperator !== isConjunctiveNextOperator) {\r\n                    throw errors.Error(\"E4019\")\r\n                }\r\n                ops.push(compileCriteria(this, langParams));\r\n                isConjunctiveOperator = isConjunctiveNextOperator;\r\n                isConjunctiveNextOperator = true\r\n            } else {\r\n                isConjunctiveNextOperator = isConjunctiveOperatorChecker(this)\r\n            }\r\n        }));\r\n        return function(d) {\r\n            let result = isConjunctiveOperator;\r\n            for (let i = 0; i < ops.length; i++) {\r\n                if (ops[i](d) !== isConjunctiveOperator) {\r\n                    result = !isConjunctiveOperator;\r\n                    break\r\n                }\r\n            }\r\n            return result\r\n        }\r\n    };\r\n    const toString = function(value) {\r\n        var _langParams;\r\n        return isDefined(value) ? null !== (_langParams = langParams) && void 0 !== _langParams && _langParams.locale ? value.toLocaleString(langParams.locale) : value.toString() : \"\"\r\n    };\r\n\r\n    function compileEquals(getter, value, negate) {\r\n        return function(obj) {\r\n            obj = _toComparable(getter(obj));\r\n            let result = useStrictComparison(value) ? obj === value : obj == value;\r\n            if (negate) {\r\n                result = !result\r\n            }\r\n            return result\r\n        }\r\n    }\r\n\r\n    function useStrictComparison(value) {\r\n        return \"\" === value || 0 === value || false === value\r\n    }\r\n    return function(crit, options) {\r\n        langParams = options || {};\r\n        if (isFunction(crit)) {\r\n            return crit\r\n        }\r\n        if (isGroupCriterion(crit)) {\r\n            return compileGroup(crit)\r\n        }\r\n        if (isUnaryOperation(crit)) {\r\n            return function(crit) {\r\n                const op = crit[0];\r\n                const criteria = compileCriteria(crit[1], langParams);\r\n                if (\"!\" === op) {\r\n                    return function(obj) {\r\n                        return !criteria(obj)\r\n                    }\r\n                }\r\n                throw errors.Error(\"E4003\", op)\r\n            }(crit)\r\n        }\r\n        return function(crit) {\r\n            crit = normalizeBinaryCriterion(crit);\r\n            const getter = compileGetter(crit[0]);\r\n            const op = crit[1];\r\n            let value = crit[2];\r\n            value = _toComparable(value);\r\n            const compare = (obj, operatorFn) => {\r\n                obj = _toComparable(getter(obj));\r\n                return (null == value || null == obj) && value !== obj ? false : operatorFn(obj, value)\r\n            };\r\n            switch (op.toLowerCase()) {\r\n                case \"=\":\r\n                    return compileEquals(getter, value);\r\n                case \"<>\":\r\n                    return compileEquals(getter, value, true);\r\n                case \">\":\r\n                    return obj => compare(obj, ((a, b) => a > b));\r\n                case \"<\":\r\n                    return obj => compare(obj, ((a, b) => a < b));\r\n                case \">=\":\r\n                    return obj => compare(obj, ((a, b) => a >= b));\r\n                case \"<=\":\r\n                    return obj => compare(obj, ((a, b) => a <= b));\r\n                case \"startswith\":\r\n                    return obj => _toComparable(toString(getter(obj))).startsWith(value);\r\n                case \"endswith\":\r\n                    return obj => _toComparable(toString(getter(obj))).endsWith(value);\r\n                case \"contains\":\r\n                    return obj => _toComparable(toString(getter(obj))).includes(value);\r\n                case \"notcontains\":\r\n                    return obj => !_toComparable(toString(getter(obj))).includes(value)\r\n            }\r\n            throw errors.Error(\"E4003\", op)\r\n        }(crit)\r\n    }\r\n}();\r\nconst FilterIterator = WrappedIterator.inherit({\r\n    ctor(iter, criteria) {\r\n        this.callBase(iter);\r\n        this.langParams = iter.langParams;\r\n        this.criteria = compileCriteria(criteria, this.langParams)\r\n    },\r\n    next() {\r\n        while (this.iter.next()) {\r\n            if (this.criteria(this.current())) {\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n});\r\nconst GroupIterator = Iterator.inherit({\r\n    ctor(iter, getter) {\r\n        this.iter = iter;\r\n        this.getter = getter\r\n    },\r\n    next() {\r\n        this._ensureGrouped();\r\n        return this.groupedIter.next()\r\n    },\r\n    current() {\r\n        this._ensureGrouped();\r\n        return this.groupedIter.current()\r\n    },\r\n    reset() {\r\n        delete this.groupedIter\r\n    },\r\n    countable() {\r\n        return !!this.groupedIter\r\n    },\r\n    count() {\r\n        return this.groupedIter.count()\r\n    },\r\n    _ensureGrouped() {\r\n        if (this.groupedIter) {\r\n            return\r\n        }\r\n        const hash = {};\r\n        const keys = [];\r\n        const {\r\n            iter: iter\r\n        } = this;\r\n        const getter = compileGetter(this.getter);\r\n        iter.reset();\r\n        while (iter.next()) {\r\n            const current = iter.current();\r\n            const key = getter(current);\r\n            if (key in hash) {\r\n                hash[key].push(current)\r\n            } else {\r\n                hash[key] = [current];\r\n                keys.push(key)\r\n            }\r\n        }\r\n        this.groupedIter = new ArrayIterator(map(keys, (key => ({\r\n            key: key,\r\n            items: hash[key]\r\n        }))))\r\n    }\r\n});\r\nconst SelectIterator = WrappedIterator.inherit({\r\n    ctor(iter, getter) {\r\n        this.callBase(iter);\r\n        this.getter = compileGetter(getter)\r\n    },\r\n    current() {\r\n        return this.getter(this.callBase())\r\n    },\r\n    countable() {\r\n        return this.iter.countable()\r\n    },\r\n    count() {\r\n        return this.iter.count()\r\n    }\r\n});\r\nconst SliceIterator = WrappedIterator.inherit({\r\n    ctor(iter, skip, take) {\r\n        this.callBase(iter);\r\n        this.skip = Math.max(0, skip);\r\n        this.take = Math.max(0, take);\r\n        this.pos = 0\r\n    },\r\n    next() {\r\n        if (this.pos >= this.skip + this.take) {\r\n            return false\r\n        }\r\n        while (this.pos < this.skip && this.iter.next()) {\r\n            this.pos++\r\n        }\r\n        this.pos++;\r\n        return this.iter.next()\r\n    },\r\n    reset() {\r\n        this.callBase();\r\n        this.pos = 0\r\n    },\r\n    countable() {\r\n        return this.iter.countable()\r\n    },\r\n    count() {\r\n        return Math.min(this.iter.count() - this.skip, this.take)\r\n    }\r\n});\r\nconst arrayQueryImpl = function(iter, queryOptions) {\r\n    queryOptions = queryOptions || {};\r\n    if (!(iter instanceof Iterator)) {\r\n        iter = new ArrayIterator(iter)\r\n    }\r\n    if (queryOptions.langParams) {\r\n        iter.langParams = queryOptions.langParams\r\n    }\r\n    const handleError = function(error) {\r\n        const handler = queryOptions.errorHandler;\r\n        if (handler) {\r\n            handler(error)\r\n        }\r\n        handleDataError(error)\r\n    };\r\n    const aggregateCore = function(aggregator) {\r\n        const d = (new Deferred).fail(handleError);\r\n        let seed;\r\n        const {\r\n            step: step\r\n        } = aggregator;\r\n        const {\r\n            finalize: finalize\r\n        } = aggregator;\r\n        try {\r\n            iter.reset();\r\n            if (\"seed\" in aggregator) {\r\n                seed = aggregator.seed\r\n            } else {\r\n                seed = iter.next() ? iter.current() : NaN\r\n            }\r\n            let accumulator = seed;\r\n            while (iter.next()) {\r\n                accumulator = step(accumulator, iter.current())\r\n            }\r\n            d.resolve(finalize ? finalize(accumulator) : accumulator)\r\n        } catch (x) {\r\n            d.reject(x)\r\n        }\r\n        return d.promise()\r\n    };\r\n    const standardAggregate = function(name) {\r\n        return aggregateCore(aggregators[name])\r\n    };\r\n    const select = function(getter) {\r\n        if (!isFunction(getter) && !Array.isArray(getter)) {\r\n            getter = [].slice.call(arguments)\r\n        }\r\n        return chainQuery(new SelectIterator(iter, getter))\r\n    };\r\n    const selectProp = function(name) {\r\n        return select(compileGetter(name))\r\n    };\r\n\r\n    function chainQuery(iter) {\r\n        return arrayQueryImpl(iter, queryOptions)\r\n    }\r\n    return {\r\n        toArray: () => iter.toArray(),\r\n        enumerate() {\r\n            const d = (new Deferred).fail(handleError);\r\n            try {\r\n                d.resolve(iter.toArray())\r\n            } catch (x) {\r\n                d.reject(x)\r\n            }\r\n            return d.promise()\r\n        },\r\n        setLangParams(options) {\r\n            iter.langParams = options\r\n        },\r\n        sortBy: (getter, desc, compare) => chainQuery(new SortIterator(iter, getter, desc, compare)),\r\n        thenBy(getter, desc, compare) {\r\n            if (iter instanceof SortIterator) {\r\n                return chainQuery(iter.thenBy(getter, desc, compare))\r\n            }\r\n            throw errors.Error(\"E4004\")\r\n        },\r\n        filter(criteria) {\r\n            if (!Array.isArray(criteria)) {\r\n                criteria = [].slice.call(arguments)\r\n            }\r\n            return chainQuery(new FilterIterator(iter, criteria))\r\n        },\r\n        slice(skip, take) {\r\n            if (void 0 === take) {\r\n                take = Number.MAX_VALUE\r\n            }\r\n            return chainQuery(new SliceIterator(iter, skip, take))\r\n        },\r\n        select: select,\r\n        groupBy: getter => chainQuery(new GroupIterator(iter, getter)),\r\n        aggregate: function(seed, step, finalize) {\r\n            if (arguments.length < 2) {\r\n                return aggregateCore({\r\n                    step: arguments[0]\r\n                })\r\n            }\r\n            return aggregateCore({\r\n                seed: seed,\r\n                step: step,\r\n                finalize: finalize\r\n            })\r\n        },\r\n        count() {\r\n            if (iter.countable()) {\r\n                const d = (new Deferred).fail(handleError);\r\n                try {\r\n                    d.resolve(iter.count())\r\n                } catch (x) {\r\n                    d.reject(x)\r\n                }\r\n                return d.promise()\r\n            }\r\n            return standardAggregate(\"count\")\r\n        },\r\n        sum(getter) {\r\n            if (getter) {\r\n                return selectProp(getter).sum()\r\n            }\r\n            return standardAggregate(\"sum\")\r\n        },\r\n        min(getter) {\r\n            if (getter) {\r\n                return selectProp(getter).min()\r\n            }\r\n            return standardAggregate(\"min\")\r\n        },\r\n        max(getter) {\r\n            if (getter) {\r\n                return selectProp(getter).max()\r\n            }\r\n            return standardAggregate(\"max\")\r\n        },\r\n        avg(getter) {\r\n            if (getter) {\r\n                return selectProp(getter).avg()\r\n            }\r\n            return standardAggregate(\"avg\")\r\n        }\r\n    }\r\n};\r\nexport default arrayQueryImpl;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}