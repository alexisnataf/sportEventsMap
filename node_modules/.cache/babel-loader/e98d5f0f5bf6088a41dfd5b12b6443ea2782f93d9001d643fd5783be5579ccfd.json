{"ast":null,"code":"/**\r\n * DevExtreme (esm/__internal/core/utils/m_data.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport Class from \"../../../core/class\";\nimport errors from \"../../../core/errors\";\nimport { each } from \"../../../core/utils/iterator\";\nimport { deepExtendArraySafe } from \"../../../core/utils/object\";\nimport { isDefined, isFunction, isObject, isPlainObject } from \"../../../core/utils/type\";\nimport variableWrapper from \"../../../core/utils/variable_wrapper\";\nconst unwrapVariable = variableWrapper.unwrap;\nconst {\n  isWrapped: isWrapped\n} = variableWrapper;\nconst {\n  assign: assign\n} = variableWrapper;\nconst bracketsToDots = function (expr) {\n  return expr.replace(/\\[/g, \".\").replace(/\\]/g, \"\");\n};\nexport const getPathParts = function (name) {\n  return bracketsToDots(name).split(\".\");\n};\nconst readPropValue = function (obj, propName, options) {\n  options = options || {};\n  if (\"this\" === propName) {\n    return unwrap(obj, options);\n  }\n  return unwrap(obj[propName], options);\n};\nconst assignPropValue = function (obj, propName, value, options) {\n  if (\"this\" === propName) {\n    throw new errors.Error(\"E4016\");\n  }\n  const propValue = obj[propName];\n  if (options.unwrapObservables && isWrapped(propValue)) {\n    assign(propValue, value);\n  } else {\n    obj[propName] = value;\n  }\n};\nconst prepareOptions = function (options) {\n  options = options || {};\n  options.unwrapObservables = void 0 !== options.unwrapObservables ? options.unwrapObservables : true;\n  return options;\n};\nfunction unwrap(value, options) {\n  return options.unwrapObservables ? unwrapVariable(value) : value;\n}\nexport const compileGetter = function (expr) {\n  if (arguments.length > 1) {\n    expr = [].slice.call(arguments);\n  }\n  if (!expr || \"this\" === expr) {\n    return function (obj) {\n      return obj;\n    };\n  }\n  if (\"string\" === typeof expr) {\n    const path = getPathParts(expr);\n    return function (obj, options) {\n      options = prepareOptions(options);\n      const functionAsIs = options.functionsAsIs;\n      const hasDefaultValue = \"defaultValue\" in options;\n      let current = unwrap(obj, options);\n      for (let i = 0; i < path.length; i++) {\n        if (!current) {\n          if (null == current && hasDefaultValue) {\n            return options.defaultValue;\n          }\n          break;\n        }\n        const pathPart = path[i];\n        if (hasDefaultValue && isObject(current) && !(pathPart in current)) {\n          return options.defaultValue;\n        }\n        let next = unwrap(current[pathPart], options);\n        if (!functionAsIs && isFunction(next)) {\n          next = next.call(current);\n        }\n        current = next;\n      }\n      return current;\n    };\n  }\n  if (Array.isArray(expr)) {\n    return combineGetters(expr);\n  }\n  if (isFunction(expr)) {\n    return expr;\n  }\n};\nfunction combineGetters(getters) {\n  const compiledGetters = {};\n  for (let i = 0, l = getters.length; i < l; i++) {\n    const getter = getters[i];\n    compiledGetters[getter] = compileGetter(getter);\n  }\n  return function (obj, options) {\n    let result;\n    each(compiledGetters, function (name) {\n      const value = this(obj, options);\n      if (void 0 === value) {\n        return;\n      }\n      let current = result || (result = {});\n      const path = name.split(\".\");\n      const last = path.length - 1;\n      for (let i = 0; i < last; i++) {\n        const pathItem = path[i];\n        if (!(pathItem in current)) {\n          current[pathItem] = {};\n        }\n        current = current[pathItem];\n      }\n      current[path[last]] = value;\n    });\n    return result;\n  };\n}\nfunction toLowerCase(value, options) {\n  return null !== options && void 0 !== options && options.locale ? value.toLocaleLowerCase(options.locale) : value.toLowerCase();\n}\nfunction toUpperCase(value, options) {\n  return null !== options && void 0 !== options && options.locale ? value.toLocaleUpperCase(options.locale) : value.toUpperCase();\n}\nconst ensurePropValueDefined = function (obj, propName, value, options) {\n  if (isDefined(value)) {\n    return value;\n  }\n  const newValue = {};\n  assignPropValue(obj, propName, newValue, options);\n  return newValue;\n};\nexport const compileSetter = function (expr) {\n  expr = getPathParts(expr || \"this\");\n  const lastLevelIndex = expr.length - 1;\n  return function (obj, value, options) {\n    options = prepareOptions(options);\n    let currentValue = unwrap(obj, options);\n    expr.forEach(function (propertyName, levelIndex) {\n      let propertyValue = readPropValue(currentValue, propertyName, options);\n      const isPropertyFunc = !options.functionsAsIs && isFunction(propertyValue) && !isWrapped(propertyValue);\n      if (levelIndex === lastLevelIndex) {\n        if (options.merge && isPlainObject(value) && (!isDefined(propertyValue) || isPlainObject(propertyValue))) {\n          propertyValue = ensurePropValueDefined(currentValue, propertyName, propertyValue, options);\n          deepExtendArraySafe(propertyValue, value, false, true);\n        } else if (isPropertyFunc) {\n          currentValue[propertyName](value);\n        } else {\n          assignPropValue(currentValue, propertyName, value, options);\n        }\n      } else {\n        propertyValue = ensurePropValueDefined(currentValue, propertyName, propertyValue, options);\n        if (isPropertyFunc) {\n          propertyValue = propertyValue.call(currentValue);\n        }\n        currentValue = propertyValue;\n      }\n    });\n  };\n};\nexport const toComparable = function (value, caseSensitive) {\n  var _options$collatorOpti;\n  let options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};\n  if (value instanceof Date) {\n    return value.getTime();\n  }\n  const collatorSensitivity = null === options || void 0 === options || null === (_options$collatorOpti = options.collatorOptions) || void 0 === _options$collatorOpti ? void 0 : _options$collatorOpti.sensitivity;\n  if (value && value instanceof Class && value.valueOf) {\n    value = value.valueOf();\n  } else if (\"string\" === typeof value && (\"base\" === collatorSensitivity || \"case\" === collatorSensitivity)) {\n    const REMOVE_DIACRITICAL_MARKS_REGEXP = /[\\u0300-\\u036f]/g;\n    if (\"base\" === collatorSensitivity) {\n      value = toLowerCase(value, options);\n    }\n    value = value.normalize(\"NFD\").replace(REMOVE_DIACRITICAL_MARKS_REGEXP, \"\");\n  }\n  const isCaseSensitive = caseSensitive || \"case\" === collatorSensitivity || \"variant\" === collatorSensitivity;\n  if (\"string\" === typeof value && !isCaseSensitive) {\n    var _options$locale;\n    const locale = null === options || void 0 === options || null === (_options$locale = options.locale) || void 0 === _options$locale ? void 0 : _options$locale.toLowerCase();\n    const useUpperCase = locale && !![\"hy\", \"el\"].find(code => locale === code || locale.startsWith(`${code}-`));\n    return (useUpperCase ? toUpperCase : toLowerCase)(value, options);\n  }\n  return value;\n};","map":{"version":3,"names":["Class","errors","each","deepExtendArraySafe","isDefined","isFunction","isObject","isPlainObject","variableWrapper","unwrapVariable","unwrap","isWrapped","assign","bracketsToDots","expr","replace","getPathParts","name","split","readPropValue","obj","propName","options","assignPropValue","value","Error","propValue","unwrapObservables","prepareOptions","compileGetter","arguments","length","slice","call","path","functionAsIs","functionsAsIs","hasDefaultValue","current","i","defaultValue","pathPart","next","Array","isArray","combineGetters","getters","compiledGetters","l","getter","result","last","pathItem","toLowerCase","locale","toLocaleLowerCase","toUpperCase","toLocaleUpperCase","ensurePropValueDefined","newValue","compileSetter","lastLevelIndex","currentValue","forEach","propertyName","levelIndex","propertyValue","isPropertyFunc","merge","toComparable","caseSensitive","_options$collatorOpti","Date","getTime","collatorSensitivity","collatorOptions","sensitivity","valueOf","REMOVE_DIACRITICAL_MARKS_REGEXP","normalize","isCaseSensitive","_options$locale","useUpperCase","find","code","startsWith"],"sources":["/home/nataf/Cours/world-cities-map/client/node_modules/devextreme/esm/__internal/core/utils/m_data.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/__internal/core/utils/m_data.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport Class from \"../../../core/class\";\r\nimport errors from \"../../../core/errors\";\r\nimport {\r\n    each\r\n} from \"../../../core/utils/iterator\";\r\nimport {\r\n    deepExtendArraySafe\r\n} from \"../../../core/utils/object\";\r\nimport {\r\n    isDefined,\r\n    isFunction,\r\n    isObject,\r\n    isPlainObject\r\n} from \"../../../core/utils/type\";\r\nimport variableWrapper from \"../../../core/utils/variable_wrapper\";\r\nconst unwrapVariable = variableWrapper.unwrap;\r\nconst {\r\n    isWrapped: isWrapped\r\n} = variableWrapper;\r\nconst {\r\n    assign: assign\r\n} = variableWrapper;\r\nconst bracketsToDots = function(expr) {\r\n    return expr.replace(/\\[/g, \".\").replace(/\\]/g, \"\")\r\n};\r\nexport const getPathParts = function(name) {\r\n    return bracketsToDots(name).split(\".\")\r\n};\r\nconst readPropValue = function(obj, propName, options) {\r\n    options = options || {};\r\n    if (\"this\" === propName) {\r\n        return unwrap(obj, options)\r\n    }\r\n    return unwrap(obj[propName], options)\r\n};\r\nconst assignPropValue = function(obj, propName, value, options) {\r\n    if (\"this\" === propName) {\r\n        throw new errors.Error(\"E4016\")\r\n    }\r\n    const propValue = obj[propName];\r\n    if (options.unwrapObservables && isWrapped(propValue)) {\r\n        assign(propValue, value)\r\n    } else {\r\n        obj[propName] = value\r\n    }\r\n};\r\nconst prepareOptions = function(options) {\r\n    options = options || {};\r\n    options.unwrapObservables = void 0 !== options.unwrapObservables ? options.unwrapObservables : true;\r\n    return options\r\n};\r\n\r\nfunction unwrap(value, options) {\r\n    return options.unwrapObservables ? unwrapVariable(value) : value\r\n}\r\nexport const compileGetter = function(expr) {\r\n    if (arguments.length > 1) {\r\n        expr = [].slice.call(arguments)\r\n    }\r\n    if (!expr || \"this\" === expr) {\r\n        return function(obj) {\r\n            return obj\r\n        }\r\n    }\r\n    if (\"string\" === typeof expr) {\r\n        const path = getPathParts(expr);\r\n        return function(obj, options) {\r\n            options = prepareOptions(options);\r\n            const functionAsIs = options.functionsAsIs;\r\n            const hasDefaultValue = \"defaultValue\" in options;\r\n            let current = unwrap(obj, options);\r\n            for (let i = 0; i < path.length; i++) {\r\n                if (!current) {\r\n                    if (null == current && hasDefaultValue) {\r\n                        return options.defaultValue\r\n                    }\r\n                    break\r\n                }\r\n                const pathPart = path[i];\r\n                if (hasDefaultValue && isObject(current) && !(pathPart in current)) {\r\n                    return options.defaultValue\r\n                }\r\n                let next = unwrap(current[pathPart], options);\r\n                if (!functionAsIs && isFunction(next)) {\r\n                    next = next.call(current)\r\n                }\r\n                current = next\r\n            }\r\n            return current\r\n        }\r\n    }\r\n    if (Array.isArray(expr)) {\r\n        return combineGetters(expr)\r\n    }\r\n    if (isFunction(expr)) {\r\n        return expr\r\n    }\r\n};\r\n\r\nfunction combineGetters(getters) {\r\n    const compiledGetters = {};\r\n    for (let i = 0, l = getters.length; i < l; i++) {\r\n        const getter = getters[i];\r\n        compiledGetters[getter] = compileGetter(getter)\r\n    }\r\n    return function(obj, options) {\r\n        let result;\r\n        each(compiledGetters, (function(name) {\r\n            const value = this(obj, options);\r\n            if (void 0 === value) {\r\n                return\r\n            }\r\n            let current = result || (result = {});\r\n            const path = name.split(\".\");\r\n            const last = path.length - 1;\r\n            for (let i = 0; i < last; i++) {\r\n                const pathItem = path[i];\r\n                if (!(pathItem in current)) {\r\n                    current[pathItem] = {}\r\n                }\r\n                current = current[pathItem]\r\n            }\r\n            current[path[last]] = value\r\n        }));\r\n        return result\r\n    }\r\n}\r\n\r\nfunction toLowerCase(value, options) {\r\n    return null !== options && void 0 !== options && options.locale ? value.toLocaleLowerCase(options.locale) : value.toLowerCase()\r\n}\r\n\r\nfunction toUpperCase(value, options) {\r\n    return null !== options && void 0 !== options && options.locale ? value.toLocaleUpperCase(options.locale) : value.toUpperCase()\r\n}\r\nconst ensurePropValueDefined = function(obj, propName, value, options) {\r\n    if (isDefined(value)) {\r\n        return value\r\n    }\r\n    const newValue = {};\r\n    assignPropValue(obj, propName, newValue, options);\r\n    return newValue\r\n};\r\nexport const compileSetter = function(expr) {\r\n    expr = getPathParts(expr || \"this\");\r\n    const lastLevelIndex = expr.length - 1;\r\n    return function(obj, value, options) {\r\n        options = prepareOptions(options);\r\n        let currentValue = unwrap(obj, options);\r\n        expr.forEach((function(propertyName, levelIndex) {\r\n            let propertyValue = readPropValue(currentValue, propertyName, options);\r\n            const isPropertyFunc = !options.functionsAsIs && isFunction(propertyValue) && !isWrapped(propertyValue);\r\n            if (levelIndex === lastLevelIndex) {\r\n                if (options.merge && isPlainObject(value) && (!isDefined(propertyValue) || isPlainObject(propertyValue))) {\r\n                    propertyValue = ensurePropValueDefined(currentValue, propertyName, propertyValue, options);\r\n                    deepExtendArraySafe(propertyValue, value, false, true)\r\n                } else if (isPropertyFunc) {\r\n                    currentValue[propertyName](value)\r\n                } else {\r\n                    assignPropValue(currentValue, propertyName, value, options)\r\n                }\r\n            } else {\r\n                propertyValue = ensurePropValueDefined(currentValue, propertyName, propertyValue, options);\r\n                if (isPropertyFunc) {\r\n                    propertyValue = propertyValue.call(currentValue)\r\n                }\r\n                currentValue = propertyValue\r\n            }\r\n        }))\r\n    }\r\n};\r\nexport const toComparable = function(value, caseSensitive) {\r\n    var _options$collatorOpti;\r\n    let options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};\r\n    if (value instanceof Date) {\r\n        return value.getTime()\r\n    }\r\n    const collatorSensitivity = null === options || void 0 === options || null === (_options$collatorOpti = options.collatorOptions) || void 0 === _options$collatorOpti ? void 0 : _options$collatorOpti.sensitivity;\r\n    if (value && value instanceof Class && value.valueOf) {\r\n        value = value.valueOf()\r\n    } else if (\"string\" === typeof value && (\"base\" === collatorSensitivity || \"case\" === collatorSensitivity)) {\r\n        const REMOVE_DIACRITICAL_MARKS_REGEXP = /[\\u0300-\\u036f]/g;\r\n        if (\"base\" === collatorSensitivity) {\r\n            value = toLowerCase(value, options)\r\n        }\r\n        value = value.normalize(\"NFD\").replace(REMOVE_DIACRITICAL_MARKS_REGEXP, \"\")\r\n    }\r\n    const isCaseSensitive = caseSensitive || \"case\" === collatorSensitivity || \"variant\" === collatorSensitivity;\r\n    if (\"string\" === typeof value && !isCaseSensitive) {\r\n        var _options$locale;\r\n        const locale = null === options || void 0 === options || null === (_options$locale = options.locale) || void 0 === _options$locale ? void 0 : _options$locale.toLowerCase();\r\n        const useUpperCase = locale && !![\"hy\", \"el\"].find((code => locale === code || locale.startsWith(`${code}-`)));\r\n        return (useUpperCase ? toUpperCase : toLowerCase)(value, options)\r\n    }\r\n    return value\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}