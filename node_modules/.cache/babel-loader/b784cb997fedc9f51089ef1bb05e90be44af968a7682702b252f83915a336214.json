{"ast":null,"code":"/**\r\n * DevExtreme (esm/__internal/scheduler/m_utils_time_zone.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport errors from \"../../core/errors\";\nimport { dateUtilsTs } from \"../core/utils/date\";\nimport { macroTaskArray } from \"../scheduler/utils/index\";\nimport dateUtils from \"../../core/utils/date\";\nimport DateAdapter from \"./m_date_adapter\";\nimport timeZoneDataUtils from \"./timezones/m_utils_timezones_data\";\nimport timeZoneList from \"./timezones/timezone_list\";\nconst toMs = dateUtils.dateToMilliseconds;\nconst MINUTES_IN_HOUR = 60;\nconst MS_IN_MINUTE = 6e4;\nconst GET_TIMEZONES_BATCH_SIZE = 20;\nconst GMT = \"GMT\";\nconst offsetFormatRegexp = /^GMT(?:[+-]\\d{2}:\\d{2})?$/;\nconst createUTCDateWithLocalOffset = date => {\n  if (!date) {\n    return null;\n  }\n  return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds()));\n};\nconst createDateFromUTCWithLocalOffset = date => {\n  const result = DateAdapter(date);\n  const timezoneOffsetBeforeInMin = result.getTimezoneOffset();\n  result.addTime(result.getTimezoneOffset(\"minute\"));\n  result.subtractMinutes(timezoneOffsetBeforeInMin - result.getTimezoneOffset());\n  return result.source;\n};\nconst createUTCDate = date => new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes()));\nconst getTimezoneOffsetChangeInMinutes = (startDate, endDate, updatedStartDate, updatedEndDate) => getDaylightOffset(updatedStartDate, updatedEndDate) - getDaylightOffset(startDate, endDate);\nconst getTimezoneOffsetChangeInMs = (startDate, endDate, updatedStartDate, updatedEndDate) => getTimezoneOffsetChangeInMinutes(startDate, endDate, updatedStartDate, updatedEndDate) * toMs(\"minute\");\nconst getDaylightOffset = (startDate, endDate) => new Date(startDate).getTimezoneOffset() - new Date(endDate).getTimezoneOffset();\nconst getDaylightOffsetInMs = (startDate, endDate) => getDaylightOffset(startDate, endDate) * toMs(\"minute\");\nconst calculateTimezoneByValueOld = function (timezone) {\n  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Date();\n  const customTimezones = timeZoneDataUtils.getTimeZonesOld();\n  if (0 === customTimezones.length) {\n    return;\n  }\n  const dateUtc = createUTCDate(date);\n  return timeZoneDataUtils.getTimeZoneOffsetById(timezone, dateUtc.getTime());\n};\nconst calculateTimezoneByValueCore = function (timeZone) {\n  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Date();\n  const offset = getStringOffset(timeZone, date);\n  if (void 0 === offset) {\n    return;\n  }\n  if (offset === GMT) {\n    return 0;\n  }\n  const isMinus = \"-\" === offset.substring(3, 4);\n  const hours = offset.substring(4, 6);\n  const minutes = offset.substring(7, 9);\n  const result = parseInt(hours, 10) + parseInt(minutes, 10) / 60;\n  return isMinus ? -result : result;\n};\nconst calculateTimezoneByValue = function (timeZone) {\n  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Date();\n  if (!timeZone) {\n    return;\n  }\n  const isValidTimezone = timeZoneList.value.includes(timeZone);\n  if (!isValidTimezone) {\n    errors.log(\"W0009\", timeZone);\n    return;\n  }\n  if (!dateUtilsTs.isValidDate(date)) {\n    return;\n  }\n  let result = calculateTimezoneByValueOld(timeZone, date);\n  if (void 0 === result) {\n    result = calculateTimezoneByValueCore(timeZone, date);\n  }\n  return result;\n};\nconst getStringOffset = function (timeZone) {\n  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Date();\n  let result = \"\";\n  try {\n    var _dateTimeFormat$forma;\n    const dateTimeFormat = new Intl.DateTimeFormat(\"en-US\", {\n      timeZone: timeZone,\n      timeZoneName: \"longOffset\"\n    });\n    result = (null === (_dateTimeFormat$forma = dateTimeFormat.formatToParts(date).find(_ref => {\n      let {\n        type: type\n      } = _ref;\n      return \"timeZoneName\" === type;\n    })) || void 0 === _dateTimeFormat$forma ? void 0 : _dateTimeFormat$forma.value) ?? \"\";\n  } catch (e) {\n    errors.log(\"W0009\", timeZone);\n    return;\n  }\n  const isSupportedFormat = offsetFormatRegexp.test(result);\n  if (!isSupportedFormat) {\n    errors.log(\"W0009\", timeZone);\n    return;\n  }\n  return result;\n};\nconst getOffsetNamePart = offset => {\n  if (offset === GMT) {\n    return `${offset} +00:00`;\n  }\n  return offset.replace(GMT, `${GMT} `);\n};\nconst getTimezoneTitle = function (timeZone) {\n  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Date();\n  if (!dateUtilsTs.isValidDate(date)) {\n    return \"\";\n  }\n  const tzNamePart = timeZone.replace(/\\//g, \" - \").replace(/_/g, \" \");\n  const offset = getStringOffset(timeZone, date);\n  if (void 0 === offset) {\n    return;\n  }\n  const offsetNamePart = getOffsetNamePart(offset);\n  return `(${offsetNamePart}) ${tzNamePart}`;\n};\nconst _getDaylightOffsetByTimezone = (startDate, endDate, timeZone) => {\n  const startDayOffset = calculateTimezoneByValue(timeZone, startDate);\n  const endDayOffset = calculateTimezoneByValue(timeZone, endDate);\n  if (void 0 === startDayOffset || void 0 === endDayOffset) {\n    return 0;\n  }\n  return startDayOffset - endDayOffset;\n};\nconst getCorrectedDateByDaylightOffsets = (convertedOriginalStartDate, convertedDate, date, timeZone, startDateTimezone) => {\n  const daylightOffsetByCommonTimezone = _getDaylightOffsetByTimezone(convertedOriginalStartDate, convertedDate, timeZone);\n  const daylightOffsetByAppointmentTimezone = _getDaylightOffsetByTimezone(convertedOriginalStartDate, convertedDate, startDateTimezone);\n  const diff = daylightOffsetByCommonTimezone - daylightOffsetByAppointmentTimezone;\n  return new Date(date.getTime() - diff * toMs(\"hour\"));\n};\nconst correctRecurrenceExceptionByTimezone = function (exception, exceptionByStartDate, timeZone, startDateTimeZone) {\n  let isBackConversion = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;\n  let timezoneOffset = (exception.getTimezoneOffset() - exceptionByStartDate.getTimezoneOffset()) / 60;\n  if (startDateTimeZone) {\n    timezoneOffset = _getDaylightOffsetByTimezone(exceptionByStartDate, exception, startDateTimeZone);\n  } else if (timeZone) {\n    timezoneOffset = _getDaylightOffsetByTimezone(exceptionByStartDate, exception, timeZone);\n  }\n  return new Date(exception.getTime() + (isBackConversion ? -1 : 1) * timezoneOffset * toMs(\"hour\"));\n};\nconst isTimezoneChangeInDate = date => {\n  const startDayDate = new Date(new Date(date).setHours(0, 0, 0, 0));\n  const endDayDate = new Date(new Date(date).setHours(23, 59, 59, 0));\n  return startDayDate.getTimezoneOffset() - endDayDate.getTimezoneOffset() !== 0;\n};\nconst getDateWithoutTimezoneChange = date => {\n  const clonedDate = new Date(date);\n  if (isTimezoneChangeInDate(clonedDate)) {\n    const result = new Date(clonedDate);\n    return new Date(result.setDate(result.getDate() + 1));\n  }\n  return clonedDate;\n};\nconst isSameAppointmentDates = (startDate, endDate) => {\n  endDate = new Date(endDate.getTime() - 1);\n  return dateUtils.sameDate(startDate, endDate);\n};\nconst getClientTimezoneOffset = function () {\n  let date = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Date();\n  return 6e4 * date.getTimezoneOffset();\n};\nconst getDiffBetweenClientTimezoneOffsets = function () {\n  let firstDate = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Date();\n  let secondDate = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Date();\n  return getClientTimezoneOffset(firstDate) - getClientTimezoneOffset(secondDate);\n};\nconst isEqualLocalTimeZone = function (timeZoneName) {\n  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Date();\n  if (Intl) {\n    const localTimeZoneName = Intl.DateTimeFormat().resolvedOptions().timeZone;\n    if (localTimeZoneName === timeZoneName) {\n      return true;\n    }\n  }\n  return isEqualLocalTimeZoneByDeclaration(timeZoneName, date);\n};\nconst hasDSTInLocalTimeZone = () => {\n  const [startDate, endDate] = getExtremeDates();\n  return startDate.getTimezoneOffset() !== endDate.getTimezoneOffset();\n};\nconst getOffset = date => -date.getTimezoneOffset() / 60;\nconst getDateAndMoveHourBack = dateStamp => new Date(dateStamp - toMs(\"hour\"));\nconst isEqualLocalTimeZoneByDeclarationOld = (timeZoneName, date) => {\n  const year = date.getFullYear();\n  const configTuple = timeZoneDataUtils.getTimeZoneDeclarationTuple(timeZoneName, year);\n  const [summerTime, winterTime] = configTuple;\n  const noDSTInTargetTimeZone = configTuple.length < 2;\n  if (noDSTInTargetTimeZone) {\n    const targetTimeZoneOffset = timeZoneDataUtils.getTimeZoneOffsetById(timeZoneName, date);\n    const localTimeZoneOffset = getOffset(date);\n    if (targetTimeZoneOffset !== localTimeZoneOffset) {\n      return false;\n    }\n    return !hasDSTInLocalTimeZone();\n  }\n  const localSummerOffset = getOffset(new Date(summerTime.date));\n  const localWinterOffset = getOffset(new Date(winterTime.date));\n  if (localSummerOffset !== summerTime.offset) {\n    return false;\n  }\n  if (localSummerOffset === getOffset(getDateAndMoveHourBack(summerTime.date))) {\n    return false;\n  }\n  if (localWinterOffset !== winterTime.offset) {\n    return false;\n  }\n  if (localWinterOffset === getOffset(getDateAndMoveHourBack(winterTime.date))) {\n    return false;\n  }\n  return true;\n};\nconst isEqualLocalTimeZoneByDeclaration = (timeZoneName, date) => {\n  const customTimezones = timeZoneDataUtils.getTimeZonesOld();\n  const targetTimezoneData = customTimezones.filter(tz => tz.id === timeZoneName);\n  if (1 === targetTimezoneData.length) {\n    return isEqualLocalTimeZoneByDeclarationOld(timeZoneName, date);\n  }\n  return false;\n};\nconst getExtremeDates = () => {\n  const nowDate = new Date(Date.now());\n  const startDate = new Date();\n  const endDate = new Date();\n  startDate.setFullYear(nowDate.getFullYear(), 0, 1);\n  endDate.setFullYear(nowDate.getFullYear(), 6, 1);\n  return [startDate, endDate];\n};\nconst setOffsetsToDate = (targetDate, offsetsArray) => {\n  const newDateMs = offsetsArray.reduce((result, offset) => result + offset, targetDate.getTime());\n  return new Date(newDateMs);\n};\nconst addOffsetsWithoutDST = function (date) {\n  for (var _len = arguments.length, offsets = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    offsets[_key - 1] = arguments[_key];\n  }\n  const newDate = dateUtilsTs.addOffsets(date, offsets);\n  const daylightShift = getDaylightOffsetInMs(date, newDate);\n  if (!daylightShift) {\n    return newDate;\n  }\n  const correctLocalDate = dateUtilsTs.addOffsets(newDate, [-daylightShift]);\n  const daylightSecondShift = getDaylightOffsetInMs(newDate, correctLocalDate);\n  return !daylightSecondShift ? correctLocalDate : newDate;\n};\nconst getTimeZoneLabelsAsyncBatch = function () {\n  let date = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Date();\n  return macroTaskArray.map(timeZoneList.value, timezoneId => ({\n    id: timezoneId,\n    title: getTimezoneTitle(timezoneId, date)\n  }), 20);\n};\nconst getTimeZoneLabel = function (timezoneId) {\n  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Date();\n  return {\n    id: timezoneId,\n    title: getTimezoneTitle(timezoneId, date)\n  };\n};\nconst getTimeZones = function () {\n  let date = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Date();\n  return timeZoneList.value.map(timezoneId => ({\n    id: timezoneId,\n    title: getTimezoneTitle(timezoneId, date),\n    offset: calculateTimezoneByValue(timezoneId, date)\n  }));\n};\nconst utils = {\n  getDaylightOffset: getDaylightOffset,\n  getDaylightOffsetInMs: getDaylightOffsetInMs,\n  getTimezoneOffsetChangeInMinutes: getTimezoneOffsetChangeInMinutes,\n  getTimezoneOffsetChangeInMs: getTimezoneOffsetChangeInMs,\n  calculateTimezoneByValue: calculateTimezoneByValue,\n  getCorrectedDateByDaylightOffsets: getCorrectedDateByDaylightOffsets,\n  isSameAppointmentDates: isSameAppointmentDates,\n  correctRecurrenceExceptionByTimezone: correctRecurrenceExceptionByTimezone,\n  getClientTimezoneOffset: getClientTimezoneOffset,\n  getDiffBetweenClientTimezoneOffsets: getDiffBetweenClientTimezoneOffsets,\n  createUTCDateWithLocalOffset: createUTCDateWithLocalOffset,\n  createDateFromUTCWithLocalOffset: createDateFromUTCWithLocalOffset,\n  createUTCDate: createUTCDate,\n  isTimezoneChangeInDate: isTimezoneChangeInDate,\n  getDateWithoutTimezoneChange: getDateWithoutTimezoneChange,\n  hasDSTInLocalTimeZone: hasDSTInLocalTimeZone,\n  isEqualLocalTimeZone: isEqualLocalTimeZone,\n  isEqualLocalTimeZoneByDeclaration: isEqualLocalTimeZoneByDeclaration,\n  setOffsetsToDate: setOffsetsToDate,\n  addOffsetsWithoutDST: addOffsetsWithoutDST,\n  getTimeZoneLabelsAsyncBatch: getTimeZoneLabelsAsyncBatch,\n  getTimeZoneLabel: getTimeZoneLabel,\n  getTimeZones: getTimeZones\n};\nexport default utils;","map":{"version":3,"names":["errors","dateUtilsTs","macroTaskArray","dateUtils","DateAdapter","timeZoneDataUtils","timeZoneList","toMs","dateToMilliseconds","MINUTES_IN_HOUR","MS_IN_MINUTE","GET_TIMEZONES_BATCH_SIZE","GMT","offsetFormatRegexp","createUTCDateWithLocalOffset","date","Date","UTC","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","createDateFromUTCWithLocalOffset","result","timezoneOffsetBeforeInMin","getTimezoneOffset","addTime","subtractMinutes","source","createUTCDate","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getTimezoneOffsetChangeInMinutes","startDate","endDate","updatedStartDate","updatedEndDate","getDaylightOffset","getTimezoneOffsetChangeInMs","getDaylightOffsetInMs","calculateTimezoneByValueOld","timezone","arguments","length","customTimezones","getTimeZonesOld","dateUtc","getTimeZoneOffsetById","getTime","calculateTimezoneByValueCore","timeZone","offset","getStringOffset","isMinus","substring","hours","minutes","parseInt","calculateTimezoneByValue","isValidTimezone","value","includes","log","isValidDate","_dateTimeFormat$forma","dateTimeFormat","Intl","DateTimeFormat","timeZoneName","formatToParts","find","_ref","type","e","isSupportedFormat","test","getOffsetNamePart","replace","getTimezoneTitle","tzNamePart","offsetNamePart","_getDaylightOffsetByTimezone","startDayOffset","endDayOffset","getCorrectedDateByDaylightOffsets","convertedOriginalStartDate","convertedDate","startDateTimezone","daylightOffsetByCommonTimezone","daylightOffsetByAppointmentTimezone","diff","correctRecurrenceExceptionByTimezone","exception","exceptionByStartDate","startDateTimeZone","isBackConversion","timezoneOffset","isTimezoneChangeInDate","startDayDate","setHours","endDayDate","getDateWithoutTimezoneChange","clonedDate","setDate","isSameAppointmentDates","sameDate","getClientTimezoneOffset","getDiffBetweenClientTimezoneOffsets","firstDate","secondDate","isEqualLocalTimeZone","localTimeZoneName","resolvedOptions","isEqualLocalTimeZoneByDeclaration","hasDSTInLocalTimeZone","getExtremeDates","getOffset","getDateAndMoveHourBack","dateStamp","isEqualLocalTimeZoneByDeclarationOld","year","configTuple","getTimeZoneDeclarationTuple","summerTime","winterTime","noDSTInTargetTimeZone","targetTimeZoneOffset","localTimeZoneOffset","localSummerOffset","localWinterOffset","targetTimezoneData","filter","tz","id","nowDate","now","setFullYear","setOffsetsToDate","targetDate","offsetsArray","newDateMs","reduce","addOffsetsWithoutDST","_len","offsets","Array","_key","newDate","addOffsets","daylightShift","correctLocalDate","daylightSecondShift","getTimeZoneLabelsAsyncBatch","map","timezoneId","title","getTimeZoneLabel","getTimeZones","utils"],"sources":["/home/nataf/Cours/world-cities-map/client/node_modules/devextreme/esm/__internal/scheduler/m_utils_time_zone.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/__internal/scheduler/m_utils_time_zone.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport errors from \"../../core/errors\";\r\nimport {\r\n    dateUtilsTs\r\n} from \"../core/utils/date\";\r\nimport {\r\n    macroTaskArray\r\n} from \"../scheduler/utils/index\";\r\nimport dateUtils from \"../../core/utils/date\";\r\nimport DateAdapter from \"./m_date_adapter\";\r\nimport timeZoneDataUtils from \"./timezones/m_utils_timezones_data\";\r\nimport timeZoneList from \"./timezones/timezone_list\";\r\nconst toMs = dateUtils.dateToMilliseconds;\r\nconst MINUTES_IN_HOUR = 60;\r\nconst MS_IN_MINUTE = 6e4;\r\nconst GET_TIMEZONES_BATCH_SIZE = 20;\r\nconst GMT = \"GMT\";\r\nconst offsetFormatRegexp = /^GMT(?:[+-]\\d{2}:\\d{2})?$/;\r\nconst createUTCDateWithLocalOffset = date => {\r\n    if (!date) {\r\n        return null\r\n    }\r\n    return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds()))\r\n};\r\nconst createDateFromUTCWithLocalOffset = date => {\r\n    const result = DateAdapter(date);\r\n    const timezoneOffsetBeforeInMin = result.getTimezoneOffset();\r\n    result.addTime(result.getTimezoneOffset(\"minute\"));\r\n    result.subtractMinutes(timezoneOffsetBeforeInMin - result.getTimezoneOffset());\r\n    return result.source\r\n};\r\nconst createUTCDate = date => new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes()));\r\nconst getTimezoneOffsetChangeInMinutes = (startDate, endDate, updatedStartDate, updatedEndDate) => getDaylightOffset(updatedStartDate, updatedEndDate) - getDaylightOffset(startDate, endDate);\r\nconst getTimezoneOffsetChangeInMs = (startDate, endDate, updatedStartDate, updatedEndDate) => getTimezoneOffsetChangeInMinutes(startDate, endDate, updatedStartDate, updatedEndDate) * toMs(\"minute\");\r\nconst getDaylightOffset = (startDate, endDate) => new Date(startDate).getTimezoneOffset() - new Date(endDate).getTimezoneOffset();\r\nconst getDaylightOffsetInMs = (startDate, endDate) => getDaylightOffset(startDate, endDate) * toMs(\"minute\");\r\nconst calculateTimezoneByValueOld = function(timezone) {\r\n    let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Date;\r\n    const customTimezones = timeZoneDataUtils.getTimeZonesOld();\r\n    if (0 === customTimezones.length) {\r\n        return\r\n    }\r\n    const dateUtc = createUTCDate(date);\r\n    return timeZoneDataUtils.getTimeZoneOffsetById(timezone, dateUtc.getTime())\r\n};\r\nconst calculateTimezoneByValueCore = function(timeZone) {\r\n    let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Date;\r\n    const offset = getStringOffset(timeZone, date);\r\n    if (void 0 === offset) {\r\n        return\r\n    }\r\n    if (offset === GMT) {\r\n        return 0\r\n    }\r\n    const isMinus = \"-\" === offset.substring(3, 4);\r\n    const hours = offset.substring(4, 6);\r\n    const minutes = offset.substring(7, 9);\r\n    const result = parseInt(hours, 10) + parseInt(minutes, 10) / 60;\r\n    return isMinus ? -result : result\r\n};\r\nconst calculateTimezoneByValue = function(timeZone) {\r\n    let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Date;\r\n    if (!timeZone) {\r\n        return\r\n    }\r\n    const isValidTimezone = timeZoneList.value.includes(timeZone);\r\n    if (!isValidTimezone) {\r\n        errors.log(\"W0009\", timeZone);\r\n        return\r\n    }\r\n    if (!dateUtilsTs.isValidDate(date)) {\r\n        return\r\n    }\r\n    let result = calculateTimezoneByValueOld(timeZone, date);\r\n    if (void 0 === result) {\r\n        result = calculateTimezoneByValueCore(timeZone, date)\r\n    }\r\n    return result\r\n};\r\nconst getStringOffset = function(timeZone) {\r\n    let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Date;\r\n    let result = \"\";\r\n    try {\r\n        var _dateTimeFormat$forma;\r\n        const dateTimeFormat = new Intl.DateTimeFormat(\"en-US\", {\r\n            timeZone: timeZone,\r\n            timeZoneName: \"longOffset\"\r\n        });\r\n        result = (null === (_dateTimeFormat$forma = dateTimeFormat.formatToParts(date).find((_ref => {\r\n            let {\r\n                type: type\r\n            } = _ref;\r\n            return \"timeZoneName\" === type\r\n        }))) || void 0 === _dateTimeFormat$forma ? void 0 : _dateTimeFormat$forma.value) ?? \"\"\r\n    } catch (e) {\r\n        errors.log(\"W0009\", timeZone);\r\n        return\r\n    }\r\n    const isSupportedFormat = offsetFormatRegexp.test(result);\r\n    if (!isSupportedFormat) {\r\n        errors.log(\"W0009\", timeZone);\r\n        return\r\n    }\r\n    return result\r\n};\r\nconst getOffsetNamePart = offset => {\r\n    if (offset === GMT) {\r\n        return `${offset} +00:00`\r\n    }\r\n    return offset.replace(GMT, `${GMT} `)\r\n};\r\nconst getTimezoneTitle = function(timeZone) {\r\n    let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Date;\r\n    if (!dateUtilsTs.isValidDate(date)) {\r\n        return \"\"\r\n    }\r\n    const tzNamePart = timeZone.replace(/\\//g, \" - \").replace(/_/g, \" \");\r\n    const offset = getStringOffset(timeZone, date);\r\n    if (void 0 === offset) {\r\n        return\r\n    }\r\n    const offsetNamePart = getOffsetNamePart(offset);\r\n    return `(${offsetNamePart}) ${tzNamePart}`\r\n};\r\nconst _getDaylightOffsetByTimezone = (startDate, endDate, timeZone) => {\r\n    const startDayOffset = calculateTimezoneByValue(timeZone, startDate);\r\n    const endDayOffset = calculateTimezoneByValue(timeZone, endDate);\r\n    if (void 0 === startDayOffset || void 0 === endDayOffset) {\r\n        return 0\r\n    }\r\n    return startDayOffset - endDayOffset\r\n};\r\nconst getCorrectedDateByDaylightOffsets = (convertedOriginalStartDate, convertedDate, date, timeZone, startDateTimezone) => {\r\n    const daylightOffsetByCommonTimezone = _getDaylightOffsetByTimezone(convertedOriginalStartDate, convertedDate, timeZone);\r\n    const daylightOffsetByAppointmentTimezone = _getDaylightOffsetByTimezone(convertedOriginalStartDate, convertedDate, startDateTimezone);\r\n    const diff = daylightOffsetByCommonTimezone - daylightOffsetByAppointmentTimezone;\r\n    return new Date(date.getTime() - diff * toMs(\"hour\"))\r\n};\r\nconst correctRecurrenceExceptionByTimezone = function(exception, exceptionByStartDate, timeZone, startDateTimeZone) {\r\n    let isBackConversion = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;\r\n    let timezoneOffset = (exception.getTimezoneOffset() - exceptionByStartDate.getTimezoneOffset()) / 60;\r\n    if (startDateTimeZone) {\r\n        timezoneOffset = _getDaylightOffsetByTimezone(exceptionByStartDate, exception, startDateTimeZone)\r\n    } else if (timeZone) {\r\n        timezoneOffset = _getDaylightOffsetByTimezone(exceptionByStartDate, exception, timeZone)\r\n    }\r\n    return new Date(exception.getTime() + (isBackConversion ? -1 : 1) * timezoneOffset * toMs(\"hour\"))\r\n};\r\nconst isTimezoneChangeInDate = date => {\r\n    const startDayDate = new Date(new Date(date).setHours(0, 0, 0, 0));\r\n    const endDayDate = new Date(new Date(date).setHours(23, 59, 59, 0));\r\n    return startDayDate.getTimezoneOffset() - endDayDate.getTimezoneOffset() !== 0\r\n};\r\nconst getDateWithoutTimezoneChange = date => {\r\n    const clonedDate = new Date(date);\r\n    if (isTimezoneChangeInDate(clonedDate)) {\r\n        const result = new Date(clonedDate);\r\n        return new Date(result.setDate(result.getDate() + 1))\r\n    }\r\n    return clonedDate\r\n};\r\nconst isSameAppointmentDates = (startDate, endDate) => {\r\n    endDate = new Date(endDate.getTime() - 1);\r\n    return dateUtils.sameDate(startDate, endDate)\r\n};\r\nconst getClientTimezoneOffset = function() {\r\n    let date = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Date;\r\n    return 6e4 * date.getTimezoneOffset()\r\n};\r\nconst getDiffBetweenClientTimezoneOffsets = function() {\r\n    let firstDate = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Date;\r\n    let secondDate = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Date;\r\n    return getClientTimezoneOffset(firstDate) - getClientTimezoneOffset(secondDate)\r\n};\r\nconst isEqualLocalTimeZone = function(timeZoneName) {\r\n    let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Date;\r\n    if (Intl) {\r\n        const localTimeZoneName = Intl.DateTimeFormat().resolvedOptions().timeZone;\r\n        if (localTimeZoneName === timeZoneName) {\r\n            return true\r\n        }\r\n    }\r\n    return isEqualLocalTimeZoneByDeclaration(timeZoneName, date)\r\n};\r\nconst hasDSTInLocalTimeZone = () => {\r\n    const [startDate, endDate] = getExtremeDates();\r\n    return startDate.getTimezoneOffset() !== endDate.getTimezoneOffset()\r\n};\r\nconst getOffset = date => -date.getTimezoneOffset() / 60;\r\nconst getDateAndMoveHourBack = dateStamp => new Date(dateStamp - toMs(\"hour\"));\r\nconst isEqualLocalTimeZoneByDeclarationOld = (timeZoneName, date) => {\r\n    const year = date.getFullYear();\r\n    const configTuple = timeZoneDataUtils.getTimeZoneDeclarationTuple(timeZoneName, year);\r\n    const [summerTime, winterTime] = configTuple;\r\n    const noDSTInTargetTimeZone = configTuple.length < 2;\r\n    if (noDSTInTargetTimeZone) {\r\n        const targetTimeZoneOffset = timeZoneDataUtils.getTimeZoneOffsetById(timeZoneName, date);\r\n        const localTimeZoneOffset = getOffset(date);\r\n        if (targetTimeZoneOffset !== localTimeZoneOffset) {\r\n            return false\r\n        }\r\n        return !hasDSTInLocalTimeZone()\r\n    }\r\n    const localSummerOffset = getOffset(new Date(summerTime.date));\r\n    const localWinterOffset = getOffset(new Date(winterTime.date));\r\n    if (localSummerOffset !== summerTime.offset) {\r\n        return false\r\n    }\r\n    if (localSummerOffset === getOffset(getDateAndMoveHourBack(summerTime.date))) {\r\n        return false\r\n    }\r\n    if (localWinterOffset !== winterTime.offset) {\r\n        return false\r\n    }\r\n    if (localWinterOffset === getOffset(getDateAndMoveHourBack(winterTime.date))) {\r\n        return false\r\n    }\r\n    return true\r\n};\r\nconst isEqualLocalTimeZoneByDeclaration = (timeZoneName, date) => {\r\n    const customTimezones = timeZoneDataUtils.getTimeZonesOld();\r\n    const targetTimezoneData = customTimezones.filter((tz => tz.id === timeZoneName));\r\n    if (1 === targetTimezoneData.length) {\r\n        return isEqualLocalTimeZoneByDeclarationOld(timeZoneName, date)\r\n    }\r\n    return false\r\n};\r\nconst getExtremeDates = () => {\r\n    const nowDate = new Date(Date.now());\r\n    const startDate = new Date;\r\n    const endDate = new Date;\r\n    startDate.setFullYear(nowDate.getFullYear(), 0, 1);\r\n    endDate.setFullYear(nowDate.getFullYear(), 6, 1);\r\n    return [startDate, endDate]\r\n};\r\nconst setOffsetsToDate = (targetDate, offsetsArray) => {\r\n    const newDateMs = offsetsArray.reduce(((result, offset) => result + offset), targetDate.getTime());\r\n    return new Date(newDateMs)\r\n};\r\nconst addOffsetsWithoutDST = function(date) {\r\n    for (var _len = arguments.length, offsets = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\r\n        offsets[_key - 1] = arguments[_key]\r\n    }\r\n    const newDate = dateUtilsTs.addOffsets(date, offsets);\r\n    const daylightShift = getDaylightOffsetInMs(date, newDate);\r\n    if (!daylightShift) {\r\n        return newDate\r\n    }\r\n    const correctLocalDate = dateUtilsTs.addOffsets(newDate, [-daylightShift]);\r\n    const daylightSecondShift = getDaylightOffsetInMs(newDate, correctLocalDate);\r\n    return !daylightSecondShift ? correctLocalDate : newDate\r\n};\r\nconst getTimeZoneLabelsAsyncBatch = function() {\r\n    let date = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Date;\r\n    return macroTaskArray.map(timeZoneList.value, (timezoneId => ({\r\n        id: timezoneId,\r\n        title: getTimezoneTitle(timezoneId, date)\r\n    })), 20)\r\n};\r\nconst getTimeZoneLabel = function(timezoneId) {\r\n    let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Date;\r\n    return {\r\n        id: timezoneId,\r\n        title: getTimezoneTitle(timezoneId, date)\r\n    }\r\n};\r\nconst getTimeZones = function() {\r\n    let date = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Date;\r\n    return timeZoneList.value.map((timezoneId => ({\r\n        id: timezoneId,\r\n        title: getTimezoneTitle(timezoneId, date),\r\n        offset: calculateTimezoneByValue(timezoneId, date)\r\n    })))\r\n};\r\nconst utils = {\r\n    getDaylightOffset: getDaylightOffset,\r\n    getDaylightOffsetInMs: getDaylightOffsetInMs,\r\n    getTimezoneOffsetChangeInMinutes: getTimezoneOffsetChangeInMinutes,\r\n    getTimezoneOffsetChangeInMs: getTimezoneOffsetChangeInMs,\r\n    calculateTimezoneByValue: calculateTimezoneByValue,\r\n    getCorrectedDateByDaylightOffsets: getCorrectedDateByDaylightOffsets,\r\n    isSameAppointmentDates: isSameAppointmentDates,\r\n    correctRecurrenceExceptionByTimezone: correctRecurrenceExceptionByTimezone,\r\n    getClientTimezoneOffset: getClientTimezoneOffset,\r\n    getDiffBetweenClientTimezoneOffsets: getDiffBetweenClientTimezoneOffsets,\r\n    createUTCDateWithLocalOffset: createUTCDateWithLocalOffset,\r\n    createDateFromUTCWithLocalOffset: createDateFromUTCWithLocalOffset,\r\n    createUTCDate: createUTCDate,\r\n    isTimezoneChangeInDate: isTimezoneChangeInDate,\r\n    getDateWithoutTimezoneChange: getDateWithoutTimezoneChange,\r\n    hasDSTInLocalTimeZone: hasDSTInLocalTimeZone,\r\n    isEqualLocalTimeZone: isEqualLocalTimeZone,\r\n    isEqualLocalTimeZoneByDeclaration: isEqualLocalTimeZoneByDeclaration,\r\n    setOffsetsToDate: setOffsetsToDate,\r\n    addOffsetsWithoutDST: addOffsetsWithoutDST,\r\n    getTimeZoneLabelsAsyncBatch: getTimeZoneLabelsAsyncBatch,\r\n    getTimeZoneLabel: getTimeZoneLabel,\r\n    getTimeZones: getTimeZones\r\n};\r\nexport default utils;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}