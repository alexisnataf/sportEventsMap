{"ast":null,"code":"/**\r\n * DevExtreme (esm/__internal/ui/number_box/m_number_box.caret.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport number from \"../../../common/core/localization/number\";\nimport { escapeRegExp } from \"../../../core/utils/common\";\nimport { fitIntoRange } from \"../../../core/utils/math\";\nimport { getNthOccurrence, getRealSeparatorIndex, splitByIndex } from \"./m_utils\";\nexport const getCaretBoundaries = function (text, format) {\n  if (\"string\" === typeof format) {\n    const signParts = format.split(\";\");\n    const sign = number.getSign(text, format);\n    signParts[1] = signParts[1] || `-${signParts[0]}`;\n    format = signParts[sign < 0 ? 1 : 0];\n    const mockEscapedStubs = str => str.replace(/'([^']*)'/g, str => str.split(\"\").map(() => \" \").join(\"\").substr(2));\n    format = mockEscapedStubs(format);\n    const prefixStubLength = /^[^#0.,]*/.exec(format)[0].length;\n    const postfixStubLength = /[^#0.,]*$/.exec(format)[0].length;\n    return {\n      start: prefixStubLength,\n      end: text.length - postfixStubLength\n    };\n  }\n  return {\n    start: 0,\n    end: text.length\n  };\n};\nconst _getDigitCountBeforeIndex = function (index, text) {\n  const decimalSeparator = number.getDecimalSeparator();\n  const regExp = new RegExp(`[^0-9${escapeRegExp(decimalSeparator)}]`, \"g\");\n  const textBeforePosition = text.slice(0, index);\n  return textBeforePosition.replace(regExp, \"\").length;\n};\nconst _reverseText = function (text) {\n  return text.split(\"\").reverse().join(\"\");\n};\nconst _getDigitPositionByIndex = function (digitIndex, text) {\n  if (!digitIndex) {\n    return -1;\n  }\n  const regExp = /[0-9]/g;\n  let counter = 1;\n  let index = null;\n  let result = regExp.exec(text);\n  while (result) {\n    index = result.index;\n    if (counter >= digitIndex) {\n      return index;\n    }\n    counter++;\n    result = regExp.exec(text);\n  }\n  return null === index ? text.length : index;\n};\nconst _trimNonNumericCharsFromEnd = function (text) {\n  return text.replace(/[^0-9e]+$/, \"\");\n};\nexport const getCaretWithOffset = function (caret, offset) {\n  if (void 0 === caret.start) {\n    caret = {\n      start: caret,\n      end: caret\n    };\n  }\n  return {\n    start: caret.start + offset,\n    end: caret.end + offset\n  };\n};\nexport const getCaretAfterFormat = function (text, formatted, caret, format) {\n  caret = getCaretWithOffset(caret, 0);\n  const point = number.getDecimalSeparator();\n  const isSeparatorBasedText = isSeparatorBasedString(text);\n  const realSeparatorOccurrenceIndex = getRealSeparatorIndex(format).occurrence;\n  const pointPosition = isSeparatorBasedText ? 0 : getNthOccurrence(text, point, realSeparatorOccurrenceIndex);\n  const newPointPosition = getNthOccurrence(formatted, point, realSeparatorOccurrenceIndex);\n  const textParts = splitByIndex(text, pointPosition);\n  const formattedParts = splitByIndex(formatted, newPointPosition);\n  const isCaretOnFloat = -1 !== pointPosition && caret.start > pointPosition;\n  if (isCaretOnFloat) {\n    const relativeIndex = caret.start - pointPosition - 1;\n    const digitsBefore = _getDigitCountBeforeIndex(relativeIndex, textParts[1]);\n    const newPosition = formattedParts[1] ? newPointPosition + 1 + _getDigitPositionByIndex(digitsBefore, formattedParts[1]) + 1 : formatted.length;\n    return getCaretInBoundaries(newPosition, formatted, format);\n  }\n  const formattedIntPart = _trimNonNumericCharsFromEnd(formattedParts[0]);\n  const positionFromEnd = textParts[0].length - caret.start;\n  const digitsFromEnd = _getDigitCountBeforeIndex(positionFromEnd, _reverseText(textParts[0]));\n  const newPositionFromEnd = _getDigitPositionByIndex(digitsFromEnd, _reverseText(formattedIntPart));\n  const newPositionFromBegin = formattedIntPart.length - (newPositionFromEnd + 1);\n  return getCaretInBoundaries(newPositionFromBegin, formatted, format);\n};\nfunction isSeparatorBasedString(text) {\n  return 1 === text.length && !!text.match(/^[,.][0-9]*$/g);\n}\nexport const isCaretInBoundaries = function (caret, text, format) {\n  caret = getCaretWithOffset(caret, 0);\n  const boundaries = getCaretInBoundaries(caret, text, format);\n  return caret.start >= boundaries.start && caret.end <= boundaries.end;\n};\nexport function getCaretInBoundaries(caret, text, format) {\n  caret = getCaretWithOffset(caret, 0);\n  const boundaries = getCaretBoundaries(text, format);\n  const adjustedCaret = {\n    start: fitIntoRange(caret.start, boundaries.start, boundaries.end),\n    end: fitIntoRange(caret.end, boundaries.start, boundaries.end)\n  };\n  return adjustedCaret;\n}\nexport const getCaretOffset = function (previousText, newText, format) {\n  const previousBoundaries = getCaretBoundaries(previousText, format);\n  const newBoundaries = getCaretBoundaries(newText, format);\n  return newBoundaries.start - previousBoundaries.start;\n};","map":{"version":3,"names":["number","escapeRegExp","fitIntoRange","getNthOccurrence","getRealSeparatorIndex","splitByIndex","getCaretBoundaries","text","format","signParts","split","sign","getSign","mockEscapedStubs","str","replace","map","join","substr","prefixStubLength","exec","length","postfixStubLength","start","end","_getDigitCountBeforeIndex","index","decimalSeparator","getDecimalSeparator","regExp","RegExp","textBeforePosition","slice","_reverseText","reverse","_getDigitPositionByIndex","digitIndex","counter","result","_trimNonNumericCharsFromEnd","getCaretWithOffset","caret","offset","getCaretAfterFormat","formatted","point","isSeparatorBasedText","isSeparatorBasedString","realSeparatorOccurrenceIndex","occurrence","pointPosition","newPointPosition","textParts","formattedParts","isCaretOnFloat","relativeIndex","digitsBefore","newPosition","getCaretInBoundaries","formattedIntPart","positionFromEnd","digitsFromEnd","newPositionFromEnd","newPositionFromBegin","match","isCaretInBoundaries","boundaries","adjustedCaret","getCaretOffset","previousText","newText","previousBoundaries","newBoundaries"],"sources":["/home/nataf/Cours/world-cities-map/client/node_modules/devextreme/esm/__internal/ui/number_box/m_number_box.caret.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/__internal/ui/number_box/m_number_box.caret.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport number from \"../../../common/core/localization/number\";\r\nimport {\r\n    escapeRegExp\r\n} from \"../../../core/utils/common\";\r\nimport {\r\n    fitIntoRange\r\n} from \"../../../core/utils/math\";\r\nimport {\r\n    getNthOccurrence,\r\n    getRealSeparatorIndex,\r\n    splitByIndex\r\n} from \"./m_utils\";\r\nexport const getCaretBoundaries = function(text, format) {\r\n    if (\"string\" === typeof format) {\r\n        const signParts = format.split(\";\");\r\n        const sign = number.getSign(text, format);\r\n        signParts[1] = signParts[1] || `-${signParts[0]}`;\r\n        format = signParts[sign < 0 ? 1 : 0];\r\n        const mockEscapedStubs = str => str.replace(/'([^']*)'/g, (str => str.split(\"\").map((() => \" \")).join(\"\").substr(2)));\r\n        format = mockEscapedStubs(format);\r\n        const prefixStubLength = /^[^#0.,]*/.exec(format)[0].length;\r\n        const postfixStubLength = /[^#0.,]*$/.exec(format)[0].length;\r\n        return {\r\n            start: prefixStubLength,\r\n            end: text.length - postfixStubLength\r\n        }\r\n    }\r\n    return {\r\n        start: 0,\r\n        end: text.length\r\n    }\r\n};\r\nconst _getDigitCountBeforeIndex = function(index, text) {\r\n    const decimalSeparator = number.getDecimalSeparator();\r\n    const regExp = new RegExp(`[^0-9${escapeRegExp(decimalSeparator)}]`, \"g\");\r\n    const textBeforePosition = text.slice(0, index);\r\n    return textBeforePosition.replace(regExp, \"\").length\r\n};\r\nconst _reverseText = function(text) {\r\n    return text.split(\"\").reverse().join(\"\")\r\n};\r\nconst _getDigitPositionByIndex = function(digitIndex, text) {\r\n    if (!digitIndex) {\r\n        return -1\r\n    }\r\n    const regExp = /[0-9]/g;\r\n    let counter = 1;\r\n    let index = null;\r\n    let result = regExp.exec(text);\r\n    while (result) {\r\n        index = result.index;\r\n        if (counter >= digitIndex) {\r\n            return index\r\n        }\r\n        counter++;\r\n        result = regExp.exec(text)\r\n    }\r\n    return null === index ? text.length : index\r\n};\r\nconst _trimNonNumericCharsFromEnd = function(text) {\r\n    return text.replace(/[^0-9e]+$/, \"\")\r\n};\r\nexport const getCaretWithOffset = function(caret, offset) {\r\n    if (void 0 === caret.start) {\r\n        caret = {\r\n            start: caret,\r\n            end: caret\r\n        }\r\n    }\r\n    return {\r\n        start: caret.start + offset,\r\n        end: caret.end + offset\r\n    }\r\n};\r\nexport const getCaretAfterFormat = function(text, formatted, caret, format) {\r\n    caret = getCaretWithOffset(caret, 0);\r\n    const point = number.getDecimalSeparator();\r\n    const isSeparatorBasedText = isSeparatorBasedString(text);\r\n    const realSeparatorOccurrenceIndex = getRealSeparatorIndex(format).occurrence;\r\n    const pointPosition = isSeparatorBasedText ? 0 : getNthOccurrence(text, point, realSeparatorOccurrenceIndex);\r\n    const newPointPosition = getNthOccurrence(formatted, point, realSeparatorOccurrenceIndex);\r\n    const textParts = splitByIndex(text, pointPosition);\r\n    const formattedParts = splitByIndex(formatted, newPointPosition);\r\n    const isCaretOnFloat = -1 !== pointPosition && caret.start > pointPosition;\r\n    if (isCaretOnFloat) {\r\n        const relativeIndex = caret.start - pointPosition - 1;\r\n        const digitsBefore = _getDigitCountBeforeIndex(relativeIndex, textParts[1]);\r\n        const newPosition = formattedParts[1] ? newPointPosition + 1 + _getDigitPositionByIndex(digitsBefore, formattedParts[1]) + 1 : formatted.length;\r\n        return getCaretInBoundaries(newPosition, formatted, format)\r\n    }\r\n    const formattedIntPart = _trimNonNumericCharsFromEnd(formattedParts[0]);\r\n    const positionFromEnd = textParts[0].length - caret.start;\r\n    const digitsFromEnd = _getDigitCountBeforeIndex(positionFromEnd, _reverseText(textParts[0]));\r\n    const newPositionFromEnd = _getDigitPositionByIndex(digitsFromEnd, _reverseText(formattedIntPart));\r\n    const newPositionFromBegin = formattedIntPart.length - (newPositionFromEnd + 1);\r\n    return getCaretInBoundaries(newPositionFromBegin, formatted, format)\r\n};\r\n\r\nfunction isSeparatorBasedString(text) {\r\n    return 1 === text.length && !!text.match(/^[,.][0-9]*$/g)\r\n}\r\nexport const isCaretInBoundaries = function(caret, text, format) {\r\n    caret = getCaretWithOffset(caret, 0);\r\n    const boundaries = getCaretInBoundaries(caret, text, format);\r\n    return caret.start >= boundaries.start && caret.end <= boundaries.end\r\n};\r\nexport function getCaretInBoundaries(caret, text, format) {\r\n    caret = getCaretWithOffset(caret, 0);\r\n    const boundaries = getCaretBoundaries(text, format);\r\n    const adjustedCaret = {\r\n        start: fitIntoRange(caret.start, boundaries.start, boundaries.end),\r\n        end: fitIntoRange(caret.end, boundaries.start, boundaries.end)\r\n    };\r\n    return adjustedCaret\r\n}\r\nexport const getCaretOffset = function(previousText, newText, format) {\r\n    const previousBoundaries = getCaretBoundaries(previousText, format);\r\n    const newBoundaries = getCaretBoundaries(newText, format);\r\n    return newBoundaries.start - previousBoundaries.start\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}