{"ast":null,"code":"/**\r\n * DevExtreme (esm/common/core/localization/ldml/date.format.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport numberLocalization from \"../number\";\nconst ARABIC_COMMA = \"\\u060c\";\nconst FORMAT_SEPARATORS = \" .,:;/\\\\<>()-[]\\u060c\";\nconst AM_PM_PATTERN = \". m.\";\nconst checkDigit = function (char) {\n  const code = char && numberLocalization.convertDigits(char, false).charCodeAt(0);\n  const zeroCode = numberLocalization.convertDigits(\"0\", false).charCodeAt(0);\n  return zeroCode <= code && code < zeroCode + 10;\n};\nconst checkPatternContinue = function (text, patterns, index, isDigit) {\n  const char = text[index];\n  const nextChar = text[index + 1];\n  if (!isDigit) {\n    if (\".\" === char || \" \" === char && \". m.\" === text.slice(index - 1, index + 3)) {\n      return true;\n    }\n    if (\"-\" === char && !checkDigit(nextChar)) {\n      return true;\n    }\n  }\n  const isDigitChanged = isDigit && patterns.some(pattern => text[index] !== pattern[index]);\n  return FORMAT_SEPARATORS.indexOf(char) < 0 && isDigit === checkDigit(char) && (!isDigit || isDigitChanged);\n};\nconst getPatternStartIndex = function (defaultPattern, index) {\n  if (!checkDigit(defaultPattern[index])) {\n    while (index > 0 && !checkDigit(defaultPattern[index - 1]) && (\".\" === defaultPattern[index - 1] || FORMAT_SEPARATORS.indexOf(defaultPattern[index - 1]) < 0)) {\n      index--;\n    }\n  }\n  return index;\n};\nconst getDifference = function (defaultPattern, patterns, processedIndexes, isDigit) {\n  let i = 0;\n  const result = [];\n  const patternsFilter = function (pattern) {\n    return defaultPattern[i] !== pattern[i] && (void 0 === isDigit || checkDigit(defaultPattern[i]) === isDigit);\n  };\n  if (!Array.isArray(patterns)) {\n    patterns = [patterns];\n  }\n  for (i = 0; i < defaultPattern.length; i++) {\n    if (processedIndexes.indexOf(i) < 0 && patterns.filter(patternsFilter).length) {\n      i = getPatternStartIndex(defaultPattern, i);\n      do {\n        isDigit = checkDigit(defaultPattern[i]);\n        if (!result.length && !isDigit && checkDigit(patterns[0][i])) {\n          break;\n        }\n        result.push(i);\n        processedIndexes.unshift(i);\n        i++;\n      } while (defaultPattern[i] && checkPatternContinue(defaultPattern, patterns, i, isDigit));\n      break;\n    }\n  }\n  if (1 === result.length && (\"0\" === defaultPattern[processedIndexes[0] - 1] || \"\\u0660\" === defaultPattern[processedIndexes[0] - 1])) {\n    processedIndexes.unshift(processedIndexes[0] - 1);\n  }\n  return result;\n};\nconst replaceCharsCore = function (pattern, indexes, char, patternPositions) {\n  const baseCharIndex = indexes[0];\n  const patternIndex = baseCharIndex < patternPositions.length ? patternPositions[baseCharIndex] : baseCharIndex;\n  indexes.forEach(function (_, index) {\n    pattern = pattern.substr(0, patternIndex + index) + (char.length > 1 ? char[index] : char) + pattern.substr(patternIndex + index + 1);\n  });\n  if (1 === indexes.length) {\n    pattern = pattern.replace(\"0\" + char, char + char);\n    pattern = pattern.replace(\"\\u0660\" + char, char + char);\n  }\n  return pattern;\n};\nconst replaceChars = function (pattern, indexes, char, patternPositions) {\n  let i;\n  let index;\n  let patternIndex;\n  if (!checkDigit(pattern[indexes[0]] || \"0\")) {\n    const letterCount = Math.max(indexes.length <= 3 ? 3 : 4, char.length);\n    while (indexes.length > letterCount) {\n      index = indexes.pop();\n      patternIndex = patternPositions[index];\n      patternPositions[index] = -1;\n      for (i = index + 1; i < patternPositions.length; i++) {\n        patternPositions[i]--;\n      }\n      pattern = pattern.substr(0, patternIndex) + pattern.substr(patternIndex + 1);\n    }\n    index = indexes[indexes.length - 1] + 1, patternIndex = index < patternPositions.length ? patternPositions[index] : index;\n    while (indexes.length < letterCount) {\n      indexes.push(indexes[indexes.length - 1] + 1);\n      for (i = index; i < patternPositions.length; i++) {\n        patternPositions[i]++;\n      }\n      pattern = pattern.substr(0, patternIndex) + \" \" + pattern.substr(patternIndex);\n    }\n  }\n  pattern = replaceCharsCore(pattern, indexes, char, patternPositions);\n  return pattern;\n};\nconst formatValue = function (value, formatter) {\n  if (Array.isArray(value)) {\n    return value.map(function (value) {\n      return (formatter(value) || \"\").toString();\n    });\n  }\n  return (formatter(value) || \"\").toString();\n};\nconst ESCAPE_CHARS_REGEXP = /[a-zA-Z]/g;\nconst escapeChars = function (pattern, defaultPattern, processedIndexes, patternPositions) {\n  const escapeIndexes = defaultPattern.split(\"\").map(function (char, index) {\n    if (processedIndexes.indexOf(index) < 0 && (char.match(ESCAPE_CHARS_REGEXP) || \"'\" === char)) {\n      return patternPositions[index];\n    }\n    return -1;\n  });\n  pattern = pattern.split(\"\").map(function (char, index) {\n    let result = char;\n    const isCurrentCharEscaped = escapeIndexes.indexOf(index) >= 0;\n    const isPrevCharEscaped = index > 0 && escapeIndexes.indexOf(index - 1) >= 0;\n    const isNextCharEscaped = escapeIndexes.indexOf(index + 1) >= 0;\n    if (isCurrentCharEscaped) {\n      if (!isPrevCharEscaped) {\n        result = \"'\" + result;\n      }\n      if (!isNextCharEscaped) {\n        result += \"'\";\n      }\n    }\n    return result;\n  }).join(\"\");\n  return pattern;\n};\nexport const getFormat = function (formatter) {\n  const processedIndexes = [];\n  const defaultPattern = formatValue(new Date(2009, 8, 8, 6, 5, 4), formatter);\n  const patternPositions = defaultPattern.split(\"\").map(function (_, index) {\n    return index;\n  });\n  let result = defaultPattern;\n  const replacedPatterns = {};\n  const datePatterns = [{\n    date: new Date(2009, 8, 8, 6, 5, 4, 111),\n    pattern: \"S\"\n  }, {\n    date: new Date(2009, 8, 8, 6, 5, 2),\n    pattern: \"s\"\n  }, {\n    date: new Date(2009, 8, 8, 6, 2, 4),\n    pattern: \"m\"\n  }, {\n    date: new Date(2009, 8, 8, 18, 5, 4),\n    pattern: \"H\",\n    isDigit: true\n  }, {\n    date: new Date(2009, 8, 8, 2, 5, 4),\n    pattern: \"h\",\n    isDigit: true\n  }, {\n    date: new Date(2009, 8, 8, 18, 5, 4),\n    pattern: \"a\",\n    isDigit: false\n  }, {\n    date: new Date(2009, 8, 1, 6, 5, 4),\n    pattern: \"d\"\n  }, {\n    date: [new Date(2009, 8, 2, 6, 5, 4), new Date(2009, 8, 3, 6, 5, 4), new Date(2009, 8, 4, 6, 5, 4)],\n    pattern: \"E\"\n  }, {\n    date: new Date(2009, 9, 6, 6, 5, 4),\n    pattern: \"M\"\n  }, {\n    date: new Date(1998, 8, 8, 6, 5, 4),\n    pattern: \"y\"\n  }];\n  if (!result) {\n    return;\n  }\n  datePatterns.forEach(function (test) {\n    const diff = getDifference(defaultPattern, formatValue(test.date, formatter), processedIndexes, test.isDigit);\n    const pattern = \"M\" === test.pattern && !replacedPatterns.d ? \"L\" : test.pattern;\n    result = replaceChars(result, diff, pattern, patternPositions);\n    replacedPatterns[pattern] = diff.length;\n  });\n  result = escapeChars(result, defaultPattern, processedIndexes, patternPositions);\n  if (processedIndexes.length) {\n    return result;\n  }\n};","map":{"version":3,"names":["numberLocalization","ARABIC_COMMA","FORMAT_SEPARATORS","AM_PM_PATTERN","checkDigit","char","code","convertDigits","charCodeAt","zeroCode","checkPatternContinue","text","patterns","index","isDigit","nextChar","slice","isDigitChanged","some","pattern","indexOf","getPatternStartIndex","defaultPattern","getDifference","processedIndexes","i","result","patternsFilter","Array","isArray","length","filter","push","unshift","replaceCharsCore","indexes","patternPositions","baseCharIndex","patternIndex","forEach","_","substr","replace","replaceChars","letterCount","Math","max","pop","formatValue","value","formatter","map","toString","ESCAPE_CHARS_REGEXP","escapeChars","escapeIndexes","split","match","isCurrentCharEscaped","isPrevCharEscaped","isNextCharEscaped","join","getFormat","Date","replacedPatterns","datePatterns","date","test","diff","d"],"sources":["/home/nataf/Cours/world-cities-map/client/node_modules/devextreme/esm/common/core/localization/ldml/date.format.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/common/core/localization/ldml/date.format.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport numberLocalization from \"../number\";\r\nconst ARABIC_COMMA = \"\\u060c\";\r\nconst FORMAT_SEPARATORS = \" .,:;/\\\\<>()-[]\\u060c\";\r\nconst AM_PM_PATTERN = \". m.\";\r\nconst checkDigit = function(char) {\r\n    const code = char && numberLocalization.convertDigits(char, false).charCodeAt(0);\r\n    const zeroCode = numberLocalization.convertDigits(\"0\", false).charCodeAt(0);\r\n    return zeroCode <= code && code < zeroCode + 10\r\n};\r\nconst checkPatternContinue = function(text, patterns, index, isDigit) {\r\n    const char = text[index];\r\n    const nextChar = text[index + 1];\r\n    if (!isDigit) {\r\n        if (\".\" === char || \" \" === char && \". m.\" === text.slice(index - 1, index + 3)) {\r\n            return true\r\n        }\r\n        if (\"-\" === char && !checkDigit(nextChar)) {\r\n            return true\r\n        }\r\n    }\r\n    const isDigitChanged = isDigit && patterns.some((pattern => text[index] !== pattern[index]));\r\n    return FORMAT_SEPARATORS.indexOf(char) < 0 && isDigit === checkDigit(char) && (!isDigit || isDigitChanged)\r\n};\r\nconst getPatternStartIndex = function(defaultPattern, index) {\r\n    if (!checkDigit(defaultPattern[index])) {\r\n        while (index > 0 && !checkDigit(defaultPattern[index - 1]) && (\".\" === defaultPattern[index - 1] || FORMAT_SEPARATORS.indexOf(defaultPattern[index - 1]) < 0)) {\r\n            index--\r\n        }\r\n    }\r\n    return index\r\n};\r\nconst getDifference = function(defaultPattern, patterns, processedIndexes, isDigit) {\r\n    let i = 0;\r\n    const result = [];\r\n    const patternsFilter = function(pattern) {\r\n        return defaultPattern[i] !== pattern[i] && (void 0 === isDigit || checkDigit(defaultPattern[i]) === isDigit)\r\n    };\r\n    if (!Array.isArray(patterns)) {\r\n        patterns = [patterns]\r\n    }\r\n    for (i = 0; i < defaultPattern.length; i++) {\r\n        if (processedIndexes.indexOf(i) < 0 && patterns.filter(patternsFilter).length) {\r\n            i = getPatternStartIndex(defaultPattern, i);\r\n            do {\r\n                isDigit = checkDigit(defaultPattern[i]);\r\n                if (!result.length && !isDigit && checkDigit(patterns[0][i])) {\r\n                    break\r\n                }\r\n                result.push(i);\r\n                processedIndexes.unshift(i);\r\n                i++\r\n            } while (defaultPattern[i] && checkPatternContinue(defaultPattern, patterns, i, isDigit));\r\n            break\r\n        }\r\n    }\r\n    if (1 === result.length && (\"0\" === defaultPattern[processedIndexes[0] - 1] || \"\\u0660\" === defaultPattern[processedIndexes[0] - 1])) {\r\n        processedIndexes.unshift(processedIndexes[0] - 1)\r\n    }\r\n    return result\r\n};\r\nconst replaceCharsCore = function(pattern, indexes, char, patternPositions) {\r\n    const baseCharIndex = indexes[0];\r\n    const patternIndex = baseCharIndex < patternPositions.length ? patternPositions[baseCharIndex] : baseCharIndex;\r\n    indexes.forEach((function(_, index) {\r\n        pattern = pattern.substr(0, patternIndex + index) + (char.length > 1 ? char[index] : char) + pattern.substr(patternIndex + index + 1)\r\n    }));\r\n    if (1 === indexes.length) {\r\n        pattern = pattern.replace(\"0\" + char, char + char);\r\n        pattern = pattern.replace(\"\\u0660\" + char, char + char)\r\n    }\r\n    return pattern\r\n};\r\nconst replaceChars = function(pattern, indexes, char, patternPositions) {\r\n    let i;\r\n    let index;\r\n    let patternIndex;\r\n    if (!checkDigit(pattern[indexes[0]] || \"0\")) {\r\n        const letterCount = Math.max(indexes.length <= 3 ? 3 : 4, char.length);\r\n        while (indexes.length > letterCount) {\r\n            index = indexes.pop();\r\n            patternIndex = patternPositions[index];\r\n            patternPositions[index] = -1;\r\n            for (i = index + 1; i < patternPositions.length; i++) {\r\n                patternPositions[i]--\r\n            }\r\n            pattern = pattern.substr(0, patternIndex) + pattern.substr(patternIndex + 1)\r\n        }\r\n        index = indexes[indexes.length - 1] + 1, patternIndex = index < patternPositions.length ? patternPositions[index] : index;\r\n        while (indexes.length < letterCount) {\r\n            indexes.push(indexes[indexes.length - 1] + 1);\r\n            for (i = index; i < patternPositions.length; i++) {\r\n                patternPositions[i]++\r\n            }\r\n            pattern = pattern.substr(0, patternIndex) + \" \" + pattern.substr(patternIndex)\r\n        }\r\n    }\r\n    pattern = replaceCharsCore(pattern, indexes, char, patternPositions);\r\n    return pattern\r\n};\r\nconst formatValue = function(value, formatter) {\r\n    if (Array.isArray(value)) {\r\n        return value.map((function(value) {\r\n            return (formatter(value) || \"\").toString()\r\n        }))\r\n    }\r\n    return (formatter(value) || \"\").toString()\r\n};\r\nconst ESCAPE_CHARS_REGEXP = /[a-zA-Z]/g;\r\nconst escapeChars = function(pattern, defaultPattern, processedIndexes, patternPositions) {\r\n    const escapeIndexes = defaultPattern.split(\"\").map((function(char, index) {\r\n        if (processedIndexes.indexOf(index) < 0 && (char.match(ESCAPE_CHARS_REGEXP) || \"'\" === char)) {\r\n            return patternPositions[index]\r\n        }\r\n        return -1\r\n    }));\r\n    pattern = pattern.split(\"\").map((function(char, index) {\r\n        let result = char;\r\n        const isCurrentCharEscaped = escapeIndexes.indexOf(index) >= 0;\r\n        const isPrevCharEscaped = index > 0 && escapeIndexes.indexOf(index - 1) >= 0;\r\n        const isNextCharEscaped = escapeIndexes.indexOf(index + 1) >= 0;\r\n        if (isCurrentCharEscaped) {\r\n            if (!isPrevCharEscaped) {\r\n                result = \"'\" + result\r\n            }\r\n            if (!isNextCharEscaped) {\r\n                result += \"'\"\r\n            }\r\n        }\r\n        return result\r\n    })).join(\"\");\r\n    return pattern\r\n};\r\nexport const getFormat = function(formatter) {\r\n    const processedIndexes = [];\r\n    const defaultPattern = formatValue(new Date(2009, 8, 8, 6, 5, 4), formatter);\r\n    const patternPositions = defaultPattern.split(\"\").map((function(_, index) {\r\n        return index\r\n    }));\r\n    let result = defaultPattern;\r\n    const replacedPatterns = {};\r\n    const datePatterns = [{\r\n        date: new Date(2009, 8, 8, 6, 5, 4, 111),\r\n        pattern: \"S\"\r\n    }, {\r\n        date: new Date(2009, 8, 8, 6, 5, 2),\r\n        pattern: \"s\"\r\n    }, {\r\n        date: new Date(2009, 8, 8, 6, 2, 4),\r\n        pattern: \"m\"\r\n    }, {\r\n        date: new Date(2009, 8, 8, 18, 5, 4),\r\n        pattern: \"H\",\r\n        isDigit: true\r\n    }, {\r\n        date: new Date(2009, 8, 8, 2, 5, 4),\r\n        pattern: \"h\",\r\n        isDigit: true\r\n    }, {\r\n        date: new Date(2009, 8, 8, 18, 5, 4),\r\n        pattern: \"a\",\r\n        isDigit: false\r\n    }, {\r\n        date: new Date(2009, 8, 1, 6, 5, 4),\r\n        pattern: \"d\"\r\n    }, {\r\n        date: [new Date(2009, 8, 2, 6, 5, 4), new Date(2009, 8, 3, 6, 5, 4), new Date(2009, 8, 4, 6, 5, 4)],\r\n        pattern: \"E\"\r\n    }, {\r\n        date: new Date(2009, 9, 6, 6, 5, 4),\r\n        pattern: \"M\"\r\n    }, {\r\n        date: new Date(1998, 8, 8, 6, 5, 4),\r\n        pattern: \"y\"\r\n    }];\r\n    if (!result) {\r\n        return\r\n    }\r\n    datePatterns.forEach((function(test) {\r\n        const diff = getDifference(defaultPattern, formatValue(test.date, formatter), processedIndexes, test.isDigit);\r\n        const pattern = \"M\" === test.pattern && !replacedPatterns.d ? \"L\" : test.pattern;\r\n        result = replaceChars(result, diff, pattern, patternPositions);\r\n        replacedPatterns[pattern] = diff.length\r\n    }));\r\n    result = escapeChars(result, defaultPattern, processedIndexes, patternPositions);\r\n    if (processedIndexes.length) {\r\n        return result\r\n    }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}