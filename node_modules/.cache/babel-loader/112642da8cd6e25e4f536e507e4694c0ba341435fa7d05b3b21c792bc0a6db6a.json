{"ast":null,"code":"/**\r\n * DevExtreme (esm/__internal/ui/number_box/m_number_box.mask.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport eventsEngine from \"../../../common/core/events/core/events_engine\";\nimport { name as dxDblClickEvent } from \"../../../common/core/events/double_click\";\nimport { addNamespace, getChar, isCommandKeyPressed, normalizeKeyName } from \"../../../common/core/events/utils/index\";\nimport { getFormat as getLDMLFormat } from \"../../../common/core/localization/ldml/number\";\nimport number from \"../../../common/core/localization/number\";\nimport devices from \"../../../core/devices\";\nimport { ensureDefined, escapeRegExp } from \"../../../core/utils/common\";\nimport { fitIntoRange, inRange } from \"../../../core/utils/math\";\nimport { isDefined, isFunction, isNumeric, isString } from \"../../../core/utils/type\";\nimport NumberBoxBase from \"./m_number_box.base\";\nimport { getCaretAfterFormat, getCaretBoundaries, getCaretInBoundaries, getCaretOffset, getCaretWithOffset, isCaretInBoundaries } from \"./m_number_box.caret\";\nimport { adjustPercentValue, getNthOccurrence, getRealSeparatorIndex, splitByIndex } from \"./m_utils\";\nconst NUMBER_FORMATTER_NAMESPACE = \"dxNumberFormatter\";\nconst MOVE_FORWARD = 1;\nconst MOVE_BACKWARD = -1;\nconst MINUS = \"-\";\nconst MINUS_KEY = \"minus\";\nconst INPUT_EVENT = \"input\";\nconst NUMPAD_DOT_KEY_CODE = 110;\nconst CARET_TIMEOUT_DURATION = 0;\nclass NumberBoxMask extends NumberBoxBase {\n  _getDefaultOptions() {\n    return _extends({}, super._getDefaultOptions(), {\n      useMaskBehavior: true,\n      format: null\n    });\n  }\n  _isDeleteKey(key) {\n    return \"del\" === key;\n  }\n  _supportedKeys() {\n    if (!this._useMaskBehavior()) {\n      return super._supportedKeys();\n    }\n    return _extends({}, super._supportedKeys(), {\n      minus: this._revertSign.bind(this),\n      del: this._removeHandler.bind(this),\n      backspace: this._removeHandler.bind(this),\n      leftArrow: this._arrowHandler.bind(this, -1),\n      rightArrow: this._arrowHandler.bind(this, 1),\n      home: this._moveCaretToBoundaryEventHandler.bind(this, 1),\n      enter: this._updateFormattedValue.bind(this),\n      end: this._moveCaretToBoundaryEventHandler.bind(this, -1)\n    });\n  }\n  _getTextSeparatorIndex(text) {\n    const decimalSeparator = number.getDecimalSeparator();\n    const realSeparatorOccurrenceIndex = getRealSeparatorIndex(this.option(\"format\")).occurrence;\n    return getNthOccurrence(text, decimalSeparator, realSeparatorOccurrenceIndex);\n  }\n  _focusInHandler(e) {\n    if (!this._preventNestedFocusEvent(e)) {\n      this.clearCaretTimeout();\n      this._caretTimeout = setTimeout(() => {\n        this._caretTimeout = void 0;\n        const caret = this._caret();\n        if (caret.start === caret.end && this._useMaskBehavior()) {\n          const text = this._getInputVal();\n          const decimalSeparatorIndex = this._getTextSeparatorIndex(text);\n          if (decimalSeparatorIndex >= 0) {\n            this._caret({\n              start: decimalSeparatorIndex,\n              end: decimalSeparatorIndex\n            });\n          } else {\n            this._moveCaretToBoundaryEventHandler(-1, e);\n          }\n        }\n      }, 0);\n    }\n    super._focusInHandler(e);\n  }\n  _focusOutHandler(e) {\n    const shouldHandleEvent = !this._preventNestedFocusEvent(e);\n    if (shouldHandleEvent) {\n      this._focusOutOccurs = true;\n      if (this._useMaskBehavior()) {\n        this._updateFormattedValue();\n      }\n    }\n    super._focusOutHandler(e);\n    if (shouldHandleEvent) {\n      this._focusOutOccurs = false;\n    }\n  }\n  _hasValueBeenChanged(inputValue) {\n    const format = this._getFormatPattern();\n    const value = this.option(\"value\");\n    const formatted = this._format(value, format) || \"\";\n    return formatted !== inputValue;\n  }\n  _updateFormattedValue() {\n    const inputValue = this._getInputVal();\n    if (this._hasValueBeenChanged(inputValue)) {\n      this._updateParsedValue();\n      this._adjustParsedValue();\n      this._setTextByParsedValue();\n      const {\n        value: value\n      } = this.option();\n      if (this._parsedValue !== value) {\n        eventsEngine.trigger(this._input(), \"change\");\n      }\n    }\n  }\n  _arrowHandler(step, e) {\n    if (!this._useMaskBehavior()) {\n      return;\n    }\n    const text = this._getInputVal();\n    const format = this._getFormatPattern();\n    let nextCaret = getCaretWithOffset(this._caret(), step);\n    if (!isCaretInBoundaries(nextCaret, text, format)) {\n      nextCaret = 1 === step ? nextCaret.end : nextCaret.start;\n      e.preventDefault();\n      this._caret(getCaretInBoundaries(nextCaret, text, format));\n    }\n  }\n  _moveCaretToBoundary(direction) {\n    const boundaries = getCaretBoundaries(this._getInputVal(), this._getFormatPattern());\n    const newCaret = getCaretWithOffset(1 === direction ? boundaries.start : boundaries.end, 0);\n    this._caret(newCaret);\n  }\n  _moveCaretToBoundaryEventHandler(direction, e) {\n    if (!this._useMaskBehavior() || null !== e && void 0 !== e && e.shiftKey) {\n      return;\n    }\n    this._moveCaretToBoundary(direction);\n    null === e || void 0 === e || e.preventDefault();\n  }\n  _shouldMoveCaret(text, caret) {\n    const decimalSeparator = number.getDecimalSeparator();\n    const isDecimalSeparatorNext = text.charAt(caret.end) === decimalSeparator;\n    const moveToFloat = (this._lastKey === decimalSeparator || \".\" === this._lastKey || \",\" === this._lastKey) && isDecimalSeparatorNext;\n    return moveToFloat;\n  }\n  _getInputVal() {\n    return number.convertDigits(this._input().val(), true);\n  }\n  _keyboardHandler(e) {\n    this.clearCaretTimeout();\n    this._lastKey = number.convertDigits(getChar(e), true);\n    this._lastKeyName = normalizeKeyName(e);\n    if (!this._shouldHandleKey(e.originalEvent)) {\n      return super._keyboardHandler(e);\n    }\n    const normalizedText = this._getInputVal();\n    const caret = this._caret();\n    let enteredChar;\n    if (\"minus\" === this._lastKeyName) {\n      enteredChar = \"\";\n    } else {\n      enteredChar = 110 === e.which ? number.getDecimalSeparator() : this._lastKey;\n    }\n    const newValue = this._tryParse(normalizedText, caret, enteredChar);\n    if (this._shouldMoveCaret(normalizedText, caret)) {\n      this._moveCaret(1);\n      e.originalEvent.preventDefault();\n    }\n    if (void 0 === newValue) {\n      if (\"minus\" !== this._lastKeyName) {\n        e.originalEvent.preventDefault();\n      }\n    } else {\n      this._parsedValue = newValue;\n    }\n    return super._keyboardHandler(e);\n  }\n  _keyPressHandler(e) {\n    if (!this._useMaskBehavior()) {\n      super._keyPressHandler(e);\n    }\n  }\n  _removeHandler(e) {\n    const caret = this._caret();\n    const text = this._getInputVal();\n    let {\n      start: start\n    } = caret;\n    let {\n      end: end\n    } = caret;\n    this._lastKey = getChar(e);\n    this._lastKeyName = normalizeKeyName(e);\n    const isDeleteKey = this._isDeleteKey(this._lastKeyName);\n    const isBackspaceKey = !isDeleteKey;\n    if (start === end) {\n      const caretPosition = start;\n      const canDelete = isBackspaceKey && caretPosition > 0 || isDeleteKey && caretPosition < text.length;\n      if (canDelete) {\n        isDeleteKey && end++;\n        isBackspaceKey && start--;\n      } else {\n        e.preventDefault();\n        return;\n      }\n    }\n    const char = text.slice(start, end);\n    if (this._isStub(char)) {\n      this._moveCaret(isDeleteKey ? 1 : -1);\n      if (this._parsedValue < 0 || 1 / this._parsedValue === -1 / 0) {\n        this._revertSign(e);\n        this._setTextByParsedValue();\n        const shouldTriggerInputEvent = this.option(\"valueChangeEvent\").split(\" \").includes(\"input\");\n        if (shouldTriggerInputEvent) {\n          eventsEngine.trigger(this._input(), \"input\");\n        }\n      }\n      e.preventDefault();\n      return;\n    }\n    const decimalSeparator = number.getDecimalSeparator();\n    if (char === decimalSeparator) {\n      const decimalSeparatorIndex = text.indexOf(decimalSeparator);\n      if (this._isNonStubAfter(decimalSeparatorIndex + 1)) {\n        this._moveCaret(isDeleteKey ? 1 : -1);\n        e.preventDefault();\n      }\n      return;\n    }\n    if (end - start < text.length) {\n      const editedText = this._replaceSelectedText(text, {\n        start: start,\n        end: end\n      }, \"\");\n      const noDigits = editedText.search(/[0-9]/) < 0;\n      if (noDigits && this._isValueInRange(0)) {\n        this._parsedValue = this._parsedValue < 0 || 1 / this._parsedValue === -1 / 0 ? -0 : 0;\n        return;\n      }\n    }\n    const valueAfterRemoving = this._tryParse(text, {\n      start: start,\n      end: end\n    }, \"\");\n    if (void 0 === valueAfterRemoving) {\n      e.preventDefault();\n    } else {\n      this._parsedValue = valueAfterRemoving;\n    }\n  }\n  _isPercentFormat() {\n    const format = this._getFormatPattern();\n    const noEscapedFormat = format.replace(/'[^']+'/g, \"\");\n    return -1 !== noEscapedFormat.indexOf(\"%\");\n  }\n  _parse(text, format) {\n    const formatOption = this.option(\"format\");\n    const isCustomParser = isFunction(formatOption.parser);\n    const parser = isCustomParser ? formatOption.parser : number.parse;\n    let integerPartStartIndex = 0;\n    if (!isCustomParser) {\n      const formatPointIndex = getRealSeparatorIndex(format).index;\n      const textPointIndex = this._getTextSeparatorIndex(text);\n      const formatIntegerPartLength = -1 !== formatPointIndex ? formatPointIndex : format.length;\n      const textIntegerPartLength = -1 !== textPointIndex ? textPointIndex : text.length;\n      if (textIntegerPartLength > formatIntegerPartLength && -1 === format.indexOf(\"#\")) {\n        integerPartStartIndex = textIntegerPartLength - formatIntegerPartLength;\n      }\n    }\n    text = text.substr(integerPartStartIndex);\n    return parser(text, format);\n  }\n  _format(value, format) {\n    const formatOption = this.option(\"format\");\n    const customFormatter = (null === formatOption || void 0 === formatOption ? void 0 : formatOption.formatter) || formatOption;\n    const formatter = isFunction(customFormatter) ? customFormatter : number.format;\n    const formattedValue = null === value ? \"\" : formatter(value, format);\n    return formattedValue;\n  }\n  _getFormatPattern() {\n    if (!this._currentFormat) {\n      this._updateFormat();\n    }\n    return this._currentFormat;\n  }\n  _updateFormat() {\n    const {\n      format: format\n    } = this.option();\n    const isCustomParser = isFunction(null === format || void 0 === format ? void 0 : format.parser);\n    const isLDMLPattern = isString(format) && (format.includes(\"0\") || format.includes(\"#\"));\n    const isExponentialFormat = \"exponential\" === format || \"exponential\" === (null === format || void 0 === format ? void 0 : format.type);\n    const shouldUseFormatAsIs = isCustomParser || isLDMLPattern || isExponentialFormat;\n    this._currentFormat = shouldUseFormatAsIs ? format : getLDMLFormat(value => {\n      const text = this._format(value, format);\n      return number.convertDigits(text, true);\n    });\n  }\n  _getFormatForSign(text) {\n    const format = this._getFormatPattern();\n    if (isString(format)) {\n      const signParts = format.split(\";\");\n      const sign = number.getSign(text, format);\n      signParts[1] = signParts[1] || `-${signParts[0]}`;\n      return sign < 0 ? signParts[1] : signParts[0];\n    }\n    const sign = number.getSign(text);\n    return sign < 0 ? \"-\" : \"\";\n  }\n  _removeStubs(text, excludeComma) {\n    const format = this._getFormatForSign(text);\n    const thousandsSeparator = number.getThousandsSeparator();\n    const stubs = this._getStubs(format);\n    let result = text;\n    if (stubs.length) {\n      const prefixStubs = stubs[0];\n      const postfixRegex = new RegExp(`(${escapeRegExp(stubs[1] || \"\")})$`, \"g\");\n      const decoratorsRegex = new RegExp(`[-${escapeRegExp(excludeComma ? \"\" : thousandsSeparator)}]`, \"g\");\n      result = result.replace(prefixStubs, \"\").replace(postfixRegex, \"\").replace(decoratorsRegex, \"\");\n    }\n    return result;\n  }\n  _getStubs(format) {\n    const regExpResult = /[^']([#0.,]+)/g.exec(format);\n    const pattern = regExpResult && regExpResult[0].trim();\n    return format.split(pattern).map(stub => stub.replace(/'/g, \"\"));\n  }\n  _truncateToPrecision(value, maxPrecision) {\n    if (isDefined(value)) {\n      const strValue = value.toString();\n      const decimalSeparatorIndex = strValue.indexOf(\".\");\n      if (strValue && decimalSeparatorIndex > -1) {\n        const parsedValue = parseFloat(strValue.substr(0, decimalSeparatorIndex + maxPrecision + 1));\n        return isNaN(parsedValue) ? value : parsedValue;\n      }\n    }\n    return value;\n  }\n  _tryParse(text, selection, char) {\n    const isTextSelected = selection.start !== selection.end;\n    const isWholeTextSelected = isTextSelected && 0 === selection.start && selection.end === text.length;\n    const decimalSeparator = number.getDecimalSeparator();\n    if (isWholeTextSelected && char === decimalSeparator) {\n      return 0;\n    }\n    const editedText = this._replaceSelectedText(text, selection, char);\n    const format = this._getFormatPattern();\n    let parsedValue = this._getParsedValue(editedText, format);\n    const maxPrecision = !format.parser && this._getPrecisionLimits(editedText).max;\n    const isValueChanged = parsedValue !== this._parsedValue;\n    const isDecimalPointRestricted = char === decimalSeparator && 0 === maxPrecision;\n    const isUselessCharRestricted = !isTextSelected && !isValueChanged && \"-\" !== char && this._isStub(char);\n    if (isDecimalPointRestricted || isUselessCharRestricted) {\n      return;\n    }\n    if (\"\" === this._removeStubs(editedText)) {\n      parsedValue = Math.abs(0 * this._parsedValue);\n    }\n    if (isNaN(parsedValue)) {\n      return;\n    }\n    const value = null === parsedValue ? this._parsedValue : parsedValue;\n    parsedValue = maxPrecision ? this._truncateToPrecision(value, maxPrecision) : parsedValue;\n    if (!format.parser && this._isPercentFormat()) {\n      const interval = this._getIntervalFromPrecision(maxPrecision);\n      return adjustPercentValue(parsedValue, interval);\n    }\n    return parsedValue;\n  }\n  _getIntervalFromPrecision(precision) {\n    if (precision < 1) {\n      return 1;\n    }\n    return 10 ** -precision;\n  }\n  _getParsedValue(text, format) {\n    const sign = number.getSign(text, (null === format || void 0 === format ? void 0 : format.formatter) || format);\n    const textWithoutStubs = this._removeStubs(text, true);\n    const parsedValue = this._parse(textWithoutStubs, format);\n    const parsedValueSign = parsedValue < 0 ? -1 : 1;\n    const parsedValueWithSign = isNumeric(parsedValue) && sign !== parsedValueSign ? sign * parsedValue : parsedValue;\n    return parsedValueWithSign;\n  }\n  _isValueIncomplete(text) {\n    if (!this._useMaskBehavior()) {\n      return super._isValueIncomplete(text);\n    }\n    const caret = this._caret();\n    const point = number.getDecimalSeparator();\n    const pointIndex = this._getTextSeparatorIndex(text);\n    const isCaretOnFloat = pointIndex >= 0 && pointIndex < caret.start;\n    const textParts = this._removeStubs(text, true).split(point);\n    if (!isCaretOnFloat || 2 !== textParts.length) {\n      return false;\n    }\n    const floatLength = textParts[1].length;\n    const format = this._getFormatPattern();\n    const isCustomParser = !!format.parser;\n    const precision = !isCustomParser && this._getPrecisionLimits(this._getFormatPattern());\n    const isPrecisionInRange = isCustomParser ? true : inRange(floatLength, precision.min, precision.max);\n    const endsWithZero = \"0\" === textParts[1].charAt(floatLength - 1);\n    return isPrecisionInRange && (endsWithZero || !floatLength);\n  }\n  _isValueInRange(value) {\n    const min = ensureDefined(this.option(\"min\"), -1 / 0);\n    const max = ensureDefined(this.option(\"max\"), 1 / 0);\n    return inRange(value, min, max);\n  }\n  _setInputText(text) {\n    const normalizedText = number.convertDigits(text, true);\n    const newCaret = getCaretAfterFormat(this._getInputVal(), normalizedText, this._caret(), this._getFormatPattern());\n    this._input().val(text);\n    this._toggleEmptinessEventHandler();\n    this._formattedValue = text;\n    if (!this._focusOutOccurs) {\n      this._caret(newCaret);\n    }\n  }\n  _useMaskBehavior() {\n    const {\n      useMaskBehavior: useMaskBehavior\n    } = this.option();\n    return !!this.option(\"format\") && useMaskBehavior;\n  }\n  _renderInputType() {\n    const {\n      mode: mode\n    } = this.option();\n    const isNumberType = \"number\" === mode;\n    const isDesktop = \"desktop\" === devices.real().deviceType;\n    if (this._useMaskBehavior() && isNumberType) {\n      this._setInputType(isDesktop || this._isSupportInputMode() ? \"text\" : \"tel\");\n    } else {\n      super._renderInputType();\n    }\n  }\n  _isChar(str) {\n    return isString(str) && 1 === str.length;\n  }\n  _moveCaret(offset) {\n    if (!offset) {\n      return;\n    }\n    const newCaret = getCaretWithOffset(this._caret(), offset);\n    const adjustedCaret = getCaretInBoundaries(newCaret, this._getInputVal(), this._getFormatPattern());\n    this._caret(adjustedCaret);\n  }\n  _shouldHandleKey(e) {\n    const keyName = normalizeKeyName(e);\n    const isSpecialChar = isCommandKeyPressed(e) || e.altKey || e.shiftKey || !this._isChar(keyName);\n    const isMinusKey = \"minus\" === keyName;\n    const useMaskBehavior = this._useMaskBehavior();\n    return useMaskBehavior && !isSpecialChar && !isMinusKey;\n  }\n  _renderInput() {\n    super._renderInput();\n    this._renderFormatter();\n  }\n  _renderFormatter() {\n    this._clearCache();\n    this._detachFormatterEvents();\n    if (this._useMaskBehavior()) {\n      this._attachFormatterEvents();\n    }\n  }\n  _detachFormatterEvents() {\n    eventsEngine.off(this._input(), \".dxNumberFormatter\");\n  }\n  _isInputFromPaste(e) {\n    var _e$originalEvent;\n    const inputType = null === (_e$originalEvent = e.originalEvent) || void 0 === _e$originalEvent ? void 0 : _e$originalEvent.inputType;\n    if (isDefined(inputType)) {\n      return \"insertFromPaste\" === inputType;\n    }\n    return this._isValuePasted;\n  }\n  _attachFormatterEvents() {\n    const $input = this._input();\n    eventsEngine.on($input, addNamespace(\"input\", \"dxNumberFormatter\"), e => {\n      this._formatValue(e);\n      this._isValuePasted = false;\n    });\n    eventsEngine.on($input, addNamespace(\"dxclick\", \"dxNumberFormatter\"), () => {\n      if (!this._caretTimeout) {\n        this._caretTimeout = setTimeout(() => {\n          this._caretTimeout = void 0;\n          this._caret(getCaretInBoundaries(this._caret(), this._getInputVal(), this._getFormatPattern()));\n        }, 0);\n      }\n    });\n    eventsEngine.on($input, dxDblClickEvent, () => {\n      this.clearCaretTimeout();\n    });\n  }\n  clearCaretTimeout() {\n    clearTimeout(this._caretTimeout);\n    this._caretTimeout = void 0;\n  }\n  _forceRefreshInputValue() {\n    if (!this._useMaskBehavior()) {\n      return super._forceRefreshInputValue();\n    }\n  }\n  _isNonStubAfter(index) {\n    const text = this._getInputVal().slice(index);\n    return text && !this._isStub(text, true);\n  }\n  _isStub(str, isString) {\n    const escapedDecimalSeparator = escapeRegExp(number.getDecimalSeparator());\n    const regExpString = `^[^0-9${escapedDecimalSeparator}]+$`;\n    const stubRegExp = new RegExp(regExpString, \"g\");\n    return stubRegExp.test(str) && (isString || this._isChar(str));\n  }\n  _parseValue(text) {\n    if (!this._useMaskBehavior()) {\n      return super._parseValue(text);\n    }\n    return this._parsedValue;\n  }\n  _getPrecisionLimits(text) {\n    const currentFormat = this._getFormatForSign(text);\n    const realSeparatorIndex = getRealSeparatorIndex(currentFormat).index;\n    const floatPart = (splitByIndex(currentFormat, realSeparatorIndex)[1] || \"\").replace(/[^#0]/g, \"\");\n    const minPrecision = floatPart.replace(/^(0*)#*/, \"$1\").length;\n    const maxPrecision = floatPart.length;\n    return {\n      min: minPrecision,\n      max: maxPrecision\n    };\n  }\n  _revertSign(e) {\n    if (!this._useMaskBehavior()) {\n      return;\n    }\n    const caret = this._caret();\n    if (caret.start !== caret.end) {\n      if (\"minus\" === normalizeKeyName(e)) {\n        this._applyRevertedSign(e, caret, true);\n        return;\n      }\n      this._caret(getCaretInBoundaries(0, this._getInputVal(), this._getFormatPattern()));\n    }\n    this._applyRevertedSign(e, caret);\n  }\n  _applyRevertedSign(e, caret, preserveSelectedText) {\n    const newValue = -1 * ensureDefined(this._parsedValue, null);\n    if (this._isValueInRange(newValue) || 0 === newValue) {\n      this._parsedValue = newValue;\n      if (preserveSelectedText) {\n        const format = this._getFormatPattern();\n        const previousText = this._getInputVal();\n        this._setTextByParsedValue();\n        e.preventDefault();\n        const currentText = this._getInputVal();\n        const offset = getCaretOffset(previousText, currentText, format);\n        caret = getCaretWithOffset(caret, offset);\n        const caretInBoundaries = getCaretInBoundaries(caret, currentText, format);\n        this._caret(caretInBoundaries);\n      }\n    }\n  }\n  _removeMinusFromText(text, caret) {\n    const isMinusPressed = \"minus\" === this._lastKeyName && \"-\" === text.charAt(caret.start - 1);\n    return isMinusPressed ? this._replaceSelectedText(text, {\n      start: caret.start - 1,\n      end: caret.start\n    }, \"\") : text;\n  }\n  _setTextByParsedValue() {\n    const format = this._getFormatPattern();\n    const parsed = this._parseValue();\n    const formatted = this._format(parsed, format) || \"\";\n    this._setInputText(formatted);\n  }\n  _formatValue(e) {\n    let normalizedText = this._getInputVal();\n    const caret = this._caret();\n    const textWithoutMinus = this._removeMinusFromText(normalizedText, caret);\n    const wasMinusRemoved = textWithoutMinus !== normalizedText;\n    normalizedText = textWithoutMinus;\n    if (!this._isInputFromPaste(e) && this._isValueIncomplete(textWithoutMinus)) {\n      this._formattedValue = normalizedText;\n      if (wasMinusRemoved) {\n        this._setTextByParsedValue();\n      }\n      return;\n    }\n    const textWasChanged = number.convertDigits(this._formattedValue, true) !== normalizedText;\n    if (textWasChanged) {\n      const value = this._tryParse(normalizedText, caret, \"\");\n      if (isDefined(value)) {\n        this._parsedValue = value;\n      }\n    }\n    this._setTextByParsedValue();\n  }\n  _renderDisplayText() {\n    if (this._useMaskBehavior()) {\n      this._toggleEmptinessEventHandler();\n    } else {\n      super._renderDisplayText.apply(this, arguments);\n    }\n  }\n  _renderValue() {\n    if (this._useMaskBehavior()) {\n      const {\n        value: value\n      } = this.option();\n      this._parsedValue = value;\n      this._setTextByParsedValue();\n    }\n    return super._renderValue();\n  }\n  _updateParsedValue() {\n    const inputValue = this._getInputVal();\n    this._parsedValue = this._tryParse(inputValue, this._caret());\n  }\n  _adjustParsedValue() {\n    if (!this._useMaskBehavior()) {\n      return;\n    }\n    const clearedText = this._removeStubs(this._getInputVal());\n    const parsedValue = clearedText ? this._parseValue() : null;\n    if (!isNumeric(parsedValue)) {\n      this._parsedValue = parsedValue;\n      return;\n    }\n    this._parsedValue = fitIntoRange(parsedValue, this.option(\"min\"), this.option(\"max\"));\n  }\n  _valueChangeEventHandler(e) {\n    if (!this._useMaskBehavior()) {\n      return super._valueChangeEventHandler(e);\n    }\n    const caret = this._caret();\n    this._saveValueChangeEvent(e);\n    this._lastKey = null;\n    this._lastKeyName = null;\n    this._updateParsedValue();\n    this._adjustParsedValue();\n    this.option(\"value\", this._parsedValue);\n    if (caret) {\n      this._caret(caret);\n    }\n  }\n  _optionChanged(args) {\n    switch (args.name) {\n      case \"format\":\n      case \"useMaskBehavior\":\n        this._renderInputType();\n        this._updateFormat();\n        this._renderFormatter();\n        this._renderValue();\n        this._refreshValueChangeEvent();\n        this._refreshEvents();\n        break;\n      case \"min\":\n      case \"max\":\n        this._adjustParsedValue();\n        super._optionChanged(args);\n        break;\n      default:\n        super._optionChanged(args);\n    }\n  }\n  _clearCache() {\n    delete this._formattedValue;\n    delete this._lastKey;\n    delete this._lastKeyName;\n    delete this._parsedValue;\n    delete this._focusOutOccurs;\n    clearTimeout(this._caretTimeout);\n    delete this._caretTimeout;\n  }\n  _clean() {\n    this._clearCache();\n    super._clean();\n  }\n}\nexport default NumberBoxMask;","map":{"version":3,"names":["_extends","eventsEngine","name","dxDblClickEvent","addNamespace","getChar","isCommandKeyPressed","normalizeKeyName","getFormat","getLDMLFormat","number","devices","ensureDefined","escapeRegExp","fitIntoRange","inRange","isDefined","isFunction","isNumeric","isString","NumberBoxBase","getCaretAfterFormat","getCaretBoundaries","getCaretInBoundaries","getCaretOffset","getCaretWithOffset","isCaretInBoundaries","adjustPercentValue","getNthOccurrence","getRealSeparatorIndex","splitByIndex","NUMBER_FORMATTER_NAMESPACE","MOVE_FORWARD","MOVE_BACKWARD","MINUS","MINUS_KEY","INPUT_EVENT","NUMPAD_DOT_KEY_CODE","CARET_TIMEOUT_DURATION","NumberBoxMask","_getDefaultOptions","useMaskBehavior","format","_isDeleteKey","key","_supportedKeys","_useMaskBehavior","minus","_revertSign","bind","del","_removeHandler","backspace","leftArrow","_arrowHandler","rightArrow","home","_moveCaretToBoundaryEventHandler","enter","_updateFormattedValue","end","_getTextSeparatorIndex","text","decimalSeparator","getDecimalSeparator","realSeparatorOccurrenceIndex","option","occurrence","_focusInHandler","e","_preventNestedFocusEvent","clearCaretTimeout","_caretTimeout","setTimeout","caret","_caret","start","_getInputVal","decimalSeparatorIndex","_focusOutHandler","shouldHandleEvent","_focusOutOccurs","_hasValueBeenChanged","inputValue","_getFormatPattern","value","formatted","_format","_updateParsedValue","_adjustParsedValue","_setTextByParsedValue","_parsedValue","trigger","_input","step","nextCaret","preventDefault","_moveCaretToBoundary","direction","boundaries","newCaret","shiftKey","_shouldMoveCaret","isDecimalSeparatorNext","charAt","moveToFloat","_lastKey","convertDigits","val","_keyboardHandler","_lastKeyName","_shouldHandleKey","originalEvent","normalizedText","enteredChar","which","newValue","_tryParse","_moveCaret","_keyPressHandler","isDeleteKey","isBackspaceKey","caretPosition","canDelete","length","char","slice","_isStub","shouldTriggerInputEvent","split","includes","indexOf","_isNonStubAfter","editedText","_replaceSelectedText","noDigits","search","_isValueInRange","valueAfterRemoving","_isPercentFormat","noEscapedFormat","replace","_parse","formatOption","isCustomParser","parser","parse","integerPartStartIndex","formatPointIndex","index","textPointIndex","formatIntegerPartLength","textIntegerPartLength","substr","customFormatter","formatter","formattedValue","_currentFormat","_updateFormat","isLDMLPattern","isExponentialFormat","type","shouldUseFormatAsIs","_getFormatForSign","signParts","sign","getSign","_removeStubs","excludeComma","thousandsSeparator","getThousandsSeparator","stubs","_getStubs","result","prefixStubs","postfixRegex","RegExp","decoratorsRegex","regExpResult","exec","pattern","trim","map","stub","_truncateToPrecision","maxPrecision","strValue","toString","parsedValue","parseFloat","isNaN","selection","isTextSelected","isWholeTextSelected","_getParsedValue","_getPrecisionLimits","max","isValueChanged","isDecimalPointRestricted","isUselessCharRestricted","Math","abs","interval","_getIntervalFromPrecision","precision","textWithoutStubs","parsedValueSign","parsedValueWithSign","_isValueIncomplete","point","pointIndex","isCaretOnFloat","textParts","floatLength","isPrecisionInRange","min","endsWithZero","_setInputText","_toggleEmptinessEventHandler","_formattedValue","_renderInputType","mode","isNumberType","isDesktop","real","deviceType","_setInputType","_isSupportInputMode","_isChar","str","offset","adjustedCaret","keyName","isSpecialChar","altKey","isMinusKey","_renderInput","_renderFormatter","_clearCache","_detachFormatterEvents","_attachFormatterEvents","off","_isInputFromPaste","_e$originalEvent","inputType","_isValuePasted","$input","on","_formatValue","clearTimeout","_forceRefreshInputValue","escapedDecimalSeparator","regExpString","stubRegExp","test","_parseValue","currentFormat","realSeparatorIndex","floatPart","minPrecision","_applyRevertedSign","preserveSelectedText","previousText","currentText","caretInBoundaries","_removeMinusFromText","isMinusPressed","parsed","textWithoutMinus","wasMinusRemoved","textWasChanged","_renderDisplayText","apply","arguments","_renderValue","clearedText","_valueChangeEventHandler","_saveValueChangeEvent","_optionChanged","args","_refreshValueChangeEvent","_refreshEvents","_clean"],"sources":["/home/nataf/Cours/world-cities-map/client/node_modules/devextreme/esm/__internal/ui/number_box/m_number_box.mask.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/__internal/ui/number_box/m_number_box.mask.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\r\nimport eventsEngine from \"../../../common/core/events/core/events_engine\";\r\nimport {\r\n    name as dxDblClickEvent\r\n} from \"../../../common/core/events/double_click\";\r\nimport {\r\n    addNamespace,\r\n    getChar,\r\n    isCommandKeyPressed,\r\n    normalizeKeyName\r\n} from \"../../../common/core/events/utils/index\";\r\nimport {\r\n    getFormat as getLDMLFormat\r\n} from \"../../../common/core/localization/ldml/number\";\r\nimport number from \"../../../common/core/localization/number\";\r\nimport devices from \"../../../core/devices\";\r\nimport {\r\n    ensureDefined,\r\n    escapeRegExp\r\n} from \"../../../core/utils/common\";\r\nimport {\r\n    fitIntoRange,\r\n    inRange\r\n} from \"../../../core/utils/math\";\r\nimport {\r\n    isDefined,\r\n    isFunction,\r\n    isNumeric,\r\n    isString\r\n} from \"../../../core/utils/type\";\r\nimport NumberBoxBase from \"./m_number_box.base\";\r\nimport {\r\n    getCaretAfterFormat,\r\n    getCaretBoundaries,\r\n    getCaretInBoundaries,\r\n    getCaretOffset,\r\n    getCaretWithOffset,\r\n    isCaretInBoundaries\r\n} from \"./m_number_box.caret\";\r\nimport {\r\n    adjustPercentValue,\r\n    getNthOccurrence,\r\n    getRealSeparatorIndex,\r\n    splitByIndex\r\n} from \"./m_utils\";\r\nconst NUMBER_FORMATTER_NAMESPACE = \"dxNumberFormatter\";\r\nconst MOVE_FORWARD = 1;\r\nconst MOVE_BACKWARD = -1;\r\nconst MINUS = \"-\";\r\nconst MINUS_KEY = \"minus\";\r\nconst INPUT_EVENT = \"input\";\r\nconst NUMPAD_DOT_KEY_CODE = 110;\r\nconst CARET_TIMEOUT_DURATION = 0;\r\nclass NumberBoxMask extends NumberBoxBase {\r\n    _getDefaultOptions() {\r\n        return _extends({}, super._getDefaultOptions(), {\r\n            useMaskBehavior: true,\r\n            format: null\r\n        })\r\n    }\r\n    _isDeleteKey(key) {\r\n        return \"del\" === key\r\n    }\r\n    _supportedKeys() {\r\n        if (!this._useMaskBehavior()) {\r\n            return super._supportedKeys()\r\n        }\r\n        return _extends({}, super._supportedKeys(), {\r\n            minus: this._revertSign.bind(this),\r\n            del: this._removeHandler.bind(this),\r\n            backspace: this._removeHandler.bind(this),\r\n            leftArrow: this._arrowHandler.bind(this, -1),\r\n            rightArrow: this._arrowHandler.bind(this, 1),\r\n            home: this._moveCaretToBoundaryEventHandler.bind(this, 1),\r\n            enter: this._updateFormattedValue.bind(this),\r\n            end: this._moveCaretToBoundaryEventHandler.bind(this, -1)\r\n        })\r\n    }\r\n    _getTextSeparatorIndex(text) {\r\n        const decimalSeparator = number.getDecimalSeparator();\r\n        const realSeparatorOccurrenceIndex = getRealSeparatorIndex(this.option(\"format\")).occurrence;\r\n        return getNthOccurrence(text, decimalSeparator, realSeparatorOccurrenceIndex)\r\n    }\r\n    _focusInHandler(e) {\r\n        if (!this._preventNestedFocusEvent(e)) {\r\n            this.clearCaretTimeout();\r\n            this._caretTimeout = setTimeout((() => {\r\n                this._caretTimeout = void 0;\r\n                const caret = this._caret();\r\n                if (caret.start === caret.end && this._useMaskBehavior()) {\r\n                    const text = this._getInputVal();\r\n                    const decimalSeparatorIndex = this._getTextSeparatorIndex(text);\r\n                    if (decimalSeparatorIndex >= 0) {\r\n                        this._caret({\r\n                            start: decimalSeparatorIndex,\r\n                            end: decimalSeparatorIndex\r\n                        })\r\n                    } else {\r\n                        this._moveCaretToBoundaryEventHandler(-1, e)\r\n                    }\r\n                }\r\n            }), 0)\r\n        }\r\n        super._focusInHandler(e)\r\n    }\r\n    _focusOutHandler(e) {\r\n        const shouldHandleEvent = !this._preventNestedFocusEvent(e);\r\n        if (shouldHandleEvent) {\r\n            this._focusOutOccurs = true;\r\n            if (this._useMaskBehavior()) {\r\n                this._updateFormattedValue()\r\n            }\r\n        }\r\n        super._focusOutHandler(e);\r\n        if (shouldHandleEvent) {\r\n            this._focusOutOccurs = false\r\n        }\r\n    }\r\n    _hasValueBeenChanged(inputValue) {\r\n        const format = this._getFormatPattern();\r\n        const value = this.option(\"value\");\r\n        const formatted = this._format(value, format) || \"\";\r\n        return formatted !== inputValue\r\n    }\r\n    _updateFormattedValue() {\r\n        const inputValue = this._getInputVal();\r\n        if (this._hasValueBeenChanged(inputValue)) {\r\n            this._updateParsedValue();\r\n            this._adjustParsedValue();\r\n            this._setTextByParsedValue();\r\n            const {\r\n                value: value\r\n            } = this.option();\r\n            if (this._parsedValue !== value) {\r\n                eventsEngine.trigger(this._input(), \"change\")\r\n            }\r\n        }\r\n    }\r\n    _arrowHandler(step, e) {\r\n        if (!this._useMaskBehavior()) {\r\n            return\r\n        }\r\n        const text = this._getInputVal();\r\n        const format = this._getFormatPattern();\r\n        let nextCaret = getCaretWithOffset(this._caret(), step);\r\n        if (!isCaretInBoundaries(nextCaret, text, format)) {\r\n            nextCaret = 1 === step ? nextCaret.end : nextCaret.start;\r\n            e.preventDefault();\r\n            this._caret(getCaretInBoundaries(nextCaret, text, format))\r\n        }\r\n    }\r\n    _moveCaretToBoundary(direction) {\r\n        const boundaries = getCaretBoundaries(this._getInputVal(), this._getFormatPattern());\r\n        const newCaret = getCaretWithOffset(1 === direction ? boundaries.start : boundaries.end, 0);\r\n        this._caret(newCaret)\r\n    }\r\n    _moveCaretToBoundaryEventHandler(direction, e) {\r\n        if (!this._useMaskBehavior() || null !== e && void 0 !== e && e.shiftKey) {\r\n            return\r\n        }\r\n        this._moveCaretToBoundary(direction);\r\n        null === e || void 0 === e || e.preventDefault()\r\n    }\r\n    _shouldMoveCaret(text, caret) {\r\n        const decimalSeparator = number.getDecimalSeparator();\r\n        const isDecimalSeparatorNext = text.charAt(caret.end) === decimalSeparator;\r\n        const moveToFloat = (this._lastKey === decimalSeparator || \".\" === this._lastKey || \",\" === this._lastKey) && isDecimalSeparatorNext;\r\n        return moveToFloat\r\n    }\r\n    _getInputVal() {\r\n        return number.convertDigits(this._input().val(), true)\r\n    }\r\n    _keyboardHandler(e) {\r\n        this.clearCaretTimeout();\r\n        this._lastKey = number.convertDigits(getChar(e), true);\r\n        this._lastKeyName = normalizeKeyName(e);\r\n        if (!this._shouldHandleKey(e.originalEvent)) {\r\n            return super._keyboardHandler(e)\r\n        }\r\n        const normalizedText = this._getInputVal();\r\n        const caret = this._caret();\r\n        let enteredChar;\r\n        if (\"minus\" === this._lastKeyName) {\r\n            enteredChar = \"\"\r\n        } else {\r\n            enteredChar = 110 === e.which ? number.getDecimalSeparator() : this._lastKey\r\n        }\r\n        const newValue = this._tryParse(normalizedText, caret, enteredChar);\r\n        if (this._shouldMoveCaret(normalizedText, caret)) {\r\n            this._moveCaret(1);\r\n            e.originalEvent.preventDefault()\r\n        }\r\n        if (void 0 === newValue) {\r\n            if (\"minus\" !== this._lastKeyName) {\r\n                e.originalEvent.preventDefault()\r\n            }\r\n        } else {\r\n            this._parsedValue = newValue\r\n        }\r\n        return super._keyboardHandler(e)\r\n    }\r\n    _keyPressHandler(e) {\r\n        if (!this._useMaskBehavior()) {\r\n            super._keyPressHandler(e)\r\n        }\r\n    }\r\n    _removeHandler(e) {\r\n        const caret = this._caret();\r\n        const text = this._getInputVal();\r\n        let {\r\n            start: start\r\n        } = caret;\r\n        let {\r\n            end: end\r\n        } = caret;\r\n        this._lastKey = getChar(e);\r\n        this._lastKeyName = normalizeKeyName(e);\r\n        const isDeleteKey = this._isDeleteKey(this._lastKeyName);\r\n        const isBackspaceKey = !isDeleteKey;\r\n        if (start === end) {\r\n            const caretPosition = start;\r\n            const canDelete = isBackspaceKey && caretPosition > 0 || isDeleteKey && caretPosition < text.length;\r\n            if (canDelete) {\r\n                isDeleteKey && end++;\r\n                isBackspaceKey && start--\r\n            } else {\r\n                e.preventDefault();\r\n                return\r\n            }\r\n        }\r\n        const char = text.slice(start, end);\r\n        if (this._isStub(char)) {\r\n            this._moveCaret(isDeleteKey ? 1 : -1);\r\n            if (this._parsedValue < 0 || 1 / this._parsedValue === -1 / 0) {\r\n                this._revertSign(e);\r\n                this._setTextByParsedValue();\r\n                const shouldTriggerInputEvent = this.option(\"valueChangeEvent\").split(\" \").includes(\"input\");\r\n                if (shouldTriggerInputEvent) {\r\n                    eventsEngine.trigger(this._input(), \"input\")\r\n                }\r\n            }\r\n            e.preventDefault();\r\n            return\r\n        }\r\n        const decimalSeparator = number.getDecimalSeparator();\r\n        if (char === decimalSeparator) {\r\n            const decimalSeparatorIndex = text.indexOf(decimalSeparator);\r\n            if (this._isNonStubAfter(decimalSeparatorIndex + 1)) {\r\n                this._moveCaret(isDeleteKey ? 1 : -1);\r\n                e.preventDefault()\r\n            }\r\n            return\r\n        }\r\n        if (end - start < text.length) {\r\n            const editedText = this._replaceSelectedText(text, {\r\n                start: start,\r\n                end: end\r\n            }, \"\");\r\n            const noDigits = editedText.search(/[0-9]/) < 0;\r\n            if (noDigits && this._isValueInRange(0)) {\r\n                this._parsedValue = this._parsedValue < 0 || 1 / this._parsedValue === -1 / 0 ? -0 : 0;\r\n                return\r\n            }\r\n        }\r\n        const valueAfterRemoving = this._tryParse(text, {\r\n            start: start,\r\n            end: end\r\n        }, \"\");\r\n        if (void 0 === valueAfterRemoving) {\r\n            e.preventDefault()\r\n        } else {\r\n            this._parsedValue = valueAfterRemoving\r\n        }\r\n    }\r\n    _isPercentFormat() {\r\n        const format = this._getFormatPattern();\r\n        const noEscapedFormat = format.replace(/'[^']+'/g, \"\");\r\n        return -1 !== noEscapedFormat.indexOf(\"%\")\r\n    }\r\n    _parse(text, format) {\r\n        const formatOption = this.option(\"format\");\r\n        const isCustomParser = isFunction(formatOption.parser);\r\n        const parser = isCustomParser ? formatOption.parser : number.parse;\r\n        let integerPartStartIndex = 0;\r\n        if (!isCustomParser) {\r\n            const formatPointIndex = getRealSeparatorIndex(format).index;\r\n            const textPointIndex = this._getTextSeparatorIndex(text);\r\n            const formatIntegerPartLength = -1 !== formatPointIndex ? formatPointIndex : format.length;\r\n            const textIntegerPartLength = -1 !== textPointIndex ? textPointIndex : text.length;\r\n            if (textIntegerPartLength > formatIntegerPartLength && -1 === format.indexOf(\"#\")) {\r\n                integerPartStartIndex = textIntegerPartLength - formatIntegerPartLength\r\n            }\r\n        }\r\n        text = text.substr(integerPartStartIndex);\r\n        return parser(text, format)\r\n    }\r\n    _format(value, format) {\r\n        const formatOption = this.option(\"format\");\r\n        const customFormatter = (null === formatOption || void 0 === formatOption ? void 0 : formatOption.formatter) || formatOption;\r\n        const formatter = isFunction(customFormatter) ? customFormatter : number.format;\r\n        const formattedValue = null === value ? \"\" : formatter(value, format);\r\n        return formattedValue\r\n    }\r\n    _getFormatPattern() {\r\n        if (!this._currentFormat) {\r\n            this._updateFormat()\r\n        }\r\n        return this._currentFormat\r\n    }\r\n    _updateFormat() {\r\n        const {\r\n            format: format\r\n        } = this.option();\r\n        const isCustomParser = isFunction(null === format || void 0 === format ? void 0 : format.parser);\r\n        const isLDMLPattern = isString(format) && (format.includes(\"0\") || format.includes(\"#\"));\r\n        const isExponentialFormat = \"exponential\" === format || \"exponential\" === (null === format || void 0 === format ? void 0 : format.type);\r\n        const shouldUseFormatAsIs = isCustomParser || isLDMLPattern || isExponentialFormat;\r\n        this._currentFormat = shouldUseFormatAsIs ? format : getLDMLFormat((value => {\r\n            const text = this._format(value, format);\r\n            return number.convertDigits(text, true)\r\n        }))\r\n    }\r\n    _getFormatForSign(text) {\r\n        const format = this._getFormatPattern();\r\n        if (isString(format)) {\r\n            const signParts = format.split(\";\");\r\n            const sign = number.getSign(text, format);\r\n            signParts[1] = signParts[1] || `-${signParts[0]}`;\r\n            return sign < 0 ? signParts[1] : signParts[0]\r\n        }\r\n        const sign = number.getSign(text);\r\n        return sign < 0 ? \"-\" : \"\"\r\n    }\r\n    _removeStubs(text, excludeComma) {\r\n        const format = this._getFormatForSign(text);\r\n        const thousandsSeparator = number.getThousandsSeparator();\r\n        const stubs = this._getStubs(format);\r\n        let result = text;\r\n        if (stubs.length) {\r\n            const prefixStubs = stubs[0];\r\n            const postfixRegex = new RegExp(`(${escapeRegExp(stubs[1]||\"\")})$`, \"g\");\r\n            const decoratorsRegex = new RegExp(`[-${escapeRegExp(excludeComma?\"\":thousandsSeparator)}]`, \"g\");\r\n            result = result.replace(prefixStubs, \"\").replace(postfixRegex, \"\").replace(decoratorsRegex, \"\")\r\n        }\r\n        return result\r\n    }\r\n    _getStubs(format) {\r\n        const regExpResult = /[^']([#0.,]+)/g.exec(format);\r\n        const pattern = regExpResult && regExpResult[0].trim();\r\n        return format.split(pattern).map((stub => stub.replace(/'/g, \"\")))\r\n    }\r\n    _truncateToPrecision(value, maxPrecision) {\r\n        if (isDefined(value)) {\r\n            const strValue = value.toString();\r\n            const decimalSeparatorIndex = strValue.indexOf(\".\");\r\n            if (strValue && decimalSeparatorIndex > -1) {\r\n                const parsedValue = parseFloat(strValue.substr(0, decimalSeparatorIndex + maxPrecision + 1));\r\n                return isNaN(parsedValue) ? value : parsedValue\r\n            }\r\n        }\r\n        return value\r\n    }\r\n    _tryParse(text, selection, char) {\r\n        const isTextSelected = selection.start !== selection.end;\r\n        const isWholeTextSelected = isTextSelected && 0 === selection.start && selection.end === text.length;\r\n        const decimalSeparator = number.getDecimalSeparator();\r\n        if (isWholeTextSelected && char === decimalSeparator) {\r\n            return 0\r\n        }\r\n        const editedText = this._replaceSelectedText(text, selection, char);\r\n        const format = this._getFormatPattern();\r\n        let parsedValue = this._getParsedValue(editedText, format);\r\n        const maxPrecision = !format.parser && this._getPrecisionLimits(editedText).max;\r\n        const isValueChanged = parsedValue !== this._parsedValue;\r\n        const isDecimalPointRestricted = char === decimalSeparator && 0 === maxPrecision;\r\n        const isUselessCharRestricted = !isTextSelected && !isValueChanged && \"-\" !== char && this._isStub(char);\r\n        if (isDecimalPointRestricted || isUselessCharRestricted) {\r\n            return\r\n        }\r\n        if (\"\" === this._removeStubs(editedText)) {\r\n            parsedValue = Math.abs(0 * this._parsedValue)\r\n        }\r\n        if (isNaN(parsedValue)) {\r\n            return\r\n        }\r\n        const value = null === parsedValue ? this._parsedValue : parsedValue;\r\n        parsedValue = maxPrecision ? this._truncateToPrecision(value, maxPrecision) : parsedValue;\r\n        if (!format.parser && this._isPercentFormat()) {\r\n            const interval = this._getIntervalFromPrecision(maxPrecision);\r\n            return adjustPercentValue(parsedValue, interval)\r\n        }\r\n        return parsedValue\r\n    }\r\n    _getIntervalFromPrecision(precision) {\r\n        if (precision < 1) {\r\n            return 1\r\n        }\r\n        return 10 ** -precision\r\n    }\r\n    _getParsedValue(text, format) {\r\n        const sign = number.getSign(text, (null === format || void 0 === format ? void 0 : format.formatter) || format);\r\n        const textWithoutStubs = this._removeStubs(text, true);\r\n        const parsedValue = this._parse(textWithoutStubs, format);\r\n        const parsedValueSign = parsedValue < 0 ? -1 : 1;\r\n        const parsedValueWithSign = isNumeric(parsedValue) && sign !== parsedValueSign ? sign * parsedValue : parsedValue;\r\n        return parsedValueWithSign\r\n    }\r\n    _isValueIncomplete(text) {\r\n        if (!this._useMaskBehavior()) {\r\n            return super._isValueIncomplete(text)\r\n        }\r\n        const caret = this._caret();\r\n        const point = number.getDecimalSeparator();\r\n        const pointIndex = this._getTextSeparatorIndex(text);\r\n        const isCaretOnFloat = pointIndex >= 0 && pointIndex < caret.start;\r\n        const textParts = this._removeStubs(text, true).split(point);\r\n        if (!isCaretOnFloat || 2 !== textParts.length) {\r\n            return false\r\n        }\r\n        const floatLength = textParts[1].length;\r\n        const format = this._getFormatPattern();\r\n        const isCustomParser = !!format.parser;\r\n        const precision = !isCustomParser && this._getPrecisionLimits(this._getFormatPattern());\r\n        const isPrecisionInRange = isCustomParser ? true : inRange(floatLength, precision.min, precision.max);\r\n        const endsWithZero = \"0\" === textParts[1].charAt(floatLength - 1);\r\n        return isPrecisionInRange && (endsWithZero || !floatLength)\r\n    }\r\n    _isValueInRange(value) {\r\n        const min = ensureDefined(this.option(\"min\"), -1 / 0);\r\n        const max = ensureDefined(this.option(\"max\"), 1 / 0);\r\n        return inRange(value, min, max)\r\n    }\r\n    _setInputText(text) {\r\n        const normalizedText = number.convertDigits(text, true);\r\n        const newCaret = getCaretAfterFormat(this._getInputVal(), normalizedText, this._caret(), this._getFormatPattern());\r\n        this._input().val(text);\r\n        this._toggleEmptinessEventHandler();\r\n        this._formattedValue = text;\r\n        if (!this._focusOutOccurs) {\r\n            this._caret(newCaret)\r\n        }\r\n    }\r\n    _useMaskBehavior() {\r\n        const {\r\n            useMaskBehavior: useMaskBehavior\r\n        } = this.option();\r\n        return !!this.option(\"format\") && useMaskBehavior\r\n    }\r\n    _renderInputType() {\r\n        const {\r\n            mode: mode\r\n        } = this.option();\r\n        const isNumberType = \"number\" === mode;\r\n        const isDesktop = \"desktop\" === devices.real().deviceType;\r\n        if (this._useMaskBehavior() && isNumberType) {\r\n            this._setInputType(isDesktop || this._isSupportInputMode() ? \"text\" : \"tel\")\r\n        } else {\r\n            super._renderInputType()\r\n        }\r\n    }\r\n    _isChar(str) {\r\n        return isString(str) && 1 === str.length\r\n    }\r\n    _moveCaret(offset) {\r\n        if (!offset) {\r\n            return\r\n        }\r\n        const newCaret = getCaretWithOffset(this._caret(), offset);\r\n        const adjustedCaret = getCaretInBoundaries(newCaret, this._getInputVal(), this._getFormatPattern());\r\n        this._caret(adjustedCaret)\r\n    }\r\n    _shouldHandleKey(e) {\r\n        const keyName = normalizeKeyName(e);\r\n        const isSpecialChar = isCommandKeyPressed(e) || e.altKey || e.shiftKey || !this._isChar(keyName);\r\n        const isMinusKey = \"minus\" === keyName;\r\n        const useMaskBehavior = this._useMaskBehavior();\r\n        return useMaskBehavior && !isSpecialChar && !isMinusKey\r\n    }\r\n    _renderInput() {\r\n        super._renderInput();\r\n        this._renderFormatter()\r\n    }\r\n    _renderFormatter() {\r\n        this._clearCache();\r\n        this._detachFormatterEvents();\r\n        if (this._useMaskBehavior()) {\r\n            this._attachFormatterEvents()\r\n        }\r\n    }\r\n    _detachFormatterEvents() {\r\n        eventsEngine.off(this._input(), \".dxNumberFormatter\")\r\n    }\r\n    _isInputFromPaste(e) {\r\n        var _e$originalEvent;\r\n        const inputType = null === (_e$originalEvent = e.originalEvent) || void 0 === _e$originalEvent ? void 0 : _e$originalEvent.inputType;\r\n        if (isDefined(inputType)) {\r\n            return \"insertFromPaste\" === inputType\r\n        }\r\n        return this._isValuePasted\r\n    }\r\n    _attachFormatterEvents() {\r\n        const $input = this._input();\r\n        eventsEngine.on($input, addNamespace(\"input\", \"dxNumberFormatter\"), (e => {\r\n            this._formatValue(e);\r\n            this._isValuePasted = false\r\n        }));\r\n        eventsEngine.on($input, addNamespace(\"dxclick\", \"dxNumberFormatter\"), (() => {\r\n            if (!this._caretTimeout) {\r\n                this._caretTimeout = setTimeout((() => {\r\n                    this._caretTimeout = void 0;\r\n                    this._caret(getCaretInBoundaries(this._caret(), this._getInputVal(), this._getFormatPattern()))\r\n                }), 0)\r\n            }\r\n        }));\r\n        eventsEngine.on($input, dxDblClickEvent, (() => {\r\n            this.clearCaretTimeout()\r\n        }))\r\n    }\r\n    clearCaretTimeout() {\r\n        clearTimeout(this._caretTimeout);\r\n        this._caretTimeout = void 0\r\n    }\r\n    _forceRefreshInputValue() {\r\n        if (!this._useMaskBehavior()) {\r\n            return super._forceRefreshInputValue()\r\n        }\r\n    }\r\n    _isNonStubAfter(index) {\r\n        const text = this._getInputVal().slice(index);\r\n        return text && !this._isStub(text, true)\r\n    }\r\n    _isStub(str, isString) {\r\n        const escapedDecimalSeparator = escapeRegExp(number.getDecimalSeparator());\r\n        const regExpString = `^[^0-9${escapedDecimalSeparator}]+$`;\r\n        const stubRegExp = new RegExp(regExpString, \"g\");\r\n        return stubRegExp.test(str) && (isString || this._isChar(str))\r\n    }\r\n    _parseValue(text) {\r\n        if (!this._useMaskBehavior()) {\r\n            return super._parseValue(text)\r\n        }\r\n        return this._parsedValue\r\n    }\r\n    _getPrecisionLimits(text) {\r\n        const currentFormat = this._getFormatForSign(text);\r\n        const realSeparatorIndex = getRealSeparatorIndex(currentFormat).index;\r\n        const floatPart = (splitByIndex(currentFormat, realSeparatorIndex)[1] || \"\").replace(/[^#0]/g, \"\");\r\n        const minPrecision = floatPart.replace(/^(0*)#*/, \"$1\").length;\r\n        const maxPrecision = floatPart.length;\r\n        return {\r\n            min: minPrecision,\r\n            max: maxPrecision\r\n        }\r\n    }\r\n    _revertSign(e) {\r\n        if (!this._useMaskBehavior()) {\r\n            return\r\n        }\r\n        const caret = this._caret();\r\n        if (caret.start !== caret.end) {\r\n            if (\"minus\" === normalizeKeyName(e)) {\r\n                this._applyRevertedSign(e, caret, true);\r\n                return\r\n            }\r\n            this._caret(getCaretInBoundaries(0, this._getInputVal(), this._getFormatPattern()))\r\n        }\r\n        this._applyRevertedSign(e, caret)\r\n    }\r\n    _applyRevertedSign(e, caret, preserveSelectedText) {\r\n        const newValue = -1 * ensureDefined(this._parsedValue, null);\r\n        if (this._isValueInRange(newValue) || 0 === newValue) {\r\n            this._parsedValue = newValue;\r\n            if (preserveSelectedText) {\r\n                const format = this._getFormatPattern();\r\n                const previousText = this._getInputVal();\r\n                this._setTextByParsedValue();\r\n                e.preventDefault();\r\n                const currentText = this._getInputVal();\r\n                const offset = getCaretOffset(previousText, currentText, format);\r\n                caret = getCaretWithOffset(caret, offset);\r\n                const caretInBoundaries = getCaretInBoundaries(caret, currentText, format);\r\n                this._caret(caretInBoundaries)\r\n            }\r\n        }\r\n    }\r\n    _removeMinusFromText(text, caret) {\r\n        const isMinusPressed = \"minus\" === this._lastKeyName && \"-\" === text.charAt(caret.start - 1);\r\n        return isMinusPressed ? this._replaceSelectedText(text, {\r\n            start: caret.start - 1,\r\n            end: caret.start\r\n        }, \"\") : text\r\n    }\r\n    _setTextByParsedValue() {\r\n        const format = this._getFormatPattern();\r\n        const parsed = this._parseValue();\r\n        const formatted = this._format(parsed, format) || \"\";\r\n        this._setInputText(formatted)\r\n    }\r\n    _formatValue(e) {\r\n        let normalizedText = this._getInputVal();\r\n        const caret = this._caret();\r\n        const textWithoutMinus = this._removeMinusFromText(normalizedText, caret);\r\n        const wasMinusRemoved = textWithoutMinus !== normalizedText;\r\n        normalizedText = textWithoutMinus;\r\n        if (!this._isInputFromPaste(e) && this._isValueIncomplete(textWithoutMinus)) {\r\n            this._formattedValue = normalizedText;\r\n            if (wasMinusRemoved) {\r\n                this._setTextByParsedValue()\r\n            }\r\n            return\r\n        }\r\n        const textWasChanged = number.convertDigits(this._formattedValue, true) !== normalizedText;\r\n        if (textWasChanged) {\r\n            const value = this._tryParse(normalizedText, caret, \"\");\r\n            if (isDefined(value)) {\r\n                this._parsedValue = value\r\n            }\r\n        }\r\n        this._setTextByParsedValue()\r\n    }\r\n    _renderDisplayText() {\r\n        if (this._useMaskBehavior()) {\r\n            this._toggleEmptinessEventHandler()\r\n        } else {\r\n            super._renderDisplayText.apply(this, arguments)\r\n        }\r\n    }\r\n    _renderValue() {\r\n        if (this._useMaskBehavior()) {\r\n            const {\r\n                value: value\r\n            } = this.option();\r\n            this._parsedValue = value;\r\n            this._setTextByParsedValue()\r\n        }\r\n        return super._renderValue()\r\n    }\r\n    _updateParsedValue() {\r\n        const inputValue = this._getInputVal();\r\n        this._parsedValue = this._tryParse(inputValue, this._caret())\r\n    }\r\n    _adjustParsedValue() {\r\n        if (!this._useMaskBehavior()) {\r\n            return\r\n        }\r\n        const clearedText = this._removeStubs(this._getInputVal());\r\n        const parsedValue = clearedText ? this._parseValue() : null;\r\n        if (!isNumeric(parsedValue)) {\r\n            this._parsedValue = parsedValue;\r\n            return\r\n        }\r\n        this._parsedValue = fitIntoRange(parsedValue, this.option(\"min\"), this.option(\"max\"))\r\n    }\r\n    _valueChangeEventHandler(e) {\r\n        if (!this._useMaskBehavior()) {\r\n            return super._valueChangeEventHandler(e)\r\n        }\r\n        const caret = this._caret();\r\n        this._saveValueChangeEvent(e);\r\n        this._lastKey = null;\r\n        this._lastKeyName = null;\r\n        this._updateParsedValue();\r\n        this._adjustParsedValue();\r\n        this.option(\"value\", this._parsedValue);\r\n        if (caret) {\r\n            this._caret(caret)\r\n        }\r\n    }\r\n    _optionChanged(args) {\r\n        switch (args.name) {\r\n            case \"format\":\r\n            case \"useMaskBehavior\":\r\n                this._renderInputType();\r\n                this._updateFormat();\r\n                this._renderFormatter();\r\n                this._renderValue();\r\n                this._refreshValueChangeEvent();\r\n                this._refreshEvents();\r\n                break;\r\n            case \"min\":\r\n            case \"max\":\r\n                this._adjustParsedValue();\r\n                super._optionChanged(args);\r\n                break;\r\n            default:\r\n                super._optionChanged(args)\r\n        }\r\n    }\r\n    _clearCache() {\r\n        delete this._formattedValue;\r\n        delete this._lastKey;\r\n        delete this._lastKeyName;\r\n        delete this._parsedValue;\r\n        delete this._focusOutOccurs;\r\n        clearTimeout(this._caretTimeout);\r\n        delete this._caretTimeout\r\n    }\r\n    _clean() {\r\n        this._clearCache();\r\n        super._clean()\r\n    }\r\n}\r\nexport default NumberBoxMask;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}